function yNe(e, t) {
  window.bridgeCommand(e, t);
}
function NNe() {
  let e;
  return [new Promise((n) => e = n), e];
}
var $;
(function(e) {
  e[e.Canceled = 1] = "Canceled", e[e.Unknown = 2] = "Unknown", e[e.InvalidArgument = 3] = "InvalidArgument", e[e.DeadlineExceeded = 4] = "DeadlineExceeded", e[e.NotFound = 5] = "NotFound", e[e.AlreadyExists = 6] = "AlreadyExists", e[e.PermissionDenied = 7] = "PermissionDenied", e[e.ResourceExhausted = 8] = "ResourceExhausted", e[e.FailedPrecondition = 9] = "FailedPrecondition", e[e.Aborted = 10] = "Aborted", e[e.OutOfRange = 11] = "OutOfRange", e[e.Unimplemented = 12] = "Unimplemented", e[e.Internal = 13] = "Internal", e[e.Unavailable = 14] = "Unavailable", e[e.DataLoss = 15] = "DataLoss", e[e.Unauthenticated = 16] = "Unauthenticated";
})($ || ($ = {}));
function uE(e, t) {
  return e !== null && typeof e == "object" && "$typeName" in e && typeof e.$typeName == "string" ? t === void 0 ? !0 : t.typeName === e.$typeName : !1;
}
var h;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(h || (h = {}));
function zG() {
  let e = 0, t = 0;
  for (let r = 0; r < 28; r += 7) {
    let a = this.buf[this.pos++];
    if (e |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  let n = this.buf[this.pos++];
  if (e |= (n & 15) << 28, t = (n & 112) >> 4, (n & 128) == 0)
    return this.assertBounds(), [e, t];
  for (let r = 3; r <= 31; r += 7) {
    let a = this.buf[this.pos++];
    if (t |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  throw new Error("invalid varint");
}
function Eg(e, t, n) {
  for (let o = 0; o < 28; o = o + 7) {
    const s = e >>> o, i = !(!(s >>> 7) && t == 0), u = (i ? s | 128 : s) & 255;
    if (n.push(u), !i)
      return;
  }
  const r = e >>> 28 & 15 | (t & 7) << 4, a = t >> 3 != 0;
  if (n.push((a ? r | 128 : r) & 255), !!a) {
    for (let o = 3; o < 31; o = o + 7) {
      const s = t >>> o, i = !!(s >>> 7), u = (i ? s | 128 : s) & 255;
      if (n.push(u), !i)
        return;
    }
    n.push(t >>> 31 & 1);
  }
}
const Cm = 4294967296;
function lI(e) {
  const t = e[0] === "-";
  t && (e = e.slice(1));
  const n = 1e6;
  let r = 0, a = 0;
  function o(s, i) {
    const u = Number(e.slice(s, i));
    a *= n, r = r * n + u, r >= Cm && (a = a + (r / Cm | 0), r = r % Cm);
  }
  return o(-24, -18), o(-18, -12), o(-12, -6), o(-6), t ? NL(r, a) : lE(r, a);
}
function qG(e, t) {
  let n = lE(e, t);
  const r = n.hi & 2147483648;
  r && (n = NL(n.lo, n.hi));
  const a = yL(n.lo, n.hi);
  return r ? "-" + a : a;
}
function yL(e, t) {
  if ({ lo: e, hi: t } = QG(e, t), t <= 2097151)
    return String(Cm * t + e);
  const n = e & 16777215, r = (e >>> 24 | t << 8) & 16777215, a = t >> 16 & 65535;
  let o = n + r * 6777216 + a * 6710656, s = r + a * 8147497, i = a * 2;
  const u = 1e7;
  return o >= u && (s += Math.floor(o / u), o %= u), s >= u && (i += Math.floor(s / u), s %= u), i.toString() + cI(s) + cI(o);
}
function QG(e, t) {
  return { lo: e >>> 0, hi: t >>> 0 };
}
function lE(e, t) {
  return { lo: e | 0, hi: t | 0 };
}
function NL(e, t) {
  return t = ~t, e ? e = ~e + 1 : t += 1, lE(e, t);
}
const cI = (e) => {
  const t = String(e);
  return "0000000".slice(t.length) + t;
};
function ay(e, t) {
  if (e >= 0) {
    for (; e > 127; )
      t.push(e & 127 | 128), e = e >>> 7;
    t.push(e);
  } else {
    for (let n = 0; n < 9; n++)
      t.push(e & 127 | 128), e = e >> 7;
    t.push(1);
  }
}
function eM() {
  let e = this.buf[this.pos++], t = e & 127;
  if ((e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 7, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 14, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 21, (e & 128) == 0)
    return this.assertBounds(), t;
  e = this.buf[this.pos++], t |= (e & 15) << 28;
  for (let n = 5; (e & 128) !== 0 && n < 10; n++)
    e = this.buf[this.pos++];
  if ((e & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
const X = /* @__PURE__ */ tM();
function tM() {
  const e = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof e.getBigInt64 == "function" && typeof e.getBigUint64 == "function" && typeof e.setBigInt64 == "function" && typeof e.setBigUint64 == "function" && (!!globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const n = BigInt("-9223372036854775808"), r = BigInt("9223372036854775807"), a = BigInt("0"), o = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(s) {
        const i = typeof s == "bigint" ? s : BigInt(s);
        if (i > r || i < n)
          throw new Error(`invalid int64: ${s}`);
        return i;
      },
      uParse(s) {
        const i = typeof s == "bigint" ? s : BigInt(s);
        if (i > o || i < a)
          throw new Error(`invalid uint64: ${s}`);
        return i;
      },
      enc(s) {
        return e.setBigInt64(0, this.parse(s), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      uEnc(s) {
        return e.setBigInt64(0, this.uParse(s), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      dec(s, i) {
        return e.setInt32(0, s, !0), e.setInt32(4, i, !0), e.getBigInt64(0, !0);
      },
      uDec(s, i) {
        return e.setInt32(0, s, !0), e.setInt32(4, i, !0), e.getBigUint64(0, !0);
      }
    };
  }
  return {
    zero: "0",
    supported: !1,
    parse(n) {
      return typeof n != "string" && (n = n.toString()), fI(n), n;
    },
    uParse(n) {
      return typeof n != "string" && (n = n.toString()), mI(n), n;
    },
    enc(n) {
      return typeof n != "string" && (n = n.toString()), fI(n), lI(n);
    },
    uEnc(n) {
      return typeof n != "string" && (n = n.toString()), mI(n), lI(n);
    },
    dec(n, r) {
      return qG(n, r);
    },
    uDec(n, r) {
      return yL(n, r);
    }
  };
}
function fI(e) {
  if (!/^-?[0-9]+$/.test(e))
    throw new Error("invalid int64: " + e);
}
function mI(e) {
  if (!/^[0-9]+$/.test(e))
    throw new Error("invalid uint64: " + e);
}
function Us(e, t) {
  switch (e) {
    case h.STRING:
      return "";
    case h.BOOL:
      return !1;
    case h.DOUBLE:
    case h.FLOAT:
      return 0;
    case h.INT64:
    case h.UINT64:
    case h.SFIXED64:
    case h.FIXED64:
    case h.SINT64:
      return t ? "0" : X.zero;
    case h.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function nM(e, t) {
  switch (e) {
    case h.BOOL:
      return t === !1;
    case h.STRING:
      return t === "";
    case h.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
const EL = 2, Sa = /* @__PURE__ */ Symbol.for("reflect unsafe local");
function vL(e, t) {
  const n = e[t.localName].case;
  return n === void 0 ? n : t.fields.find((r) => r.localName === n);
}
function rM(e, t) {
  const n = t.localName;
  if (t.oneof)
    return e[t.oneof.localName].case === n;
  if (t.presence != EL)
    return e[n] !== void 0 && Object.prototype.hasOwnProperty.call(e, n);
  switch (t.fieldKind) {
    case "list":
      return e[n].length > 0;
    case "map":
      return Object.keys(e[n]).length > 0;
    case "scalar":
      return !nM(t.scalar, e[n]);
    case "enum":
      return e[n] !== t.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function zu(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) && e[t] !== void 0;
}
function TL(e, t) {
  if (t.oneof) {
    const n = e[t.oneof.localName];
    return n.case === t.localName ? n.value : void 0;
  }
  return e[t.localName];
}
function IL(e, t, n) {
  t.oneof ? e[t.oneof.localName] = {
    case: t.localName,
    value: n
  } : e[t.localName] = n;
}
function aM(e, t) {
  const n = t.localName;
  if (t.oneof) {
    const r = t.oneof.localName;
    e[r].case === n && (e[r] = { case: void 0 });
  } else if (t.presence != EL)
    delete e[n];
  else
    switch (t.fieldKind) {
      case "map":
        e[n] = {};
        break;
      case "list":
        e[n] = [];
        break;
      case "enum":
        e[n] = t.enum.values[0].number;
        break;
      case "scalar":
        e[n] = Us(t.scalar, t.longAsString);
        break;
    }
}
function ho(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function cE(e, t) {
  var n, r, a, o;
  if (ho(e) && Sa in e && "add" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.listKind == i.listKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function fE(e, t) {
  var n, r, a, o;
  if (ho(e) && Sa in e && "has" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.mapKey === i.mapKey && s.mapKind == i.mapKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function mE(e, t) {
  return ho(e) && Sa in e && "desc" in e && ho(e.desc) && e.desc.kind === "message" && (t === void 0 || e.desc.typeName == t.typeName);
}
function oM(e) {
  return wL(e.$typeName);
}
function Uc(e) {
  const t = e.fields[0];
  return wL(e.typeName) && t !== void 0 && t.fieldKind == "scalar" && t.name == "value" && t.number == 1;
}
function wL(e) {
  return e.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(e.substring(16));
}
const sM = 999, iM = 998, Km = 2;
function mr(e, t) {
  if (uE(t, e))
    return t;
  const n = mM(e);
  return t !== void 0 && uM(e, n, t), n;
}
function uM(e, t, n) {
  for (const r of e.members) {
    let a = n[r.localName];
    if (a == null)
      continue;
    let o;
    if (r.kind == "oneof") {
      const s = vL(n, r);
      if (!s)
        continue;
      o = s, a = TL(n, s);
    } else
      o = r;
    switch (o.fieldKind) {
      case "message":
        a = dE(o, a);
        break;
      case "scalar":
        a = _L(o, a);
        break;
      case "list":
        a = cM(o, a);
        break;
      case "map":
        a = lM(o, a);
        break;
    }
    IL(t, o, a);
  }
  return t;
}
function _L(e, t) {
  return e.scalar == h.BYTES ? pE(t) : t;
}
function lM(e, t) {
  if (ho(t)) {
    if (e.scalar == h.BYTES)
      return dI(t, pE);
    if (e.mapKind == "message")
      return dI(t, (n) => dE(e, n));
  }
  return t;
}
function cM(e, t) {
  if (Array.isArray(t)) {
    if (e.scalar == h.BYTES)
      return t.map(pE);
    if (e.listKind == "message")
      return t.map((n) => dE(e, n));
  }
  return t;
}
function dE(e, t) {
  if (e.fieldKind == "message" && !e.oneof && Uc(e.message))
    return _L(e.message.fields[0], t);
  if (ho(t)) {
    if (e.message.typeName == "google.protobuf.Struct" && e.parent.typeName !== "google.protobuf.Value")
      return t;
    if (!uE(t, e.message))
      return mr(e.message, t);
  }
  return t;
}
function pE(e) {
  return Array.isArray(e) ? new Uint8Array(e) : e;
}
function dI(e, t) {
  const n = {};
  for (const r of Object.entries(e))
    n[r[0]] = t(r[1]);
  return n;
}
const fM = /* @__PURE__ */ Symbol(), pI = /* @__PURE__ */ new WeakMap();
function mM(e) {
  let t;
  if (dM(e)) {
    const n = pI.get(e);
    let r, a;
    if (n)
      ({ prototype: r, members: a } = n);
    else {
      r = {}, a = /* @__PURE__ */ new Set();
      for (const o of e.members)
        o.kind != "oneof" && (o.fieldKind != "scalar" && o.fieldKind != "enum" || o.presence != Km && (a.add(o), r[o.localName] = vg(o)));
      pI.set(e, { prototype: r, members: a });
    }
    t = Object.create(r), t.$typeName = e.typeName;
    for (const o of e.members)
      a.has(o) || o.kind == "field" && (o.fieldKind == "message" || (o.fieldKind == "scalar" || o.fieldKind == "enum") && o.presence != Km) || (t[o.localName] = vg(o));
  } else {
    t = {
      $typeName: e.typeName
    };
    for (const n of e.members)
      (n.kind == "oneof" || n.presence == Km) && (t[n.localName] = vg(n));
  }
  return t;
}
function dM(e) {
  switch (e.file.edition) {
    case sM:
      return !1;
    case iM:
      return !0;
    default:
      return e.fields.some((t) => t.presence != Km && t.fieldKind != "message" && !t.oneof);
  }
}
function vg(e) {
  if (e.kind == "oneof")
    return { case: void 0 };
  if (e.fieldKind == "list")
    return [];
  if (e.fieldKind == "map")
    return {};
  if (e.fieldKind == "message")
    return fM;
  const t = e.getDefaultValue();
  return t !== void 0 ? e.fieldKind == "scalar" && e.longAsString ? t.toString() : t : e.fieldKind == "scalar" ? Us(e.scalar, e.longAsString) : e.enum.values[0].number;
}
const pM = [
  "FieldValueInvalidError",
  "FieldListRangeError",
  "ForeignFieldError"
];
class Lt extends Error {
  constructor(t, n, r = "FieldValueInvalidError") {
    super(n), this.name = r, this.field = () => t;
  }
}
function bM(e) {
  return e instanceof Error && pM.includes(e.name) && "field" in e && typeof e.field == "function";
}
const Tg = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
function bE() {
  if (globalThis[Tg] == null) {
    const e = new globalThis.TextEncoder(), t = new globalThis.TextDecoder();
    globalThis[Tg] = {
      encodeUtf8(n) {
        return e.encode(n);
      },
      decodeUtf8(n) {
        return t.decode(n);
      },
      checkUtf8(n) {
        try {
          return encodeURIComponent(n), !0;
        } catch {
          return !1;
        }
      }
    };
  }
  return globalThis[Tg];
}
var ae;
(function(e) {
  e[e.Varint = 0] = "Varint", e[e.Bit64 = 1] = "Bit64", e[e.LengthDelimited = 2] = "LengthDelimited", e[e.StartGroup = 3] = "StartGroup", e[e.EndGroup = 4] = "EndGroup", e[e.Bit32 = 5] = "Bit32";
})(ae || (ae = {}));
const OL = 34028234663852886e22, SL = -34028234663852886e22, DL = 4294967295, kL = 2147483647, AL = -2147483648;
class LL {
  constructor(t = bE().encodeUtf8) {
    this.encodeUtf8 = t, this.stack = [], this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []);
    let t = 0;
    for (let a = 0; a < this.chunks.length; a++)
      t += this.chunks[a].length;
    let n = new Uint8Array(t), r = 0;
    for (let a = 0; a < this.chunks.length; a++)
      n.set(this.chunks[a], r), r += this.chunks[a].length;
    return this.chunks = [], n;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), n = this.stack.pop();
    if (!n)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = n.chunks, this.buf = n.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, n) {
    return this.uint32((t << 3 | n) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (bI(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return Ig(t), ay(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let n = this.encodeUtf8(t);
    return this.uint32(n.byteLength), this.raw(n);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    gM(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setFloat32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let n = new Uint8Array(8);
    return new DataView(n.buffer).setFloat64(0, t, !0), this.raw(n);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    bI(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    Ig(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setInt32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return Ig(t), t = (t << 1 ^ t >> 31) >>> 0, ay(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = X.enc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = X.uEnc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let n = X.enc(t);
    return Eg(n.lo, n.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    const n = X.enc(t), r = n.hi >> 31, a = n.lo << 1 ^ r, o = (n.hi << 1 | n.lo >>> 31) ^ r;
    return Eg(a, o, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    const n = X.uEnc(t);
    return Eg(n.lo, n.hi, this.buf), this;
  }
}
class gE {
  constructor(t, n = bE().decodeUtf8) {
    this.decodeUtf8 = n, this.varint64 = zG, this.uint32 = eM, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), n = t >>> 3, r = t & 7;
    if (n <= 0 || r < 0 || r > 5)
      throw new Error("illegal tag: field no " + n + " wire type " + r);
    return [n, r];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, n) {
    let r = this.pos;
    switch (t) {
      case ae.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case ae.Bit64:
        this.pos += 4;
      case ae.Bit32:
        this.pos += 4;
        break;
      case ae.LengthDelimited:
        let a = this.uint32();
        this.pos += a;
        break;
      case ae.StartGroup:
        for (; ; ) {
          const [o, s] = this.tag();
          if (s === ae.EndGroup) {
            if (n !== void 0 && o !== n)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(s, o);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return X.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return X.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, n] = this.varint64(), r = -(t & 1);
    return t = (t >>> 1 | (n & 1) << 31) ^ r, n = n >>> 1 ^ r, X.dec(t, n);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, n] = this.varint64();
    return t !== 0 || n !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return X.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return X.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), n = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(n, n + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function Ig(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid int32: " + typeof e);
  if (!Number.isInteger(e) || e > kL || e < AL)
    throw new Error("invalid int32: " + e);
}
function bI(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid uint32: " + typeof e);
  if (!Number.isInteger(e) || e > DL || e < 0)
    throw new Error("invalid uint32: " + e);
}
function gM(e) {
  if (typeof e == "string") {
    const t = e;
    if (e = Number(e), Number.isNaN(e) && t !== "NaN")
      throw new Error("invalid float32: " + t);
  } else if (typeof e != "number")
    throw new Error("invalid float32: " + typeof e);
  if (Number.isFinite(e) && (e > OL || e < SL))
    throw new Error("invalid float32: " + e);
}
function Do(e, t) {
  const n = e.fieldKind == "list" ? cE(t, e) : e.fieldKind == "map" ? fE(t, e) : hE(e, t);
  if (n === !0)
    return;
  let r;
  switch (e.fieldKind) {
    case "list":
      r = `expected ${RL(e)}, got ${Re(t)}`;
      break;
    case "map":
      r = `expected ${$L(e)}, got ${Re(t)}`;
      break;
    default:
      r = Nd(e, t, n);
  }
  return new Lt(e, r);
}
function gI(e, t, n) {
  const r = hE(e, n);
  if (r !== !0)
    return new Lt(e, `list item #${t + 1}: ${Nd(e, n, r)}`);
}
function hM(e, t, n) {
  const r = FL(t, e.mapKey);
  if (r !== !0)
    return new Lt(e, `invalid map key: ${Nd({ scalar: e.mapKey }, t, r)}`);
  const a = hE(e, n);
  if (a !== !0)
    return new Lt(e, `map entry ${Re(t)}: ${Nd(e, n, a)}`);
}
function hE(e, t) {
  return e.scalar !== void 0 ? FL(t, e.scalar) : e.enum !== void 0 ? e.enum.open ? Number.isInteger(t) : e.enum.values.some((n) => n.number === t) : mE(t, e.message);
}
function FL(e, t) {
  switch (t) {
    case h.DOUBLE:
      return typeof e == "number";
    case h.FLOAT:
      return typeof e != "number" ? !1 : Number.isNaN(e) || !Number.isFinite(e) ? !0 : e > OL || e < SL ? `${e.toFixed()} out of range` : !0;
    case h.INT32:
    case h.SFIXED32:
    case h.SINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > kL || e < AL ? `${e.toFixed()} out of range` : !0;
    case h.FIXED32:
    case h.UINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > DL || e < 0 ? `${e.toFixed()} out of range` : !0;
    case h.BOOL:
      return typeof e == "boolean";
    case h.STRING:
      return typeof e != "string" ? !1 : bE().checkUtf8(e) || "invalid UTF8";
    case h.BYTES:
      return e instanceof Uint8Array;
    case h.INT64:
    case h.SFIXED64:
    case h.SINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return X.parse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
    case h.FIXED64:
    case h.UINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return X.uParse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
  }
}
function Nd(e, t, n) {
  return n = typeof n == "string" ? `: ${n}` : `, got ${Re(t)}`, e.scalar !== void 0 ? `expected ${yM(e.scalar)}` + n : e.enum !== void 0 ? `expected ${e.enum.toString()}` + n : `expected ${UL(e.message)}` + n;
}
function Re(e) {
  switch (typeof e) {
    case "object":
      return e === null ? "null" : e instanceof Uint8Array ? `Uint8Array(${e.length})` : Array.isArray(e) ? `Array(${e.length})` : cE(e) ? RL(e.field()) : fE(e) ? $L(e.field()) : mE(e) ? UL(e.desc) : uE(e) ? `message ${e.$typeName}` : "object";
    case "string":
      return e.length > 30 ? "string" : `"${e.split('"').join('\\"')}"`;
    case "boolean":
      return String(e);
    case "number":
      return String(e);
    case "bigint":
      return String(e) + "n";
    default:
      return typeof e;
  }
}
function UL(e) {
  return `ReflectMessage (${e.typeName})`;
}
function RL(e) {
  switch (e.listKind) {
    case "message":
      return `ReflectList (${e.message.toString()})`;
    case "enum":
      return `ReflectList (${e.enum.toString()})`;
    case "scalar":
      return `ReflectList (${h[e.scalar]})`;
  }
}
function $L(e) {
  switch (e.mapKind) {
    case "message":
      return `ReflectMap (${h[e.mapKey]}, ${e.message.toString()})`;
    case "enum":
      return `ReflectMap (${h[e.mapKey]}, ${e.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${h[e.mapKey]}, ${h[e.scalar]})`;
  }
}
function yM(e) {
  switch (e) {
    case h.STRING:
      return "string";
    case h.BOOL:
      return "boolean";
    case h.INT64:
    case h.SINT64:
    case h.SFIXED64:
      return "bigint (int64)";
    case h.UINT64:
    case h.FIXED64:
      return "bigint (uint64)";
    case h.BYTES:
      return "Uint8Array";
    case h.DOUBLE:
      return "number (float64)";
    case h.FLOAT:
      return "number (float32)";
    case h.FIXED32:
    case h.UINT32:
      return "number (uint32)";
    case h.INT32:
    case h.SFIXED32:
    case h.SINT32:
      return "number (int32)";
  }
}
function Xn(e, t, n = !0) {
  return new PL(e, t, n);
}
const hI = /* @__PURE__ */ new WeakMap();
class PL {
  get sortedFields() {
    const t = hI.get(this.desc);
    if (t)
      return t;
    const n = this.desc.fields.concat().sort((r, a) => r.number - a.number);
    return hI.set(this.desc, n), n;
  }
  constructor(t, n, r = !0) {
    this.lists = /* @__PURE__ */ new Map(), this.maps = /* @__PURE__ */ new Map(), this.check = r, this.desc = t, this.message = this[Sa] = n ?? mr(t), this.fields = t.fields, this.oneofs = t.oneofs, this.members = t.members;
  }
  findNumber(t) {
    return this._fieldsByNumber || (this._fieldsByNumber = new Map(this.desc.fields.map((n) => [n.number, n]))), this._fieldsByNumber.get(t);
  }
  oneofCase(t) {
    return Au(this.message, t), vL(this.message, t);
  }
  isSet(t) {
    return Au(this.message, t), rM(this.message, t);
  }
  clear(t) {
    Au(this.message, t), aM(this.message, t);
  }
  get(t) {
    Au(this.message, t);
    const n = TL(this.message, t);
    switch (t.fieldKind) {
      case "list":
        let r = this.lists.get(t);
        return (!r || r[Sa] !== n) && this.lists.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          r = new NM(t, n, this.check)
        ), r;
      case "map":
        let a = this.maps.get(t);
        return (!a || a[Sa] !== n) && this.maps.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = new EM(t, n, this.check)
        ), a;
      case "message":
        return NE(t, n, this.check);
      case "scalar":
        return n === void 0 ? Us(t.scalar, !1) : EE(t, n);
      case "enum":
        return n ?? t.enum.values[0].number;
    }
  }
  set(t, n) {
    if (Au(this.message, t), this.check) {
      const a = Do(t, n);
      if (a)
        throw a;
    }
    let r;
    t.fieldKind == "message" ? r = yE(t, n) : fE(n) || cE(n) ? r = n[Sa] : r = vE(t, n), IL(this.message, t, r);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(t) {
    this.message.$unknown = t;
  }
}
function Au(e, t) {
  if (t.parent.typeName !== e.$typeName)
    throw new Lt(t, `cannot use ${t.toString()} with message ${e.$typeName}`, "ForeignFieldError");
}
class NM {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(t, n, r) {
    this._field = t, this._arr = this[Sa] = n, this.check = r;
  }
  get(t) {
    const n = this._arr[t];
    return n === void 0 ? void 0 : wg(this._field, n, this.check);
  }
  set(t, n) {
    if (t < 0 || t >= this._arr.length)
      throw new Lt(this._field, `list item #${t + 1}: out of range`);
    if (this.check) {
      const r = gI(this._field, t, n);
      if (r)
        throw r;
    }
    this._arr[t] = yI(this._field, n);
  }
  add(t) {
    if (this.check) {
      const n = gI(this._field, this._arr.length, t);
      if (n)
        throw n;
    }
    this._arr.push(yI(this._field, t));
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const t of this._arr)
      yield wg(this._field, t, this.check);
  }
  *entries() {
    for (let t = 0; t < this._arr.length; t++)
      yield [t, wg(this._field, this._arr[t], this.check)];
  }
}
class EM {
  constructor(t, n, r = !0) {
    this.obj = this[Sa] = n ?? {}, this.check = r, this._field = t;
  }
  field() {
    return this._field;
  }
  set(t, n) {
    if (this.check) {
      const r = hM(this._field, t, n);
      if (r)
        throw r;
    }
    return this.obj[Zf(t)] = vM(this._field, n), this;
  }
  delete(t) {
    const n = Zf(t), r = Object.prototype.hasOwnProperty.call(this.obj, n);
    return r && delete this.obj[n], r;
  }
  clear() {
    for (const t of Object.keys(this.obj))
      delete this.obj[t];
  }
  get(t) {
    let n = this.obj[Zf(t)];
    return n !== void 0 && (n = _g(this._field, n, this.check)), n;
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.obj, Zf(t));
  }
  *keys() {
    for (const t of Object.keys(this.obj))
      yield NI(t, this._field.mapKey);
  }
  *entries() {
    for (const t of Object.entries(this.obj))
      yield [
        NI(t[0], this._field.mapKey),
        _g(this._field, t[1], this.check)
      ];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const t of Object.values(this.obj))
      yield _g(this._field, t, this.check);
  }
  forEach(t, n) {
    for (const r of this.entries())
      t.call(n, r[1], r[0], this);
  }
}
function yE(e, t) {
  return mE(t) ? oM(t.message) && !e.oneof && e.fieldKind == "message" ? t.message.value : t.desc.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" ? xL(t.message) : t.message : t;
}
function NE(e, t, n) {
  return t !== void 0 && (Uc(e.message) && !e.oneof && e.fieldKind == "message" ? t = {
    $typeName: e.message.typeName,
    value: EE(e.message.fields[0], t)
  } : e.message.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" && ho(t) && (t = VL(t))), new PL(e.message, t, n);
}
function yI(e, t) {
  return e.listKind == "message" ? yE(e, t) : vE(e, t);
}
function wg(e, t, n) {
  return e.listKind == "message" ? NE(e, t, n) : EE(e, t);
}
function vM(e, t) {
  return e.mapKind == "message" ? yE(e, t) : vE(e, t);
}
function _g(e, t, n) {
  return e.mapKind == "message" ? NE(e, t, n) : t;
}
function Zf(e) {
  return typeof e == "string" || typeof e == "number" ? e : String(e);
}
function NI(e, t) {
  switch (t) {
    case h.STRING:
      return e;
    case h.INT32:
    case h.FIXED32:
    case h.UINT32:
    case h.SFIXED32:
    case h.SINT32: {
      const n = Number.parseInt(e);
      if (Number.isFinite(n))
        return n;
      break;
    }
    case h.BOOL:
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      break;
    case h.UINT64:
    case h.FIXED64:
      try {
        return X.uParse(e);
      } catch {
      }
      break;
    default:
      try {
        return X.parse(e);
      } catch {
      }
      break;
  }
  return e;
}
function EE(e, t) {
  switch (e.scalar) {
    case h.INT64:
    case h.SFIXED64:
    case h.SINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = X.parse(t));
      break;
    case h.FIXED64:
    case h.UINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = X.uParse(t));
      break;
  }
  return t;
}
function vE(e, t) {
  switch (e.scalar) {
    case h.INT64:
    case h.SFIXED64:
    case h.SINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = X.parse(t));
      break;
    case h.FIXED64:
    case h.UINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = X.uParse(t));
      break;
  }
  return t;
}
function VL(e) {
  const t = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (ho(e))
    for (const [n, r] of Object.entries(e))
      t.fields[n] = jL(r);
  return t;
}
function xL(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = YL(r);
  return t;
}
function YL(e) {
  switch (e.kind.case) {
    case "structValue":
      return xL(e.kind.value);
    case "listValue":
      return e.kind.value.values.map(YL);
    case "nullValue":
    case void 0:
      return null;
    default:
      return e.kind.value;
  }
}
function jL(e) {
  const t = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof e) {
    case "number":
      t.kind = { case: "numberValue", value: e };
      break;
    case "string":
      t.kind = { case: "stringValue", value: e };
      break;
    case "boolean":
      t.kind = { case: "boolValue", value: e };
      break;
    case "object":
      if (e === null)
        t.kind = { case: "nullValue", value: 0 };
      else if (Array.isArray(e)) {
        const n = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(e))
          for (const r of e)
            n.values.push(jL(r));
        t.kind = {
          case: "listValue",
          value: n
        };
      } else
        t.kind = {
          case: "structValue",
          value: VL(e)
        };
      break;
  }
  return t;
}
function TE(e) {
  const t = TM();
  let n = e.length * 3 / 4;
  e[e.length - 2] == "=" ? n -= 2 : e[e.length - 1] == "=" && (n -= 1);
  let r = new Uint8Array(n), a = 0, o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++) {
    if (s = t[e.charCodeAt(u)], s === void 0)
      switch (e[u]) {
        // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
        case "=":
          o = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string");
      }
    switch (o) {
      case 0:
        i = s, o = 1;
        break;
      case 1:
        r[a++] = i << 2 | (s & 48) >> 4, i = s, o = 2;
        break;
      case 2:
        r[a++] = (i & 15) << 4 | (s & 60) >> 2, i = s, o = 3;
        break;
      case 3:
        r[a++] = (i & 3) << 6 | s, o = 0;
        break;
    }
  }
  if (o == 1)
    throw Error("invalid base64 string");
  return r.subarray(0, a);
}
function BL(e, t = "std") {
  const n = GL(t), r = t == "std";
  let a = "", o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++)
    switch (s = e[u], o) {
      case 0:
        a += n[s >> 2], i = (s & 3) << 4, o = 1;
        break;
      case 1:
        a += n[i | s >> 4], i = (s & 15) << 2, o = 2;
        break;
      case 2:
        a += n[i | s >> 6], a += n[s & 63], o = 0;
        break;
    }
  return o && (a += n[i], r && (a += "=", o == 1 && (a += "="))), a;
}
let Hf, EI, ei;
function GL(e) {
  return Hf || (Hf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), EI = Hf.slice(0, -2).concat("-", "_")), e == "url" ? (
    // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
    EI
  ) : Hf;
}
function TM() {
  if (!ei) {
    ei = [];
    const e = GL("std");
    for (let t = 0; t < e.length; t++)
      ei[e[t].charCodeAt(0)] = t;
    ei[45] = e.indexOf("+"), ei[95] = e.indexOf("/");
  }
  return ei;
}
function qu(e) {
  let t = !1;
  const n = [];
  for (let r = 0; r < e.length; r++) {
    let a = e.charAt(r);
    switch (a) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        n.push(a), t = !1;
        break;
      default:
        t && (t = !1, a = a.toUpperCase()), n.push(a);
        break;
    }
  }
  return n.join("");
}
const IM = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function Qu(e) {
  return IM.has(e) ? e + "$" : e;
}
function IE(e) {
  for (const t of e.field)
    zu(t, "jsonName") || (t.jsonName = qu(t.name));
  e.nestedType.forEach(IE);
}
function wM(e, t) {
  const n = e.values.find((r) => r.name === t);
  if (!n)
    throw new Error(`cannot parse ${e} default value: ${t}`);
  return n.number;
}
function _M(e, t) {
  switch (e) {
    case h.STRING:
      return t;
    case h.BYTES: {
      const n = OM(t);
      if (n === !1)
        throw new Error(`cannot parse ${h[e]} default value: ${t}`);
      return n;
    }
    case h.INT64:
    case h.SFIXED64:
    case h.SINT64:
      return X.parse(t);
    case h.UINT64:
    case h.FIXED64:
      return X.uParse(t);
    case h.DOUBLE:
    case h.FLOAT:
      switch (t) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(t);
      }
    case h.BOOL:
      return t === "true";
    case h.INT32:
    case h.UINT32:
    case h.SINT32:
    case h.FIXED32:
    case h.SFIXED32:
      return parseInt(t, 10);
  }
}
function OM(e) {
  const t = [], n = {
    tail: e,
    c: "",
    next() {
      return this.tail.length == 0 ? !1 : (this.c = this.tail[0], this.tail = this.tail.substring(1), !0);
    },
    take(r) {
      if (this.tail.length >= r) {
        const a = this.tail.substring(0, r);
        return this.tail = this.tail.substring(r), a;
      }
      return !1;
    }
  };
  for (; n.next(); )
    switch (n.c) {
      case "\\":
        if (n.next())
          switch (n.c) {
            case "\\":
              t.push(n.c.charCodeAt(0));
              break;
            case "b":
              t.push(8);
              break;
            case "f":
              t.push(12);
              break;
            case "n":
              t.push(10);
              break;
            case "r":
              t.push(13);
              break;
            case "t":
              t.push(9);
              break;
            case "v":
              t.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 8);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "x": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "u": {
              const r = n.c, a = n.take(4);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              const s = new Uint8Array(4);
              new DataView(s.buffer).setInt32(0, o, !0), t.push(s[0], s[1], s[2], s[3]);
              break;
            }
            case "U": {
              const r = n.c, a = n.take(8);
              if (a === !1)
                return !1;
              const o = X.uEnc(r + a), s = new Uint8Array(8), i = new DataView(s.buffer);
              i.setInt32(0, o.lo, !0), i.setInt32(4, o.hi, !0), t.push(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
              break;
            }
          }
        break;
      default:
        t.push(n.c.charCodeAt(0));
    }
  return new Uint8Array(t);
}
function* oy(e) {
  switch (e.kind) {
    case "file":
      for (const t of e.messages)
        yield t, yield* oy(t);
      yield* e.enums, yield* e.services, yield* e.extensions;
      break;
    case "message":
      for (const t of e.nestedMessages)
        yield t, yield* oy(t);
      yield* e.nestedEnums, yield* e.nestedExtensions;
      break;
  }
}
function ML(...e) {
  const t = SM();
  if (!e.length)
    return t;
  if ("$typeName" in e[0] && e[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const n of e[0].file)
      wI(n, t);
    return t;
  }
  if ("$typeName" in e[0]) {
    let o = function(s) {
      const i = [];
      for (const u of s.dependency) {
        if (t.getFile(u) != null || a.has(u))
          continue;
        const l = r(u);
        if (!l)
          throw new Error(`Unable to resolve ${u}, imported by ${s.name}`);
        "kind" in l ? t.addFile(l, !1, !0) : (a.add(l.name), i.push(l));
      }
      return i.concat(...i.map(o));
    };
    const n = e[0], r = e[1], a = /* @__PURE__ */ new Set();
    for (const s of [n, ...o(n)].reverse())
      wI(s, t);
  } else
    for (const n of e)
      for (const r of n.files)
        t.addFile(r);
  return t;
}
function SM() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    kind: "registry",
    types: e,
    extendees: t,
    [Symbol.iterator]() {
      return e.values();
    },
    get files() {
      return n.values();
    },
    addFile(r, a, o) {
      if (n.set(r.proto.name, r), !a)
        for (const s of oy(r))
          this.add(s);
      if (o)
        for (const s of r.dependencies)
          this.addFile(s, a, o);
    },
    add(r) {
      if (r.kind == "extension") {
        let a = t.get(r.extendee.typeName);
        a || t.set(
          r.extendee.typeName,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = /* @__PURE__ */ new Map()
        ), a.set(r.number, r);
      }
      e.set(r.typeName, r);
    },
    get(r) {
      return e.get(r);
    },
    getFile(r) {
      return n.get(r);
    },
    getMessage(r) {
      const a = e.get(r);
      return a?.kind == "message" ? a : void 0;
    },
    getEnum(r) {
      const a = e.get(r);
      return a?.kind == "enum" ? a : void 0;
    },
    getExtension(r) {
      const a = e.get(r);
      return a?.kind == "extension" ? a : void 0;
    },
    getExtensionFor(r, a) {
      var o;
      return (o = t.get(r.typeName)) === null || o === void 0 ? void 0 : o.get(a);
    },
    getService(r) {
      const a = e.get(r);
      return a?.kind == "service" ? a : void 0;
    }
  };
}
const DM = 998, kM = 999, AM = 9, el = 10, Bu = 11, LM = 12, vI = 14, wE = 3, FM = 2, TI = 1, UM = 0, Og = 1, II = 2, RM = 3, $M = 1, PM = 2, VM = 1, CL = {
  // EDITION_PROTO2
  998: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 2,
    // CLOSED,
    repeatedFieldEncoding: 2,
    // EXPANDED,
    utf8Validation: 3,
    // NONE,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 2,
    // LEGACY_BEST_EFFORT,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_PROTO3
  999: {
    fieldPresence: 2,
    // IMPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2023
  1e3: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2024
  1001: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 1,
    // STYLE2024,
    defaultSymbolVisibility: 2
    // EXPORT_TOP_LEVEL,
  }
};
function wI(e, t) {
  var n, r;
  const a = {
    kind: "file",
    proto: e,
    deprecated: (r = (n = e.options) === null || n === void 0 ? void 0 : n.deprecated) !== null && r !== void 0 ? r : !1,
    edition: BM(e),
    name: e.name.replace(/\.proto$/, ""),
    dependencies: GM(e, t),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${e.name}`;
    }
  }, o = /* @__PURE__ */ new Map(), s = {
    get(i) {
      return o.get(i);
    },
    add(i) {
      var u;
      nr(((u = i.proto.options) === null || u === void 0 ? void 0 : u.mapEntry) === !0), o.set(i.typeName, i);
    }
  };
  for (const i of e.enumType)
    KL(i, a, void 0, t);
  for (const i of e.messageType)
    XL(i, a, void 0, t, s);
  for (const i of e.service)
    xM(i, a, t);
  sy(a, t);
  for (const i of o.values())
    iy(i, t, s);
  for (const i of a.messages)
    iy(i, t, s), sy(i, t);
  t.addFile(a, !0);
}
function sy(e, t) {
  switch (e.kind) {
    case "file":
      for (const n of e.proto.extension) {
        const r = uy(n, e, t);
        e.extensions.push(r), t.add(r);
      }
      break;
    case "message":
      for (const n of e.proto.extension) {
        const r = uy(n, e, t);
        e.nestedExtensions.push(r), t.add(r);
      }
      for (const n of e.nestedMessages)
        sy(n, t);
      break;
  }
}
function iy(e, t, n) {
  const r = e.proto.oneofDecl.map((o) => jM(o, e)), a = /* @__PURE__ */ new Set();
  for (const o of e.proto.field) {
    const s = KM(o, r), i = uy(o, e, t, s, n);
    e.fields.push(i), e.field[i.localName] = i, s === void 0 ? e.members.push(i) : (s.fields.push(i), a.has(s) || (a.add(s), e.members.push(s)));
  }
  for (const o of r.filter((s) => a.has(s)))
    e.oneofs.push(o);
  for (const o of e.nestedMessages)
    iy(o, t, n);
}
function KL(e, t, n, r) {
  var a, o, s, i, u;
  const l = MM(e.name, e.value), c = {
    kind: "enum",
    proto: e,
    deprecated: (o = (a = e.options) === null || a === void 0 ? void 0 : a.deprecated) !== null && o !== void 0 ? o : !1,
    file: t,
    parent: n,
    open: !0,
    name: e.name,
    typeName: nb(e, n, t),
    value: {},
    values: [],
    sharedPrefix: l,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  c.open = ZM(c), r.add(c);
  for (const f of e.value) {
    const d = f.name;
    c.values.push(
      // biome-ignore lint/suspicious/noAssignInExpressions: no
      c.value[f.number] = {
        kind: "enum_value",
        proto: f,
        deprecated: (i = (s = f.options) === null || s === void 0 ? void 0 : s.deprecated) !== null && i !== void 0 ? i : !1,
        parent: c,
        name: d,
        localName: Qu(l == null ? d : d.substring(l.length)),
        number: f.number,
        toString() {
          return `enum value ${c.typeName}.${d}`;
        }
      }
    );
  }
  ((u = n?.nestedEnums) !== null && u !== void 0 ? u : t.enums).push(c);
}
function XL(e, t, n, r, a) {
  var o, s, i, u;
  const l = {
    kind: "message",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    file: t,
    parent: n,
    name: e.name,
    typeName: nb(e, n, t),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  ((i = e.options) === null || i === void 0 ? void 0 : i.mapEntry) === !0 ? a.add(l) : (((u = n?.nestedMessages) !== null && u !== void 0 ? u : t.messages).push(l), r.add(l));
  for (const c of e.enumType)
    KL(c, t, l, r);
  for (const c of e.nestedType)
    XL(c, t, l, r, a);
}
function xM(e, t, n) {
  var r, a;
  const o = {
    kind: "service",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    file: t,
    name: e.name,
    typeName: nb(e, void 0, t),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  t.services.push(o), n.add(o);
  for (const s of e.method) {
    const i = YM(s, o, n);
    o.methods.push(i), o.method[i.localName] = i;
  }
}
function YM(e, t, n) {
  var r, a, o, s;
  let i;
  e.clientStreaming && e.serverStreaming ? i = "bidi_streaming" : e.clientStreaming ? i = "client_streaming" : e.serverStreaming ? i = "server_streaming" : i = "unary";
  const u = n.getMessage(ia(e.inputType)), l = n.getMessage(ia(e.outputType));
  nr(u, `invalid MethodDescriptorProto: input_type ${e.inputType} not found`), nr(l, `invalid MethodDescriptorProto: output_type ${e.inputType} not found`);
  const c = e.name;
  return {
    kind: "rpc",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    parent: t,
    name: c,
    localName: Qu(c.length ? Qu(c[0].toLowerCase() + c.substring(1)) : c),
    methodKind: i,
    input: u,
    output: l,
    idempotency: (s = (o = e.options) === null || o === void 0 ? void 0 : o.idempotencyLevel) !== null && s !== void 0 ? s : UM,
    toString() {
      return `rpc ${t.typeName}.${c}`;
    }
  };
}
function jM(e, t) {
  return {
    kind: "oneof",
    proto: e,
    deprecated: !1,
    parent: t,
    fields: [],
    name: e.name,
    localName: Qu(qu(e.name)),
    toString() {
      return `oneof ${t.typeName}.${this.name}`;
    }
  };
}
function uy(e, t, n, r, a) {
  var o, s, i;
  const u = a === void 0, l = {
    kind: "field",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    name: e.name,
    number: e.number,
    scalar: void 0,
    message: void 0,
    enum: void 0,
    presence: XM(e, r, u, t),
    listKind: void 0,
    mapKind: void 0,
    mapKey: void 0,
    delimitedEncoding: void 0,
    packed: void 0,
    longAsString: !1,
    getDefaultValue: void 0
  };
  if (u) {
    const m = t.kind == "file" ? t : t.file, p = t.kind == "file" ? void 0 : t, b = nb(e, p, m);
    l.kind = "extension", l.file = m, l.parent = p, l.oneof = void 0, l.typeName = b, l.jsonName = `[${b}]`, l.toString = () => `extension ${b}`;
    const g = n.getMessage(ia(e.extendee));
    nr(g, `invalid FieldDescriptorProto: extendee ${e.extendee} not found`), l.extendee = g;
  } else {
    const m = t;
    nr(m.kind == "message"), l.parent = m, l.oneof = r, l.localName = r ? qu(e.name) : Qu(qu(e.name)), l.jsonName = e.jsonName, l.toString = () => `field ${m.typeName}.${e.name}`;
  }
  const c = e.label, f = e.type, d = (i = e.options) === null || i === void 0 ? void 0 : i.jstype;
  if (c === wE) {
    const m = f == Bu ? a?.get(ia(e.typeName)) : void 0;
    if (m) {
      l.fieldKind = "map";
      const { key: p, value: b } = JM(m);
      return l.mapKey = p.scalar, l.mapKind = b.fieldKind, l.message = b.message, l.delimitedEncoding = !1, l.enum = b.enum, l.scalar = b.scalar, l;
    }
    switch (l.fieldKind = "list", f) {
      case Bu:
      case el:
        l.listKind = "message", l.message = n.getMessage(ia(e.typeName)), nr(l.message), l.delimitedEncoding = _I(e, t);
        break;
      case vI:
        l.listKind = "enum", l.enum = n.getEnum(ia(e.typeName)), nr(l.enum);
        break;
      default:
        l.listKind = "scalar", l.scalar = f, l.longAsString = d == TI;
        break;
    }
    return l.packed = WM(e, t), l;
  }
  switch (f) {
    case Bu:
    case el:
      l.fieldKind = "message", l.message = n.getMessage(ia(e.typeName)), nr(l.message, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.delimitedEncoding = _I(e, t), l.getDefaultValue = () => {
      };
      break;
    case vI: {
      const m = n.getEnum(ia(e.typeName));
      nr(m !== void 0, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.fieldKind = "enum", l.enum = n.getEnum(ia(e.typeName)), l.getDefaultValue = () => zu(e, "defaultValue") ? wM(m, e.defaultValue) : void 0;
      break;
    }
    default: {
      l.fieldKind = "scalar", l.scalar = f, l.longAsString = d == TI, l.getDefaultValue = () => zu(e, "defaultValue") ? _M(f, e.defaultValue) : void 0;
      break;
    }
  }
  return l;
}
function BM(e) {
  switch (e.syntax) {
    case "":
    case "proto2":
      return DM;
    case "proto3":
      return kM;
    case "editions":
      if (e.edition in CL)
        return e.edition;
      throw new Error(`${e.name}: unsupported edition`);
    default:
      throw new Error(`${e.name}: unsupported syntax "${e.syntax}"`);
  }
}
function GM(e, t) {
  return e.dependency.map((n) => {
    const r = t.getFile(n);
    if (!r)
      throw new Error(`Cannot find ${n}, imported by ${e.name}`);
    return r;
  });
}
function MM(e, t) {
  const n = CM(e) + "_";
  for (const r of t) {
    if (!r.name.toLowerCase().startsWith(n))
      return;
    const a = r.name.substring(n.length);
    if (a.length == 0 || /^\d/.test(a))
      return;
  }
  return n;
}
function CM(e) {
  return (e.substring(0, 1) + e.substring(1).replace(/[A-Z]/g, (t) => "_" + t)).toLowerCase();
}
function nb(e, t, n) {
  let r;
  return t ? r = `${t.typeName}.${e.name}` : n.proto.package.length > 0 ? r = `${n.proto.package}.${e.name}` : r = `${e.name}`, r;
}
function ia(e) {
  return e.startsWith(".") ? e.substring(1) : e;
}
function KM(e, t) {
  if (!zu(e, "oneofIndex") || e.proto3Optional)
    return;
  const n = t[e.oneofIndex];
  return nr(n, `invalid FieldDescriptorProto: oneof #${e.oneofIndex} for field #${e.number} not found`), n;
}
function XM(e, t, n, r) {
  if (e.label == FM)
    return RM;
  if (e.label == wE)
    return II;
  if (t || e.proto3Optional || n)
    return Og;
  const a = Fi("fieldPresence", { proto: e, parent: r });
  return a == II && (e.type == Bu || e.type == el) ? Og : a;
}
function WM(e, t) {
  if (e.label != wE)
    return !1;
  switch (e.type) {
    case AM:
    case LM:
    case el:
    case Bu:
      return !1;
  }
  const n = e.options;
  return n && zu(n, "packed") ? n.packed : $M == Fi("repeatedFieldEncoding", {
    proto: e,
    parent: t
  });
}
function JM(e) {
  const t = e.fields.find((r) => r.number === 1), n = e.fields.find((r) => r.number === 2);
  return nr(t && t.fieldKind == "scalar" && t.scalar != h.BYTES && t.scalar != h.FLOAT && t.scalar != h.DOUBLE && n && n.fieldKind != "list" && n.fieldKind != "map"), { key: t, value: n };
}
function ZM(e) {
  var t;
  return VM == Fi("enumType", {
    proto: e.proto,
    parent: (t = e.parent) !== null && t !== void 0 ? t : e.file
  });
}
function _I(e, t) {
  return e.type == el ? !0 : PM == Fi("messageEncoding", {
    proto: e,
    parent: t
  });
}
function Fi(e, t) {
  var n, r;
  const a = (n = t.proto.options) === null || n === void 0 ? void 0 : n.features;
  if (a) {
    const o = a[e];
    if (o != 0)
      return o;
  }
  if ("kind" in t) {
    if (t.kind == "message")
      return Fi(e, (r = t.parent) !== null && r !== void 0 ? r : t.file);
    const o = CL[t.edition];
    if (!o)
      throw new Error(`feature default for edition ${t.edition} not found`);
    return o[e];
  }
  return Fi(e, t.parent);
}
function nr(e, t) {
  if (!e)
    throw new Error(t);
}
function HM(e) {
  const t = zM(e);
  return t.messageType.forEach(IE), ML(t, () => {
  }).getFile(t.name);
}
function zM(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    syntax: "",
    edition: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, e), { messageType: e.messageType.map(WL), enumType: e.enumType.map(JL) }));
}
function WL(e) {
  var t, n, r, a, o, s, i, u;
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.DescriptorProto",
    name: e.name,
    field: (n = (t = e.field) === null || t === void 0 ? void 0 : t.map(qM)) !== null && n !== void 0 ? n : [],
    extension: [],
    nestedType: (a = (r = e.nestedType) === null || r === void 0 ? void 0 : r.map(WL)) !== null && a !== void 0 ? a : [],
    enumType: (s = (o = e.enumType) === null || o === void 0 ? void 0 : o.map(JL)) !== null && s !== void 0 ? s : [],
    extensionRange: (u = (i = e.extensionRange) === null || i === void 0 ? void 0 : i.map((c) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, c))) !== null && u !== void 0 ? u : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function qM(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: !1
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, e), { options: e.options ? QM(e.options) : void 0 }));
}
function QM(e) {
  var t, n, r;
  return Object.assign(/* @__PURE__ */ Object.create({
    ctype: 0,
    packed: !1,
    jstype: 0,
    lazy: !1,
    unverifiedLazy: !1,
    deprecated: !1,
    weak: !1,
    debugRedact: !1,
    retention: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, e), { targets: (t = e.targets) !== null && t !== void 0 ? t : [], editionDefaults: (r = (n = e.editionDefaults) === null || n === void 0 ? void 0 : n.map((o) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, o))) !== null && r !== void 0 ? r : [], uninterpretedOption: [] }));
}
function JL(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: e.name,
    reservedName: [],
    reservedRange: [],
    value: e.value.map((n) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, n))
  });
}
function Rc(e, t, ...n) {
  return n.reduce((r, a) => r.nestedMessages[a], e.messages[t]);
}
const eC = /* @__PURE__ */ HM({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: !0 } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false", options: { deprecated: !0 } }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1e3 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1e3, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: !0 } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1e3 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_UNSTABLE", number: 9999 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] }), tC = /* @__PURE__ */ Rc(eC, 1);
var OI;
(function(e) {
  e[e.DECLARATION = 0] = "DECLARATION", e[e.UNVERIFIED = 1] = "UNVERIFIED";
})(OI || (OI = {}));
var SI;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.GROUP = 10] = "GROUP", e[e.MESSAGE = 11] = "MESSAGE", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.ENUM = 14] = "ENUM", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(SI || (SI = {}));
var DI;
(function(e) {
  e[e.OPTIONAL = 1] = "OPTIONAL", e[e.REPEATED = 3] = "REPEATED", e[e.REQUIRED = 2] = "REQUIRED";
})(DI || (DI = {}));
var kI;
(function(e) {
  e[e.SPEED = 1] = "SPEED", e[e.CODE_SIZE = 2] = "CODE_SIZE", e[e.LITE_RUNTIME = 3] = "LITE_RUNTIME";
})(kI || (kI = {}));
var AI;
(function(e) {
  e[e.STRING = 0] = "STRING", e[e.CORD = 1] = "CORD", e[e.STRING_PIECE = 2] = "STRING_PIECE";
})(AI || (AI = {}));
var LI;
(function(e) {
  e[e.JS_NORMAL = 0] = "JS_NORMAL", e[e.JS_STRING = 1] = "JS_STRING", e[e.JS_NUMBER = 2] = "JS_NUMBER";
})(LI || (LI = {}));
var FI;
(function(e) {
  e[e.RETENTION_UNKNOWN = 0] = "RETENTION_UNKNOWN", e[e.RETENTION_RUNTIME = 1] = "RETENTION_RUNTIME", e[e.RETENTION_SOURCE = 2] = "RETENTION_SOURCE";
})(FI || (FI = {}));
var UI;
(function(e) {
  e[e.TARGET_TYPE_UNKNOWN = 0] = "TARGET_TYPE_UNKNOWN", e[e.TARGET_TYPE_FILE = 1] = "TARGET_TYPE_FILE", e[e.TARGET_TYPE_EXTENSION_RANGE = 2] = "TARGET_TYPE_EXTENSION_RANGE", e[e.TARGET_TYPE_MESSAGE = 3] = "TARGET_TYPE_MESSAGE", e[e.TARGET_TYPE_FIELD = 4] = "TARGET_TYPE_FIELD", e[e.TARGET_TYPE_ONEOF = 5] = "TARGET_TYPE_ONEOF", e[e.TARGET_TYPE_ENUM = 6] = "TARGET_TYPE_ENUM", e[e.TARGET_TYPE_ENUM_ENTRY = 7] = "TARGET_TYPE_ENUM_ENTRY", e[e.TARGET_TYPE_SERVICE = 8] = "TARGET_TYPE_SERVICE", e[e.TARGET_TYPE_METHOD = 9] = "TARGET_TYPE_METHOD";
})(UI || (UI = {}));
var ly;
(function(e) {
  e[e.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e[e.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e[e.IDEMPOTENT = 2] = "IDEMPOTENT";
})(ly || (ly = {}));
var RI;
(function(e) {
  e[e.DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", e[e.EXPORT_ALL = 1] = "EXPORT_ALL", e[e.EXPORT_TOP_LEVEL = 2] = "EXPORT_TOP_LEVEL", e[e.LOCAL_ALL = 3] = "LOCAL_ALL", e[e.STRICT = 4] = "STRICT";
})(RI || (RI = {}));
var $I;
(function(e) {
  e[e.FIELD_PRESENCE_UNKNOWN = 0] = "FIELD_PRESENCE_UNKNOWN", e[e.EXPLICIT = 1] = "EXPLICIT", e[e.IMPLICIT = 2] = "IMPLICIT", e[e.LEGACY_REQUIRED = 3] = "LEGACY_REQUIRED";
})($I || ($I = {}));
var PI;
(function(e) {
  e[e.ENUM_TYPE_UNKNOWN = 0] = "ENUM_TYPE_UNKNOWN", e[e.OPEN = 1] = "OPEN", e[e.CLOSED = 2] = "CLOSED";
})(PI || (PI = {}));
var VI;
(function(e) {
  e[e.REPEATED_FIELD_ENCODING_UNKNOWN = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN", e[e.PACKED = 1] = "PACKED", e[e.EXPANDED = 2] = "EXPANDED";
})(VI || (VI = {}));
var xI;
(function(e) {
  e[e.UTF8_VALIDATION_UNKNOWN = 0] = "UTF8_VALIDATION_UNKNOWN", e[e.VERIFY = 2] = "VERIFY", e[e.NONE = 3] = "NONE";
})(xI || (xI = {}));
var YI;
(function(e) {
  e[e.MESSAGE_ENCODING_UNKNOWN = 0] = "MESSAGE_ENCODING_UNKNOWN", e[e.LENGTH_PREFIXED = 1] = "LENGTH_PREFIXED", e[e.DELIMITED = 2] = "DELIMITED";
})(YI || (YI = {}));
var jI;
(function(e) {
  e[e.JSON_FORMAT_UNKNOWN = 0] = "JSON_FORMAT_UNKNOWN", e[e.ALLOW = 1] = "ALLOW", e[e.LEGACY_BEST_EFFORT = 2] = "LEGACY_BEST_EFFORT";
})(jI || (jI = {}));
var BI;
(function(e) {
  e[e.ENFORCE_NAMING_STYLE_UNKNOWN = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN", e[e.STYLE2024 = 1] = "STYLE2024", e[e.STYLE_LEGACY = 2] = "STYLE_LEGACY";
})(BI || (BI = {}));
var GI;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SET = 1] = "SET", e[e.ALIAS = 2] = "ALIAS";
})(GI || (GI = {}));
var MI;
(function(e) {
  e[e.EDITION_UNKNOWN = 0] = "EDITION_UNKNOWN", e[e.EDITION_LEGACY = 900] = "EDITION_LEGACY", e[e.EDITION_PROTO2 = 998] = "EDITION_PROTO2", e[e.EDITION_PROTO3 = 999] = "EDITION_PROTO3", e[e.EDITION_2023 = 1e3] = "EDITION_2023", e[e.EDITION_2024 = 1001] = "EDITION_2024", e[e.EDITION_UNSTABLE = 9999] = "EDITION_UNSTABLE", e[e.EDITION_1_TEST_ONLY = 1] = "EDITION_1_TEST_ONLY", e[e.EDITION_2_TEST_ONLY = 2] = "EDITION_2_TEST_ONLY", e[e.EDITION_99997_TEST_ONLY = 99997] = "EDITION_99997_TEST_ONLY", e[e.EDITION_99998_TEST_ONLY = 99998] = "EDITION_99998_TEST_ONLY", e[e.EDITION_99999_TEST_ONLY = 99999] = "EDITION_99999_TEST_ONLY", e[e.EDITION_MAX = 2147483647] = "EDITION_MAX";
})(MI || (MI = {}));
var CI;
(function(e) {
  e[e.VISIBILITY_UNSET = 0] = "VISIBILITY_UNSET", e[e.VISIBILITY_LOCAL = 1] = "VISIBILITY_LOCAL", e[e.VISIBILITY_EXPORT = 2] = "VISIBILITY_EXPORT";
})(CI || (CI = {}));
const KI = {
  readUnknownFields: !0
};
function nC(e) {
  return e ? Object.assign(Object.assign({}, KI), e) : KI;
}
function rb(e, t, n) {
  const r = Xn(e, void 0, !1);
  return ZL(r, new gE(t), nC(n), !1, t.byteLength), r.message;
}
function ZL(e, t, n, r, a) {
  var o;
  const s = r ? t.len : t.pos + a;
  let i, u;
  const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
  for (; t.pos < s && ([i, u] = t.tag(), !(r && u == ae.EndGroup)); ) {
    const c = e.findNumber(i);
    if (!c) {
      const f = t.skip(u, i);
      n.readUnknownFields && l.push({ no: i, wireType: u, data: f });
      continue;
    }
    HL(e, t, c, u, n);
  }
  if (r && (u != ae.EndGroup || i !== a))
    throw new Error("invalid end group tag");
  l.length > 0 && e.setUnknown(l);
}
function HL(e, t, n, r, a) {
  var o;
  switch (n.fieldKind) {
    case "scalar":
      e.set(n, Ui(t, n.scalar));
      break;
    case "enum":
      const s = Ui(t, h.INT32);
      if (n.enum.open)
        e.set(n, s);
      else if (n.enum.values.some((u) => u.number === s))
        e.set(n, s);
      else if (a.readUnknownFields) {
        const u = [];
        ay(s, u);
        const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
        l.push({
          no: n.number,
          wireType: r,
          data: new Uint8Array(u)
        }), e.setUnknown(l);
      }
      break;
    case "message":
      e.set(n, _E(t, a, n, e.get(n)));
      break;
    case "list":
      aC(t, r, e.get(n), a);
      break;
    case "map":
      rC(t, e.get(n), a);
      break;
  }
}
function rC(e, t, n) {
  const r = t.field();
  let a, o;
  const s = e.uint32(), i = e.pos + s;
  for (; e.pos < i; ) {
    const [u] = e.tag();
    switch (u) {
      case 1:
        a = Ui(e, r.mapKey);
        break;
      case 2:
        switch (r.mapKind) {
          case "scalar":
            o = Ui(e, r.scalar);
            break;
          case "enum":
            o = e.int32();
            break;
          case "message":
            o = _E(e, n, r);
            break;
        }
        break;
    }
  }
  if (a === void 0 && (a = Us(r.mapKey, !1)), o === void 0)
    switch (r.mapKind) {
      case "scalar":
        o = Us(r.scalar, !1);
        break;
      case "enum":
        o = r.enum.values[0].number;
        break;
      case "message":
        o = Xn(r.message, void 0, !1);
        break;
    }
  t.set(a, o);
}
function aC(e, t, n, r) {
  var a;
  const o = n.field();
  if (o.listKind === "message") {
    n.add(_E(e, r, o));
    return;
  }
  const s = (a = o.scalar) !== null && a !== void 0 ? a : h.INT32;
  if (!(t == ae.LengthDelimited && s != h.STRING && s != h.BYTES)) {
    n.add(Ui(e, s));
    return;
  }
  const u = e.uint32() + e.pos;
  for (; e.pos < u; )
    n.add(Ui(e, s));
}
function _E(e, t, n, r) {
  const a = n.delimitedEncoding, o = r ?? Xn(n.message, void 0, !1);
  return ZL(o, e, t, a, a ? n.number : e.uint32()), o;
}
function Ui(e, t) {
  switch (t) {
    case h.STRING:
      return e.string();
    case h.BOOL:
      return e.bool();
    case h.DOUBLE:
      return e.double();
    case h.FLOAT:
      return e.float();
    case h.INT32:
      return e.int32();
    case h.INT64:
      return e.int64();
    case h.UINT64:
      return e.uint64();
    case h.FIXED64:
      return e.fixed64();
    case h.BYTES:
      return e.bytes();
    case h.FIXED32:
      return e.fixed32();
    case h.SFIXED32:
      return e.sfixed32();
    case h.SFIXED64:
      return e.sfixed64();
    case h.SINT64:
      return e.sint64();
    case h.UINT32:
      return e.uint32();
    case h.SINT32:
      return e.sint32();
  }
}
function zL(e, t) {
  var n;
  const r = rb(tC, TE(e));
  return r.messageType.forEach(IE), r.dependency = (n = void 0) !== null && n !== void 0 ? n : [], ML(r, (o) => {
  }).getFile(r.name);
}
const oC = /* @__PURE__ */ zL("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), sC = /* @__PURE__ */ Rc(oC, 0), iC = 3, XI = {
  writeUnknownFields: !0
};
function uC(e) {
  return e ? Object.assign(Object.assign({}, XI), e) : XI;
}
function qL(e, t, n) {
  return Ed(new LL(), uC(n), Xn(e, t)).finish();
}
function Ed(e, t, n) {
  var r;
  for (const a of n.sortedFields) {
    if (!n.isSet(a)) {
      if (a.presence == iC)
        throw new Error(`cannot encode ${a} to binary: required field not set`);
      continue;
    }
    QL(e, t, n, a);
  }
  if (t.writeUnknownFields)
    for (const { no: a, wireType: o, data: s } of (r = n.getUnknown()) !== null && r !== void 0 ? r : [])
      e.tag(a, o).raw(s);
  return e;
}
function QL(e, t, n, r) {
  var a;
  switch (r.fieldKind) {
    case "scalar":
    case "enum":
      vd(e, n.desc.typeName, r.name, (a = r.scalar) !== null && a !== void 0 ? a : h.INT32, r.number, n.get(r));
      break;
    case "list":
      lC(e, t, r, n.get(r));
      break;
    case "message":
      eF(e, t, r, n.get(r));
      break;
    case "map":
      for (const [o, s] of n.get(r))
        cC(e, t, r, o, s);
      break;
  }
}
function vd(e, t, n, r, a, o) {
  tF(e.tag(a, fC(r)), t, n, r, o);
}
function eF(e, t, n, r) {
  n.delimitedEncoding ? Ed(e.tag(n.number, ae.StartGroup), t, r).tag(n.number, ae.EndGroup) : Ed(e.tag(n.number, ae.LengthDelimited).fork(), t, r).join();
}
function lC(e, t, n, r) {
  var a;
  if (n.listKind == "message") {
    for (const s of r)
      eF(e, t, n, s);
    return;
  }
  const o = (a = n.scalar) !== null && a !== void 0 ? a : h.INT32;
  if (n.packed) {
    if (!r.size)
      return;
    e.tag(n.number, ae.LengthDelimited).fork();
    for (const s of r)
      tF(e, n.parent.typeName, n.name, o, s);
    e.join();
    return;
  }
  for (const s of r)
    vd(e, n.parent.typeName, n.name, o, n.number, s);
}
function cC(e, t, n, r, a) {
  var o;
  switch (e.tag(n.number, ae.LengthDelimited).fork(), vd(e, n.parent.typeName, n.name, n.mapKey, 1, r), n.mapKind) {
    case "scalar":
    case "enum":
      vd(e, n.parent.typeName, n.name, (o = n.scalar) !== null && o !== void 0 ? o : h.INT32, 2, a);
      break;
    case "message":
      Ed(e.tag(2, ae.LengthDelimited).fork(), t, a).join();
      break;
  }
  e.join();
}
function tF(e, t, n, r, a) {
  try {
    switch (r) {
      case h.STRING:
        e.string(a);
        break;
      case h.BOOL:
        e.bool(a);
        break;
      case h.DOUBLE:
        e.double(a);
        break;
      case h.FLOAT:
        e.float(a);
        break;
      case h.INT32:
        e.int32(a);
        break;
      case h.INT64:
        e.int64(a);
        break;
      case h.UINT64:
        e.uint64(a);
        break;
      case h.FIXED64:
        e.fixed64(a);
        break;
      case h.BYTES:
        e.bytes(a);
        break;
      case h.FIXED32:
        e.fixed32(a);
        break;
      case h.SFIXED32:
        e.sfixed32(a);
        break;
      case h.SFIXED64:
        e.sfixed64(a);
        break;
      case h.SINT64:
        e.sint64(a);
        break;
      case h.UINT32:
        e.uint32(a);
        break;
      case h.SINT32:
        e.sint32(a);
        break;
    }
  } catch (o) {
    throw o instanceof Error ? new Error(`cannot encode field ${t}.${n} to binary: ${o.message}`) : o;
  }
}
function fC(e) {
  switch (e) {
    case h.BYTES:
    case h.STRING:
      return ae.LengthDelimited;
    case h.DOUBLE:
    case h.FIXED64:
    case h.SFIXED64:
      return ae.Bit64;
    case h.FIXED32:
    case h.SFIXED32:
    case h.FLOAT:
      return ae.Bit32;
    default:
      return ae.Varint;
  }
}
function mC(e, t, n) {
  let r = !1;
  return n || (n = mr(sC), r = !0), n.value = qL(e, t), n.typeUrl = bC(t.$typeName), r ? n : void 0;
}
function dC(e, t) {
  if (e.typeUrl === "")
    return !1;
  const n = typeof t == "string" ? t : t.typeName, r = nF(e.typeUrl);
  return n === r;
}
function pC(e, t) {
  if (e.typeUrl === "")
    return;
  const n = t.kind == "message" ? t : t.getMessage(nF(e.typeUrl));
  if (!(!n || !dC(e, n)))
    return rb(n, e.value);
}
function bC(e) {
  return `type.googleapis.com/${e}`;
}
function nF(e) {
  const t = e.lastIndexOf("/"), n = t >= 0 ? e.substring(t + 1) : e;
  if (!n.length)
    throw new Error(`invalid type url: ${e}`);
  return n;
}
const OE = /* @__PURE__ */ zL("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), gC = /* @__PURE__ */ Rc(OE, 0), rF = /* @__PURE__ */ Rc(OE, 1), hC = /* @__PURE__ */ Rc(OE, 2);
var cy;
(function(e) {
  e[e.NULL_VALUE = 0] = "NULL_VALUE";
})(cy || (cy = {}));
function yC(e, t) {
  aF(t, e);
  const n = EC(e.$unknown, t), [r, a, o] = ab(t);
  for (const s of n)
    HL(r, new gE(s.data), a, s.wireType, {
      readUnknownFields: !0
    });
  return o();
}
function NC(e, t, n) {
  var r;
  aF(t, e);
  const a = ((r = e.$unknown) !== null && r !== void 0 ? r : []).filter((l) => l.no !== t.number), [o, s] = ab(t, n), i = new LL();
  QL(i, { writeUnknownFields: !0 }, o, s);
  const u = new gE(i.finish());
  for (; u.pos < u.len; ) {
    const [l, c] = u.tag(), f = u.skip(c, l);
    a.push({ no: l, wireType: c, data: f });
  }
  e.$unknown = a;
}
function EC(e, t) {
  if (e === void 0)
    return [];
  if (t.fieldKind === "enum" || t.fieldKind === "scalar") {
    for (let n = e.length - 1; n >= 0; --n)
      if (e[n].no == t.number)
        return [e[n]];
    return [];
  }
  return e.filter((n) => n.no === t.number);
}
function ab(e, t) {
  const n = e.typeName, r = Object.assign(Object.assign({}, e), { kind: "field", parent: e.extendee, localName: n }), a = Object.assign(Object.assign({}, e.extendee), { fields: [r], members: [r], oneofs: [] }), o = mr(a, t !== void 0 ? { [n]: t } : void 0);
  return [
    Xn(a, o),
    r,
    () => {
      const s = o[n];
      if (s === void 0) {
        const i = e.message;
        return Uc(i) ? Us(i.fields[0].scalar, i.fields[0].longAsString) : mr(i);
      }
      return s;
    }
  ];
}
function aF(e, t) {
  if (e.extendee.typeName != t.$typeName)
    throw new Error(`extension ${e.typeName} can only be applied to message ${e.extendee.typeName}`);
}
const vC = 3, TC = 2, WI = {
  alwaysEmitImplicit: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1
};
function IC(e) {
  return e ? Object.assign(Object.assign({}, WI), e) : WI;
}
function wC(e, t, n) {
  return $c(Xn(e, t), IC(n));
}
function _C(e, t, n) {
  var r;
  const a = wC(e, t, n);
  return JSON.stringify(a, null, (r = n?.prettySpaces) !== null && r !== void 0 ? r : 0);
}
function $c(e, t) {
  var n;
  const r = kC(e, t);
  if (r !== void 0)
    return r;
  const a = {};
  for (const o of e.sortedFields) {
    if (!e.isSet(o)) {
      if (o.presence == vC)
        throw new Error(`cannot encode ${o} to JSON: required field not set`);
      if (!t.alwaysEmitImplicit || o.presence !== TC)
        continue;
    }
    const s = JI(o, e.get(o), t);
    s !== void 0 && (a[DC(o, t)] = s);
  }
  if (t.registry) {
    const o = /* @__PURE__ */ new Set();
    for (const { no: s } of (n = e.getUnknown()) !== null && n !== void 0 ? n : [])
      if (!o.has(s)) {
        o.add(s);
        const i = t.registry.getExtensionFor(e.desc, s);
        if (!i)
          continue;
        const u = yC(e.message, i), [l, c] = ab(i, u), f = JI(c, l.get(c), t);
        f !== void 0 && (a[i.jsonName] = f);
      }
  }
  return a;
}
function JI(e, t, n) {
  switch (e.fieldKind) {
    case "scalar":
      return ob(e, t);
    case "message":
      return $c(t, n);
    case "enum":
      return SE(e.enum, t, n.enumAsInteger);
    case "list":
      return SC(t, n);
    case "map":
      return OC(t, n);
  }
}
function OC(e, t) {
  const n = e.field(), r = {};
  switch (n.mapKind) {
    case "scalar":
      for (const [a, o] of e)
        r[a] = ob(n, o);
      break;
    case "message":
      for (const [a, o] of e)
        r[a] = $c(o, t);
      break;
    case "enum":
      for (const [a, o] of e)
        r[a] = SE(n.enum, o, t.enumAsInteger);
      break;
  }
  return t.alwaysEmitImplicit || e.size > 0 ? r : void 0;
}
function SC(e, t) {
  const n = e.field(), r = [];
  switch (n.listKind) {
    case "scalar":
      for (const a of e)
        r.push(ob(n, a));
      break;
    case "enum":
      for (const a of e)
        r.push(SE(n.enum, a, t.enumAsInteger));
      break;
    case "message":
      for (const a of e)
        r.push($c(a, t));
      break;
  }
  return t.alwaysEmitImplicit || r.length > 0 ? r : void 0;
}
function SE(e, t, n) {
  var r;
  if (typeof t != "number")
    throw new Error(`cannot encode ${e} to JSON: expected number, got ${Re(t)}`);
  if (e.typeName == "google.protobuf.NullValue")
    return null;
  if (n)
    return t;
  const a = e.value[t];
  return (r = a?.name) !== null && r !== void 0 ? r : t;
}
function ob(e, t) {
  var n, r, a, o, s, i;
  switch (e.scalar) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case h.INT32:
    case h.SFIXED32:
    case h.SINT32:
    case h.FIXED32:
    case h.UINT32:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(n = Do(e, t)) === null || n === void 0 ? void 0 : n.message}`);
      return t;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case h.FLOAT:
    case h.DOUBLE:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(r = Do(e, t)) === null || r === void 0 ? void 0 : r.message}`);
      return Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    // string:
    case h.STRING:
      if (typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(a = Do(e, t)) === null || a === void 0 ? void 0 : a.message}`);
      return t;
    // bool:
    case h.BOOL:
      if (typeof t != "boolean")
        throw new Error(`cannot encode ${e} to JSON: ${(o = Do(e, t)) === null || o === void 0 ? void 0 : o.message}`);
      return t;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case h.UINT64:
    case h.FIXED64:
    case h.INT64:
    case h.SFIXED64:
    case h.SINT64:
      if (typeof t != "bigint" && typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(s = Do(e, t)) === null || s === void 0 ? void 0 : s.message}`);
      return t.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case h.BYTES:
      if (t instanceof Uint8Array)
        return BL(t);
      throw new Error(`cannot encode ${e} to JSON: ${(i = Do(e, t)) === null || i === void 0 ? void 0 : i.message}`);
  }
}
function DC(e, t) {
  return t.useProtoFieldName ? e.name : e.jsonName;
}
function kC(e, t) {
  if (e.desc.typeName.startsWith("google.protobuf."))
    switch (e.desc.typeName) {
      case "google.protobuf.Any":
        return AC(e.message, t);
      case "google.protobuf.Timestamp":
        return UC(e.message);
      case "google.protobuf.Duration":
        return LC(e.message);
      case "google.protobuf.FieldMask":
        return FC(e.message);
      case "google.protobuf.Struct":
        return oF(e.message);
      case "google.protobuf.Value":
        return DE(e.message);
      case "google.protobuf.ListValue":
        return sF(e.message);
      default:
        if (Uc(e.desc)) {
          const n = e.desc.fields[0];
          return ob(n, e.get(n));
        }
        return;
    }
}
function AC(e, t) {
  if (e.typeUrl === "")
    return {};
  const { registry: n } = t;
  let r, a;
  if (n && (r = pC(e, n), r && (a = n.getMessage(r.$typeName))), !a || !r)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: "${e.typeUrl}" is not in the type registry`);
  let o = $c(Xn(a, r), t);
  return (a.typeName.startsWith("google.protobuf.") || o === null || Array.isArray(o) || typeof o != "object") && (o = { value: o }), o["@type"] = e.typeUrl, o;
}
function LC(e) {
  const t = Number(e.seconds), n = e.nanos;
  if (t > 315576e6 || t < -315576e6)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: value out of range`);
  if (t > 0 && n < 0 || t < 0 && n > 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos sign must match seconds sign`);
  let r = e.seconds.toString();
  if (n !== 0) {
    let a = Math.abs(n).toString();
    a = "0".repeat(9 - a.length) + a, a.substring(3) === "000000" ? a = a.substring(0, 3) : a.substring(6) === "000" && (a = a.substring(0, 6)), r += "." + a, n < 0 && t == 0 && (r = "-" + r);
  }
  return r + "s";
}
function FC(e) {
  return e.paths.map((t) => {
    if (t.match(/_[0-9]?_/g) || t.match(/[A-Z]/g))
      throw new Error(`cannot encode message ${e.$typeName} to JSON: lowerCamelCase of path name "` + t + '" is irreversible');
    return qu(t);
  }).join(",");
}
function oF(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = DE(r);
  return t;
}
function DE(e) {
  switch (e.kind.case) {
    case "nullValue":
      return null;
    case "numberValue":
      if (!Number.isFinite(e.kind.value))
        throw new Error(`${e.$typeName} cannot be NaN or Infinity`);
      return e.kind.value;
    case "boolValue":
      return e.kind.value;
    case "stringValue":
      return e.kind.value;
    case "structValue":
      return oF(e.kind.value);
    case "listValue":
      return sF(e.kind.value);
    default:
      throw new Error(`${e.$typeName} must have a value`);
  }
}
function sF(e) {
  return e.values.map(DE);
}
function UC(e) {
  const t = Number(e.seconds) * 1e3;
  if (t < Date.parse("0001-01-01T00:00:00Z") || t > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot encode message ${e.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  if (e.nanos < 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be negative`);
  if (e.nanos > 999999999)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be greater than 99999999`);
  let n = "Z";
  if (e.nanos > 0) {
    const r = (e.nanos + 1e9).toString().substring(1);
    r.substring(3) === "000000" ? n = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? n = "." + r.substring(0, 6) + "Z" : n = "." + r + "Z";
  }
  return new Date(t).toISOString().replace(".000Z", n);
}
const ZI = {
  ignoreUnknownFields: !1
};
function RC(e) {
  return e ? Object.assign(Object.assign({}, ZI), e) : ZI;
}
function $C(e, t, n) {
  return iF(e, GC(t, e.typeName), n);
}
function iF(e, t, n) {
  const r = Xn(e);
  try {
    Ri(r, t, RC(n));
  } catch (a) {
    throw bM(a) ? new Error(`cannot decode ${a.field()} from JSON: ${a.message}`, {
      cause: a
    }) : a;
  }
  return r.message;
}
function Ri(e, t, n) {
  var r;
  if (MC(e, t, n))
    return;
  if (t == null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode ${e.desc} from JSON: ${Re(t)}`);
  const a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const s of e.desc.fields)
    o.set(s.name, s).set(s.jsonName, s);
  for (const [s, i] of Object.entries(t)) {
    const u = o.get(s);
    if (u) {
      if (u.oneof) {
        if (i === null && u.fieldKind == "scalar")
          continue;
        const l = a.get(u.oneof);
        if (l !== void 0)
          throw new Lt(u.oneof, `oneof set multiple times by ${l.name} and ${u.name}`);
        a.set(u.oneof, u);
      }
      HI(e, u, i, n);
    } else {
      let l;
      if (s.startsWith("[") && s.endsWith("]") && // biome-ignore lint/suspicious/noAssignInExpressions: no
      (l = (r = n.registry) === null || r === void 0 ? void 0 : r.getExtension(s.substring(1, s.length - 1))) && l.extendee.typeName === e.desc.typeName) {
        const [c, f, d] = ab(l);
        HI(c, f, i, n), NC(e.message, l, d());
      }
      if (!l && !n.ignoreUnknownFields)
        throw new Error(`cannot decode ${e.desc} from JSON: key "${s}" is unknown`);
    }
  }
}
function HI(e, t, n, r) {
  switch (t.fieldKind) {
    case "scalar":
      jC(e, t, n);
      break;
    case "enum":
      YC(e, t, n, r);
      break;
    case "message":
      xC(e, t, n, r);
      break;
    case "list":
      VC(e.get(t), n, r);
      break;
    case "map":
      PC(e.get(t), n, r);
      break;
  }
}
function PC(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (typeof t != "object" || Array.isArray(t))
    throw new Lt(r, "expected object, got " + Re(t));
  for (const [a, o] of Object.entries(t)) {
    if (o === null && !uF(r))
      throw new Lt(r, "map value must not be null");
    let s;
    switch (r.mapKind) {
      case "message":
        const u = Xn(r.message);
        Ri(u, o, n), s = u;
        break;
      case "enum":
        if (s = kE(r.enum, o, n.ignoreUnknownFields, !0), s === sb)
          return;
        break;
      case "scalar":
        s = ub(r, o, !0);
        break;
    }
    const i = BC(r.mapKey, a);
    e.set(i, s);
  }
}
function VC(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (!Array.isArray(t))
    throw new Lt(r, "expected Array, got " + Re(t));
  for (const a of t) {
    if (a === null && !uF(r))
      throw new Lt(r, "list item must not be null");
    switch (r.listKind) {
      case "message":
        const o = Xn(r.message);
        Ri(o, a, n), e.add(o);
        break;
      case "enum":
        const s = kE(r.enum, a, n.ignoreUnknownFields, !0);
        s !== sb && e.add(s);
        break;
      case "scalar":
        e.add(ub(r, a, !0));
        break;
    }
  }
}
function uF(e) {
  var t, n;
  return ((t = e.message) === null || t === void 0 ? void 0 : t.typeName) == "google.protobuf.Value" || ((n = e.enum) === null || n === void 0 ? void 0 : n.typeName) == "google.protobuf.NullValue";
}
function xC(e, t, n, r) {
  if (n === null && t.message.typeName != "google.protobuf.Value") {
    e.clear(t);
    return;
  }
  const a = e.isSet(t) ? e.get(t) : Xn(t.message);
  Ri(a, n, r), e.set(t, a);
}
function YC(e, t, n, r) {
  const a = kE(t.enum, n, r.ignoreUnknownFields, !1);
  a === ib ? e.clear(t) : a !== sb && e.set(t, a);
}
function jC(e, t, n) {
  const r = ub(t, n, !1);
  r === ib ? e.clear(t) : e.set(t, r);
}
const sb = /* @__PURE__ */ Symbol();
function kE(e, t, n, r) {
  if (t === null)
    return e.typeName == "google.protobuf.NullValue" ? 0 : r ? e.values[0].number : ib;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const a = e.values.find((o) => o.name === t);
      if (a !== void 0)
        return a.number;
      if (n)
        return sb;
      break;
  }
  throw new Error(`cannot decode ${e} from JSON: ${Re(t)}`);
}
const ib = /* @__PURE__ */ Symbol();
function ub(e, t, n) {
  if (t === null)
    return n ? Us(e.scalar, !1) : ib;
  switch (e.scalar) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case h.DOUBLE:
    case h.FLOAT:
      if (t === "NaN")
        return NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (typeof t == "number") {
        if (Number.isNaN(t))
          throw new Lt(e, "unexpected NaN number");
        if (!Number.isFinite(t))
          throw new Lt(e, "unexpected infinite number");
        break;
      }
      if (typeof t == "string") {
        if (t === "" || t.trim().length !== t.length)
          break;
        const r = Number(t);
        if (!Number.isFinite(r))
          break;
        return r;
      }
      break;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case h.INT32:
    case h.FIXED32:
    case h.SFIXED32:
    case h.SINT32:
    case h.UINT32:
      return lF(t);
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case h.BYTES:
      if (typeof t == "string") {
        if (t === "")
          return new Uint8Array(0);
        try {
          return TE(t);
        } catch (r) {
          const a = r instanceof Error ? r.message : String(r);
          throw new Lt(e, a);
        }
      }
      break;
  }
  return t;
}
function BC(e, t) {
  switch (e) {
    case h.BOOL:
      switch (t) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      return t;
    case h.INT32:
    case h.FIXED32:
    case h.UINT32:
    case h.SFIXED32:
    case h.SINT32:
      return lF(t);
    default:
      return t;
  }
}
function lF(e) {
  if (typeof e == "string") {
    if (e === "" || e.trim().length !== e.length)
      return e;
    const t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
function GC(e, t) {
  try {
    return JSON.parse(e);
  } catch (n) {
    const r = n instanceof Error ? n.message : String(n);
    throw new Error(
      `cannot decode message ${t} from JSON: ${r}`,
      // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
      { cause: n }
    );
  }
}
function MC(e, t, n) {
  if (!e.desc.typeName.startsWith("google.protobuf."))
    return !1;
  switch (e.desc.typeName) {
    case "google.protobuf.Any":
      return CC(e.message, t, n), !0;
    case "google.protobuf.Timestamp":
      return KC(e.message, t), !0;
    case "google.protobuf.Duration":
      return XC(e.message, t), !0;
    case "google.protobuf.FieldMask":
      return WC(e.message, t), !0;
    case "google.protobuf.Struct":
      return cF(e.message, t), !0;
    case "google.protobuf.Value":
      return AE(e.message, t), !0;
    case "google.protobuf.ListValue":
      return fF(e.message, t), !0;
    default:
      if (Uc(e.desc)) {
        const r = e.desc.fields[0];
        return t === null ? e.clear(r) : e.set(r, ub(r, t, !0)), !0;
      }
      return !1;
  }
}
function CC(e, t, n) {
  var r;
  if (t === null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: expected object but got ${Re(t)}`);
  if (Object.keys(t).length == 0)
    return;
  const a = t["@type"];
  if (typeof a != "string" || a == "")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is empty`);
  const o = a.includes("/") ? a.substring(a.lastIndexOf("/") + 1) : a;
  if (!o.length)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is invalid`);
  const s = (r = n.registry) === null || r === void 0 ? void 0 : r.getMessage(o);
  if (!s)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${a} is not in the type registry`);
  const i = Xn(s);
  if (o.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(t, "value")) {
    const u = t.value;
    Ri(i, u, n);
  } else {
    const u = Object.assign({}, t);
    delete u["@type"], Ri(i, u, n);
  }
  mC(i.desc, i.message, e);
}
function KC(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Re(t)}`);
  const n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
  if (!n)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  const r = Date.parse(
    // biome-ignore format: want this to read well
    n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z")
  );
  if (Number.isNaN(r))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  e.seconds = X.parse(r / 1e3), e.nanos = 0, n[7] && (e.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9);
}
function XC(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Re(t)}`);
  const n = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
  if (n === null)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Re(t)}`);
  const r = Number(n[1]);
  if (r > 315576e6 || r < -315576e6)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Re(t)}`);
  if (e.seconds = X.parse(r), typeof n[2] != "string")
    return;
  const a = n[2] + "0".repeat(9 - n[2].length);
  e.nanos = parseInt(a), (r < 0 || Object.is(r, -0)) && (e.nanos = -e.nanos);
}
function WC(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Re(t)}`);
  if (t === "")
    return;
  function n(r) {
    if (r.includes("_"))
      throw new Error(`cannot decode message ${e.$typeName} from JSON: path names must be lowerCamelCase`);
    const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase());
    return a[0] === "_" ? a.substring(1) : a;
  }
  e.paths = t.split(",").map(n);
}
function cF(e, t) {
  if (typeof t != "object" || t == null || Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Re(t)}`);
  for (const [n, r] of Object.entries(t)) {
    const a = mr(rF);
    AE(a, r), e.fields[n] = a;
  }
}
function AE(e, t) {
  switch (typeof t) {
    case "number":
      e.kind = { case: "numberValue", value: t };
      break;
    case "string":
      e.kind = { case: "stringValue", value: t };
      break;
    case "boolean":
      e.kind = { case: "boolValue", value: t };
      break;
    case "object":
      if (t === null)
        e.kind = { case: "nullValue", value: cy.NULL_VALUE };
      else if (Array.isArray(t)) {
        const n = mr(hC);
        fF(n, t), e.kind = { case: "listValue", value: n };
      } else {
        const n = mr(gC);
        cF(n, t), e.kind = { case: "structValue", value: n };
      }
      break;
    default:
      throw new Error(`cannot decode message ${e.$typeName} from JSON ${Re(t)}`);
  }
  return e;
}
function fF(e, t) {
  if (!Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Re(t)}`);
  for (const n of t) {
    const r = mr(rF);
    AE(r, n), e.values.push(r);
  }
}
function fy(e) {
  const t = $[e];
  return typeof t != "string" ? e.toString() : t[0].toLowerCase() + t.substring(1).replace(/[A-Z]/g, (n) => "_" + n.toLowerCase());
}
let zf;
function JC(e) {
  if (!zf) {
    zf = {};
    for (const t of Object.values($))
      typeof t != "string" && (zf[fy(t)] = t);
  }
  return zf[e];
}
class pe extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(t, n = $.Unknown, r, a, o) {
    super(ZC(t, n)), this.name = "ConnectError", Object.setPrototypeOf(this, new.target.prototype), this.rawMessage = t, this.code = n, this.metadata = new Headers(r ?? {}), this.details = a ?? [], this.cause = o;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(t, n = $.Unknown) {
    return t instanceof pe ? t : t instanceof Error ? t.name == "AbortError" || t.name == "TimeoutError" ? new pe(t.message, $.Canceled) : new pe(t.message, n, void 0, void 0, t) : new pe(String(t), n, void 0, void 0, t);
  }
  static [Symbol.hasInstance](t) {
    return t instanceof Error ? Object.getPrototypeOf(t) === pe.prototype ? !0 : t.name === "ConnectError" && "code" in t && typeof t.code == "number" && "metadata" in t && "details" in t && Array.isArray(t.details) && "rawMessage" in t && typeof t.rawMessage == "string" && "cause" in t : !1;
  }
  findDetails(t) {
    const n = t.kind === "message" ? {
      getMessage: (a) => a === t.typeName ? t : void 0
    } : t, r = [];
    for (const a of this.details) {
      if ("desc" in a) {
        n.getMessage(a.desc.typeName) && r.push(mr(a.desc, a.value));
        continue;
      }
      const o = n.getMessage(a.type);
      if (o)
        try {
          r.push(rb(o, a.value));
        } catch {
        }
    }
    return r;
  }
}
function ZC(e, t) {
  return e.length ? `[${fy(t)}] ${e}` : `[${fy(t)}]`;
}
function HC(...e) {
  const t = new Headers();
  for (const n of e)
    n.forEach((r, a) => {
      t.append(a, r);
    });
  return t;
}
function zC(e, t) {
  const n = {};
  for (const r of e.methods) {
    const a = t(r);
    a != null && (n[r.localName] = a);
  }
  return n;
}
const zI = 1;
function qC(e, t, n = !1) {
  if (t > e) {
    let r = `message size is larger than configured readMaxBytes ${e}`;
    throw n && (r = `message size ${t} is larger than configured readMaxBytes ${e}`), new pe(r, $.ResourceExhausted);
  }
}
function QC(e) {
  return new eK(e);
}
class eK {
  constructor(t) {
    this.readMaxBytes = t, this.header = new Uint8Array(5), this.headerView = new DataView(this.header.buffer), this.buf = [];
  }
  get byteLength() {
    return this.buf.reduce((t, n) => t + n.byteLength, 0);
  }
  decode(t) {
    this.buf.push(t);
    const n = [];
    for (; ; ) {
      let r = this.pop();
      if (!r)
        break;
      n.push(r);
    }
    return n;
  }
  // consume an enveloped message
  pop() {
    if (!(!this.env && (this.env = this.head(), !this.env)) && this.cons(this.env.data)) {
      const t = this.env;
      return this.env = void 0, t;
    }
  }
  // consume header
  head() {
    if (!this.cons(this.header))
      return;
    const t = this.headerView.getUint8(0), n = this.headerView.getUint32(1);
    return qC(this.readMaxBytes, n, !0), {
      flags: t,
      data: new Uint8Array(n)
    };
  }
  // consume from buffer, fill target
  cons(t) {
    const n = t.byteLength;
    if (this.byteLength < n)
      return !1;
    let r = 0;
    for (; r < n; ) {
      const a = this.buf.shift();
      a.byteLength > n - r ? (t.set(a.subarray(0, n - r), r), this.buf.unshift(a.subarray(n - r)), r += n - r) : (t.set(a, r), r += a.byteLength);
    }
    return !0;
  }
}
function tK(e) {
  let t;
  const n = QC(4294967295);
  return new ReadableStream({
    start() {
      t = e.getReader();
    },
    async pull(r) {
      let a = !1;
      for (; !a; ) {
        const o = await t.read();
        if (o.done)
          n.byteLength > 0 && r.error(new pe("protocol error: incomplete envelope", $.InvalidArgument)), r.close();
        else
          for (const s of n.decode(o.value))
            r.enqueue(s), a = !0;
      }
    }
  });
}
function nK(e, t) {
  const n = new Uint8Array(t.length + 5);
  n.set(t, 5);
  const r = new DataView(n.buffer, n.byteOffset, n.byteLength);
  return r.setUint8(0, e), r.setUint32(1, t.length), n;
}
var rK = function(e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], n;
  return t ? t.call(e) : (e = typeof __values == "function" ? __values(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(o) {
    n[o] = e[o] && function(s) {
      return new Promise(function(i, u) {
        s = e[o](s), a(i, u, s.done, s.value);
      });
    };
  }
  function a(o, s, i, u) {
    Promise.resolve(u).then(function(l) {
      o({ value: l, done: i });
    }, s);
  }
}, tl = function(e) {
  return this instanceof tl ? (this.v = e, this) : new tl(e);
}, aK = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof tl ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
}, oK = function(e) {
  var t, n;
  return t = {}, r("next"), r("throw", function(a) {
    throw a;
  }), r("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function r(a, o) {
    t[a] = e[a] ? function(s) {
      return (n = !n) ? { value: tl(e[a](s)), done: !1 } : o ? o(s) : s;
    } : o;
  }
};
function sK(e) {
  return aK(this, arguments, function* () {
    yield tl(yield* oK(rK(e)));
  });
}
var mF = function(e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], n;
  return t ? t.call(e) : (e = typeof __values == "function" ? __values(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(o) {
    n[o] = e[o] && function(s) {
      return new Promise(function(i, u) {
        s = e[o](s), a(i, u, s.done, s.value);
      });
    };
  }
  function a(o, s, i, u) {
    Promise.resolve(u).then(function(l) {
      o({ value: l, done: i });
    }, s);
  }
}, $i = function(e) {
  return this instanceof $i ? (this.v = e, this) : new $i(e);
}, iK = function(e) {
  var t, n;
  return t = {}, r("next"), r("throw", function(a) {
    throw a;
  }), r("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function r(a, o) {
    t[a] = e[a] ? function(s) {
      return (n = !n) ? { value: $i(e[a](s)), done: !1 } : o ? o(s) : s;
    } : o;
  }
}, uK = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof $i ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
function lK(e, t) {
  return zC(e, (n) => {
    switch (n.methodKind) {
      case "unary":
        return cK(t, n);
      case "server_streaming":
        return fK(t, n);
      case "client_streaming":
        return mK(t, n);
      case "bidi_streaming":
        return dK(t, n);
      default:
        return null;
    }
  });
}
function cK(e, t) {
  return async (n, r) => {
    var a, o;
    const s = await e.unary(t, r?.signal, r?.timeoutMs, r?.headers, n, r?.contextValues);
    return (a = r?.onHeader) === null || a === void 0 || a.call(r, s.header), (o = r?.onTrailer) === null || o === void 0 || o.call(r, s.trailer), s.message;
  };
}
function fK(e, t) {
  return (n, r) => dF(e.stream(t, r?.signal, r?.timeoutMs, r?.headers, sK([n]), r?.contextValues), r);
}
function mK(e, t) {
  return async (n, r) => {
    var a, o, s, i, u, l;
    const c = await e.stream(t, r?.signal, r?.timeoutMs, r?.headers, n, r?.contextValues);
    (u = r?.onHeader) === null || u === void 0 || u.call(r, c.header);
    let f, d = 0;
    try {
      for (var m = !0, p = mF(c.message), b; b = await p.next(), a = b.done, !a; m = !0)
        i = b.value, m = !1, f = i, d++;
    } catch (g) {
      o = { error: g };
    } finally {
      try {
        !m && !a && (s = p.return) && await s.call(p);
      } finally {
        if (o) throw o.error;
      }
    }
    if (!f)
      throw new pe("protocol error: missing response message", $.Unimplemented);
    if (d > 1)
      throw new pe("protocol error: received extra messages for client streaming method", $.Unimplemented);
    return (l = r?.onTrailer) === null || l === void 0 || l.call(r, c.trailer), f;
  };
}
function dK(e, t) {
  return (n, r) => dF(e.stream(t, r?.signal, r?.timeoutMs, r?.headers, n, r?.contextValues), r);
}
function dF(e, t) {
  const n = (function() {
    return uK(this, arguments, function* () {
      var r, a;
      const o = yield $i(e);
      (r = t?.onHeader) === null || r === void 0 || r.call(t, o.header), yield $i(yield* iK(mF(o.message))), (a = t?.onTrailer) === null || a === void 0 || a.call(t, o.trailer);
    });
  })()[Symbol.asyncIterator]();
  return {
    [Symbol.asyncIterator]: () => ({
      next: () => n.next()
    })
  };
}
function pK(...e) {
  const t = new AbortController(), n = e.filter((a) => a !== void 0).concat(t.signal);
  for (const a of n) {
    if (a.aborted) {
      r.apply(a);
      break;
    }
    a.addEventListener("abort", r);
  }
  function r() {
    t.signal.aborted || t.abort(pF(this));
    for (const a of n)
      a.removeEventListener("abort", r);
  }
  return t;
}
function bK(e) {
  const t = new AbortController(), n = () => {
    t.abort(new pe("the operation timed out", $.DeadlineExceeded));
  };
  let r;
  return e !== void 0 && (e <= 0 ? n() : r = setTimeout(n, e)), {
    signal: t.signal,
    cleanup: () => clearTimeout(r)
  };
}
function pF(e) {
  if (!e.aborted)
    return;
  if (e.reason !== void 0)
    return e.reason;
  const t = new Error("This operation was aborted");
  return t.name = "AbortError", t;
}
function qI() {
  return {
    get(e) {
      return e.id in this ? this[e.id] : e.defaultValue;
    },
    set(e, t) {
      return this[e.id] = t, this;
    },
    delete(e) {
      return delete this[e.id], this;
    }
  };
}
function QI(e, t) {
  return e.toString().replace(/\/?$/, `/${t.parent.typeName}/${t.name}`);
}
function bF(e, t) {
  return mr(e, t);
}
function gK(e, t) {
  function n(r) {
    return r.done === !0 ? r : {
      done: r.done,
      value: bF(e, r.value)
    };
  }
  return {
    [Symbol.asyncIterator]() {
      const r = t[Symbol.asyncIterator](), a = {
        next: () => r.next().then(n)
      };
      return r.throw !== void 0 && (a.throw = (o) => r.throw(o).then(n)), r.return !== void 0 && (a.return = (o) => r.return(o).then(n)), a;
    }
  };
}
function gF(e, t) {
  if (!t)
    return e;
  for (const n of t.concat().reverse())
    e = n(e);
  return e;
}
function hF(e) {
  var t;
  const n = Object.assign({}, e);
  return (t = n.ignoreUnknownFields) !== null && t !== void 0 || (n.ignoreUnknownFields = !0), n;
}
function ew(e, t, n, r) {
  const a = t ? tw(e.input, r) : nw(e.input, n);
  return { parse: (t ? tw(e.output, r) : nw(e.output, n)).parse, serialize: a.serialize };
}
function tw(e, t) {
  return {
    parse(n) {
      try {
        return rb(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new pe(`parse binary: ${a}`, $.Internal);
      }
    },
    serialize(n) {
      try {
        return qL(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new pe(`serialize binary: ${a}`, $.Internal);
      }
    }
  };
}
function nw(e, t) {
  var n, r;
  const a = (n = t?.textEncoder) !== null && n !== void 0 ? n : new TextEncoder(), o = (r = t?.textDecoder) !== null && r !== void 0 ? r : new TextDecoder(), s = hF(t);
  return {
    parse(i) {
      try {
        const u = o.decode(i);
        return $C(e, u, s);
      } catch (u) {
        throw pe.from(u, $.InvalidArgument);
      }
    },
    serialize(i) {
      try {
        const u = _C(e, i, s);
        return a.encode(u);
      } catch (u) {
        throw pe.from(u, $.Internal);
      }
    }
  };
}
const hK = /^application\/(connect\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i, yK = "application/proto", NK = "application/json", EK = "application/connect+proto", vK = "application/connect+json";
function TK(e) {
  const t = e?.match(hK);
  if (!t)
    return;
  const n = !!t[1], r = !!t[3];
  return { stream: n, binary: r };
}
function yF(e, t, n) {
  var r;
  if (t && new Headers(t).forEach((i, u) => n.metadata.append(u, i)), typeof e != "object" || e == null || Array.isArray(e))
    throw n;
  let a = n.code;
  "code" in e && typeof e.code == "string" && (a = (r = JC(e.code)) !== null && r !== void 0 ? r : a);
  const o = e.message;
  if (o != null && typeof o != "string")
    throw n;
  const s = new pe(o ?? "", a, t);
  if ("details" in e && Array.isArray(e.details))
    for (const i of e.details) {
      if (i === null || typeof i != "object" || Array.isArray(i) || typeof i.type != "string" || typeof i.value != "string")
        throw n;
      try {
        s.details.push({
          type: i.type,
          value: TE(i.value),
          debug: i.debug
        });
      } catch {
        throw n;
      }
    }
  return s;
}
const rw = 2;
function IK(e) {
  const t = new pe("invalid end stream", $.Unknown);
  let n;
  try {
    n = JSON.parse(typeof e == "string" ? e : new TextDecoder().decode(e));
  } catch {
    throw t;
  }
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw t;
  const r = new Headers();
  if ("metadata" in n) {
    if (typeof n.metadata != "object" || n.metadata == null || Array.isArray(n.metadata))
      throw t;
    for (const [o, s] of Object.entries(n.metadata)) {
      if (!Array.isArray(s) || s.some((i) => typeof i != "string"))
        throw t;
      for (const i of s)
        r.append(o, i);
    }
  }
  const a = "error" in n && n.error != null ? yF(n.error, r, t) : void 0;
  return { metadata: r, error: a };
}
const Td = "Content-Type", wK = "Content-Length", aw = "Content-Encoding", _K = "Accept-Encoding", OK = "Connect-Timeout-Ms", NF = "Connect-Protocol-Version", SK = "User-Agent";
function DK(e) {
  switch (e) {
    case 400:
      return $.Internal;
    case 401:
      return $.Unauthenticated;
    case 403:
      return $.PermissionDenied;
    case 404:
      return $.Unimplemented;
    case 429:
      return $.Unavailable;
    case 502:
      return $.Unavailable;
    case 503:
      return $.Unavailable;
    case 504:
      return $.Unavailable;
    default:
      return $.Unknown;
  }
}
function ow(e) {
  const t = new Headers(), n = new Headers();
  return e.forEach((r, a) => {
    a.toLowerCase().startsWith("trailer-") ? n.append(a.substring(8), r) : t.append(a, r);
  }), [t, n];
}
const EF = "1";
function sw(e, t, n, r, a) {
  const o = new Headers(r ?? {});
  return n !== void 0 && o.set(OK, `${n}`), o.set(Td, e == "unary" ? t ? yK : NK : t ? EK : vK), o.set(NF, EF), o.has(SK), o;
}
function iw(e, t, n, r) {
  const a = r.get(Td), o = TK(a);
  if (n !== 200) {
    const i = new pe(`HTTP ${n}`, DK(n), r);
    if (e == "unary" && o && !o.binary)
      return { isUnaryError: !0, unaryError: i };
    throw i;
  }
  const s = {
    binary: t,
    stream: e !== "unary"
  };
  if (o?.binary !== s.binary || o.stream !== s.stream)
    throw new pe(`unsupported content type ${a}`, o === void 0 ? $.Unknown : $.Internal, r);
  return { isUnaryError: !1 };
}
const uw = "application/";
function kK(e, t) {
  return t ? BL(e, "url") : encodeURIComponent(new TextDecoder().decode(e));
}
function AK(e, t, n) {
  let r = `?connect=v${EF}`;
  const a = e.header.get(Td);
  a?.indexOf(uw) === 0 && (r += "&encoding=" + encodeURIComponent(a.slice(uw.length)));
  const o = e.header.get(aw);
  o !== null && o !== "identity" && (r += "&compression=" + encodeURIComponent(o), n = !0), n && (r += "&base64=1"), r += "&message=" + kK(t, n);
  const s = e.url + r, i = new Headers(e.header);
  for (const u of [
    NF,
    Td,
    wK,
    aw,
    _K
  ])
    i.delete(u);
  return Object.assign(Object.assign({}, e), {
    requestMethod: "GET",
    url: s,
    header: i
  });
}
function LK(e) {
  const t = gF(e.next, e.interceptors), [n, r, a] = vF(e), o = Object.assign(Object.assign({}, e.req), { message: bF(e.req.method.input, e.req.message), signal: n });
  return t(o).then((s) => (a(), s), r);
}
function FK(e) {
  const t = gF(e.next, e.interceptors), [n, r, a] = vF(e), o = Object.assign(Object.assign({}, e.req), { message: gK(e.req.method.input, e.req.message), signal: n });
  let s = !1;
  return n.addEventListener("abort", function() {
    var i, u;
    const l = e.req.message[Symbol.asyncIterator]();
    s || (i = l.throw) === null || i === void 0 || i.call(l, this.reason).catch(() => {
    }), (u = l.return) === null || u === void 0 || u.call(l).catch(() => {
    });
  }), t(o).then((i) => Object.assign(Object.assign({}, i), { message: {
    [Symbol.asyncIterator]() {
      const u = i.message[Symbol.asyncIterator]();
      return {
        next() {
          return u.next().then((l) => (l.done == !0 && (s = !0, a()), l), r);
        }
        // We deliberately omit throw/return.
      };
    }
  } }), r);
}
function vF(e) {
  const { signal: t, cleanup: n } = bK(e.timeoutMs), r = pK(e.signal, t);
  return [
    r.signal,
    function(o) {
      const s = pe.from(t.aborted ? pF(t) : o);
      return r.abort(s), n(), Promise.reject(s);
    },
    function() {
      n(), r.abort();
    }
  ];
}
function UK() {
  try {
    new Headers();
  } catch {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}
var nl = function(e) {
  return this instanceof nl ? (this.v = e, this) : new nl(e);
}, RK = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof nl ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
const lw = {
  redirect: "error"
};
function $K(e) {
  var t;
  UK();
  const n = (t = e.useBinaryFormat) !== null && t !== void 0 ? t : !1;
  return {
    async unary(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = ew(r, n, e.jsonOptions, e.binaryOptions);
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await LK({
        interceptors: e.interceptors,
        signal: a,
        timeoutMs: o,
        req: {
          stream: !1,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: QI(e.baseUrl, r),
          header: sw(r.methodKind, n, o, s, !1),
          contextValues: u ?? qI(),
          message: i
        },
        next: async (f) => {
          var d;
          const m = e.useHttpGet === !0 && r.idempotency === ly.NO_SIDE_EFFECTS;
          let p = null;
          m ? f = AK(f, l(f.message), n) : p = l(f.message);
          const g = await ((d = e.fetch) !== null && d !== void 0 ? d : globalThis.fetch)(f.url, Object.assign(Object.assign({}, lw), { method: f.requestMethod, headers: f.header, signal: f.signal, body: p })), { isUnaryError: S, unaryError: D } = iw(r.methodKind, n, g.status, g.headers);
          if (S)
            throw yF(await g.json(), HC(...ow(g.headers)), D);
          const [k, U] = ow(g.headers);
          return {
            stream: !1,
            service: r.parent,
            method: r,
            header: k,
            message: n ? c(new Uint8Array(await g.arrayBuffer())) : iF(r.output, await g.json(), hF(e.jsonOptions)),
            trailer: U
          };
        }
      });
    },
    async stream(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = ew(r, n, e.jsonOptions, e.binaryOptions);
      function f(m, p, b, g) {
        return RK(this, arguments, function* () {
          const D = tK(m).getReader();
          let k = !1;
          for (; ; ) {
            const U = yield nl(D.read());
            if (U.done)
              break;
            const { flags: R, data: F } = U.value;
            if ((R & zI) === zI)
              throw new pe("protocol error: received unsupported compressed output", $.Internal);
            if ((R & rw) === rw) {
              k = !0;
              const A = IK(F);
              if (A.error) {
                const L = A.error;
                throw b.forEach((re, HG) => {
                  L.metadata.append(HG, re);
                }), L;
              }
              A.metadata.forEach((L, re) => p.set(re, L));
              continue;
            }
            yield yield nl(c(F));
          }
          if ("throwIfAborted" in g && g.throwIfAborted(), !k)
            throw "missing EndStreamResponse";
        });
      }
      async function d(m) {
        if (r.methodKind != "server_streaming")
          throw "The fetch API does not support streaming request bodies";
        const p = await m[Symbol.asyncIterator]().next();
        if (p.done == !0)
          throw "missing request message";
        return nK(0, l(p.value));
      }
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await FK({
        interceptors: e.interceptors,
        timeoutMs: o,
        signal: a,
        req: {
          stream: !0,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: QI(e.baseUrl, r),
          header: sw(r.methodKind, n, o, s, !1),
          contextValues: u ?? qI(),
          message: i
        },
        next: async (m) => {
          var p;
          const g = await ((p = e.fetch) !== null && p !== void 0 ? p : globalThis.fetch)(m.url, Object.assign(Object.assign({}, lw), { method: m.requestMethod, headers: m.header, signal: m.signal, body: await d(m.message) }));
          if (iw(r.methodKind, n, g.status, g.headers), g.body === null)
            throw "missing response body";
          const S = new Headers();
          return Object.assign(Object.assign({}, m), { header: g.headers, trailer: S, message: f(g.body, S, g.headers, m.signal) });
        }
      });
    }
  };
}
const PK = $K({
  baseUrl: "/api",
  useBinaryFormat: !0,
  fetch: (e, t) => {
    const n = t?.headers ?? {};
    return fetch(e, {
      ...t,
      headers: {
        ...n,
        "qt-widget-id": window.qtWidgetId
      }
    });
  }
});
function ENe(e) {
  return lK(e, PK);
}
const VK = 2, Ke = /* @__PURE__ */ Symbol(), my = !1;
var xK = Array.isArray, YK = Array.prototype.indexOf, Sg = Object.getOwnPropertyDescriptor, jK = Object.prototype, BK = Array.prototype, GK = Object.getPrototypeOf;
function MK(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function TF() {
  var e, t, n = new Promise((r, a) => {
    e = r, t = a;
  });
  return { promise: n, resolve: e, reject: t };
}
const Ce = 2, IF = 4, wF = 8, CK = 1 << 24, Qs = 16, Pc = 32, Eu = 64, LE = 128, dr = 512, ft = 1024, _n = 2048, Gr = 4096, Li = 8192, ao = 16384, _F = 32768, cw = 65536, fw = 1 << 17, OF = 1 << 18, FE = 1 << 19, KK = 1 << 20, Rs = 32768, dy = 1 << 21, UE = 1 << 22, oo = 1 << 23, Dg = /* @__PURE__ */ Symbol("$state"), ci = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function XK() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function WK() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function JK() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function ZK() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function HK() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function SF(e) {
  return e === this.v;
}
let zK = !1, Wa = null;
function Id(e) {
  Wa = e;
}
function qK(e, t = !1, n) {
  Wa = {
    p: Wa,
    i: !1,
    c: null,
    e: null,
    s: e,
    x: null,
    l: null
  };
}
function QK(e) {
  var t = (
    /** @type {ComponentContext} */
    Wa
  ), n = t.e;
  if (n !== null) {
    t.e = null;
    for (var r of n)
      h5(r);
  }
  return t.i = !0, Wa = t.p, /** @type {T} */
  {};
}
function DF() {
  return !0;
}
let fi = [];
function e5() {
  var e = fi;
  fi = [], MK(e);
}
function t5(e) {
  if (fi.length === 0) {
    var t = fi;
    queueMicrotask(() => {
      t === fi && e5();
    });
  }
  fi.push(e);
}
function n5(e) {
  var t = ne;
  if (t === null)
    return P.f |= oo, e;
  if ((t.f & _F) === 0) {
    if ((t.f & LE) === 0)
      throw e;
    t.b.error(e);
  } else
    wd(e, t);
}
function wd(e, t) {
  for (; t !== null; ) {
    if ((t.f & LE) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e;
}
const qf = /* @__PURE__ */ new Set();
let be = null, Pn = null, Fr = [], RE = null, py = !1;
class rl {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #e = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #i = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    Fr = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const r of t)
      this.#u(r, n);
    this.is_fork || this.#c(), this.is_deferred() ? (this.#n(n.effects), this.#n(n.render_effects)) : (be = null, mw(n.render_effects), mw(n.effects), this.#i?.resolve()), Pn = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #u(t, n) {
    t.f ^= ft;
    for (var r = t.first; r !== null; ) {
      var a = r.f, o = (a & (Pc | Eu)) !== 0, s = o && (a & ft) !== 0, i = s || (a & Li) !== 0 || this.skipped_effects.has(r);
      if ((r.f & LE) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: []
      }), !i && r.fn !== null) {
        o ? r.f ^= ft : (a & IF) !== 0 ? n.effects.push(r) : xc(r) && ((r.f & Qs) !== 0 && this.#o.add(r), ol(r));
        var u = r.first;
        if (u !== null) {
          r = u;
          continue;
        }
      }
      var l = r.parent;
      for (r = r.next; r === null && l !== null; )
        l === n.effect && (this.#n(n.effects), this.#n(n.render_effects), n = /** @type {EffectTarget} */
        n.parent), r = l.next, l = l.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #n(t) {
    for (const n of t)
      (n.f & _n) !== 0 ? this.#o.add(n) : (n.f & Gr) !== 0 && this.#s.add(n), this.#l(n.deps), mt(n, ft);
  }
  /**
   * @param {Value[] | null} deps
   */
  #l(t) {
    if (t !== null)
      for (const n of t)
        (n.f & Ce) === 0 || (n.f & Rs) === 0 || (n.f ^= Rs, this.#l(
          /** @type {Derived} */
          n.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.previous.has(t) || this.previous.set(t, n), (t.f & oo) === 0 && (this.current.set(t, t.v), Pn?.set(t, t.v));
  }
  activate() {
    be = this, this.apply();
  }
  deactivate() {
    be === this && (be = null, Pn = null);
  }
  flush() {
    if (this.activate(), Fr.length > 0) {
      if (r5(), be !== null && be !== this)
        return;
    } else this.#e === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const t of this.#a) t(this);
    this.#a.clear();
  }
  #c() {
    if (this.#t === 0) {
      for (const t of this.#r) t();
      this.#r.clear();
    }
    this.#e === 0 && this.#f();
  }
  #f() {
    if (qf.size > 1) {
      this.previous.clear();
      var t = Pn, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const o of qf) {
        if (o === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [u, l] of this.current) {
          if (o.current.has(u))
            if (n && l !== o.current.get(u))
              o.current.set(u, l);
            else
              continue;
          s.push(u);
        }
        if (s.length === 0)
          continue;
        const i = [...o.current.keys()].filter((u) => !this.current.has(u));
        if (i.length > 0) {
          var a = Fr;
          Fr = [];
          const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            kF(c, i, u, l);
          if (Fr.length > 0) {
            be = o, o.apply();
            for (const c of Fr)
              o.#u(c, r);
            o.deactivate();
          }
          Fr = a;
        }
      }
      be = null, Pn = t;
    }
    this.committed = !0, qf.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(t) {
    this.#e += 1, t && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(t) {
    this.#e -= 1, t && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const t of this.#o)
      this.#s.delete(t), mt(t, _n), Pi(t);
    for (const t of this.#s)
      mt(t, Gr), Pi(t);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(t) {
    this.#r.add(t);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(t) {
    this.#a.add(t);
  }
  settled() {
    return (this.#i ??= TF()).promise;
  }
  static ensure() {
    if (be === null) {
      const t = be = new rl();
      qf.add(be), rl.enqueue(() => {
        be === t && t.flush();
      });
    }
    return be;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    t5(t);
  }
  apply() {
  }
}
function r5() {
  var e = as;
  py = !0;
  var t = null;
  try {
    var n = 0;
    for (Sd(!0); Fr.length > 0; ) {
      var r = rl.ensure();
      if (n++ > 1e3) {
        var a, o;
        a5();
      }
      r.process(Fr), so.clear();
    }
  } finally {
    py = !1, Sd(e), RE = null;
  }
}
function a5() {
  try {
    WK();
  } catch (e) {
    wd(e, RE);
  }
}
let ua = null;
function mw(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (ao | Li)) === 0 && xc(r) && (ua = /* @__PURE__ */ new Set(), ol(r), r.deps === null && r.first === null && r.nodes === null && (r.teardown === null && r.ac === null ? BF(r) : r.fn = null), ua?.size > 0)) {
        so.clear();
        for (const a of ua) {
          if ((a.f & (ao | Li)) !== 0) continue;
          const o = [a];
          let s = a.parent;
          for (; s !== null; )
            ua.has(s) && (ua.delete(s), o.push(s)), s = s.parent;
          for (let i = o.length - 1; i >= 0; i--) {
            const u = o[i];
            (u.f & (ao | Li)) === 0 && ol(u);
          }
        }
        ua.clear();
      }
    }
    ua = null;
  }
}
function kF(e, t, n, r) {
  if (!n.has(e) && (n.add(e), e.reactions !== null))
    for (const a of e.reactions) {
      const o = a.f;
      (o & Ce) !== 0 ? kF(
        /** @type {Derived} */
        a,
        t,
        n,
        r
      ) : (o & (UE | Qs)) !== 0 && (o & _n) === 0 && AF(a, t, r) && (mt(a, _n), Pi(
        /** @type {Effect} */
        a
      ));
    }
}
function AF(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (e.deps !== null)
    for (const a of e.deps) {
      if (t.includes(a))
        return !0;
      if ((a.f & Ce) !== 0 && AF(
        /** @type {Derived} */
        a,
        t,
        n
      ))
        return n.set(
          /** @type {Derived} */
          a,
          !0
        ), !0;
    }
  return n.set(e, !1), !1;
}
function Pi(e) {
  for (var t = RE = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (py && t === ne && (n & Qs) !== 0 && (n & OF) === 0)
      return;
    if ((n & (Eu | Pc)) !== 0) {
      if ((n & ft) === 0) return;
      t.f ^= ft;
    }
  }
  Fr.push(t);
}
function o5(e, t, n, r) {
  const a = i5;
  if (n.length === 0 && e.length === 0) {
    r(t.map(a));
    return;
  }
  var o = be, s = (
    /** @type {Effect} */
    ne
  ), i = s5();
  function u() {
    Promise.all(n.map((l) => /* @__PURE__ */ u5(l))).then((l) => {
      i();
      try {
        r([...t.map(a), ...l]);
      } catch (c) {
        (s.f & ao) === 0 && wd(c, s);
      }
      o?.deactivate(), _d();
    }).catch((l) => {
      wd(l, s);
    });
  }
  e.length > 0 ? Promise.all(e).then(() => {
    i();
    try {
      return u();
    } finally {
      o?.deactivate(), _d();
    }
  }) : u();
}
function s5() {
  var e = ne, t = P, n = Wa, r = be;
  return function(o = !0) {
    Vi(e), yo(t), Id(n), o && r?.activate();
  };
}
function _d() {
  Vi(null), yo(null), Id(null);
}
// @__NO_SIDE_EFFECTS__
function i5(e) {
  var t = Ce | _n, n = P !== null && (P.f & Ce) !== 0 ? (
    /** @type {Derived} */
    P
  ) : null;
  return ne !== null && (ne.f |= FE), {
    ctx: Wa,
    deps: null,
    effects: null,
    equals: SF,
    f: t,
    fn: e,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      Ke
    ),
    wv: 0,
    parent: n ?? ne,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function u5(e, t) {
  let n = (
    /** @type {Effect | null} */
    ne
  );
  n === null && XK();
  var r = (
    /** @type {Boundary} */
    n.b
  ), a = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), o = RF(
    /** @type {V} */
    Ke
  ), s = !P, i = /* @__PURE__ */ new Map();
  return y5(() => {
    var u = TF();
    a = u.promise;
    try {
      Promise.resolve(e()).then(u.resolve, u.reject).then(() => {
        l === be && l.committed && l.deactivate(), _d();
      });
    } catch (d) {
      u.reject(d), _d();
    }
    var l = (
      /** @type {Batch} */
      be
    );
    if (s) {
      var c = !r.is_pending();
      r.update_pending_count(1), l.increment(c), i.get(l)?.reject(ci), i.delete(l), i.set(l, u);
    }
    const f = (d, m = void 0) => {
      if (l.activate(), m)
        m !== ci && (o.f |= oo, gy(o, m));
      else {
        (o.f & oo) !== 0 && (o.f ^= oo), gy(o, d);
        for (const [p, b] of i) {
          if (i.delete(p), p === l) break;
          b.reject(ci);
        }
      }
      s && (r.update_pending_count(-1), l.decrement(c));
    };
    u.promise.then(f, (d) => f(null, d || "unknown"));
  }), g5(() => {
    for (const u of i.values())
      u.reject(ci);
  }), new Promise((u) => {
    function l(c) {
      function f() {
        c === a ? u(o) : l(a);
      }
      c.then(f, f);
    }
    l(a);
  });
}
function LF(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      cb(
        /** @type {Effect} */
        t[n]
      );
  }
}
function l5(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & Ce) === 0)
      return (t.f & ao) === 0 ? (
        /** @type {Effect} */
        t
      ) : null;
    t = t.parent;
  }
  return null;
}
function $E(e) {
  var t, n = ne;
  Vi(l5(e));
  try {
    e.f &= ~Rs, LF(e), t = KF(e);
  } finally {
    Vi(n);
  }
  return t;
}
function FF(e) {
  var t = $E(e);
  if (e.equals(t) || (be?.is_fork || (e.v = t), e.wv = MF()), !Vc)
    if (Pn !== null)
      (Od() || be?.is_fork) && Pn.set(e, t);
    else {
      var n = (e.f & dr) === 0 ? Gr : ft;
      mt(e, n);
    }
}
let by = /* @__PURE__ */ new Set();
const so = /* @__PURE__ */ new Map();
let UF = !1;
function RF(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: SF,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function Ja(e, t) {
  const n = RF(e);
  return T5(n), n;
}
function ko(e, t, n = !1) {
  P !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Jo || (P.f & fw) !== 0) && DF() && (P.f & (Ce | Qs | UE | fw)) !== 0 && !Va?.includes(e) && HK();
  let r = n ? mi(t) : t;
  return gy(e, r);
}
function gy(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    Vc ? so.set(e, t) : so.set(e, n), e.v = t;
    var r = rl.ensure();
    r.capture(e, n), (e.f & Ce) !== 0 && ((e.f & _n) !== 0 && $E(
      /** @type {Derived} */
      e
    ), mt(e, (e.f & dr) !== 0 ? ft : Gr)), e.wv = MF(), $F(e, _n), ne !== null && (ne.f & ft) !== 0 && (ne.f & (Pc | Eu)) === 0 && (On === null ? I5([e]) : On.push(e)), !r.is_fork && by.size > 0 && !UF && c5();
  }
  return t;
}
function c5() {
  UF = !1;
  var e = as;
  Sd(!0);
  const t = Array.from(by);
  try {
    for (const n of t)
      (n.f & ft) !== 0 && mt(n, Gr), xc(n) && ol(n);
  } finally {
    Sd(e);
  }
  by.clear();
}
function kg(e) {
  ko(e, e.v + 1);
}
function $F(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, a = 0; a < r; a++) {
      var o = n[a], s = o.f, i = (s & _n) === 0;
      if (i && mt(o, t), (s & Ce) !== 0) {
        var u = (
          /** @type {Derived} */
          o
        );
        Pn?.delete(u), (s & Rs) === 0 && (s & dr && (o.f |= Rs), $F(u, Gr));
      } else i && ((s & Qs) !== 0 && ua !== null && ua.add(
        /** @type {Effect} */
        o
      ), Pi(
        /** @type {Effect} */
        o
      ));
    }
}
function mi(e) {
  if (typeof e != "object" || e === null || Dg in e)
    return e;
  const t = GK(e);
  if (t !== jK && t !== BK)
    return e;
  var n = /* @__PURE__ */ new Map(), r = xK(e), a = /* @__PURE__ */ Ja(0), o = os, s = (i) => {
    if (os === o)
      return i();
    var u = P, l = os;
    yo(null), bw(o);
    var c = i();
    return yo(u), bw(l), c;
  };
  return r && n.set("length", /* @__PURE__ */ Ja(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(i, u, l) {
        (!("value" in l) || l.configurable === !1 || l.enumerable === !1 || l.writable === !1) && JK();
        var c = n.get(u);
        return c === void 0 ? c = s(() => {
          var f = /* @__PURE__ */ Ja(l.value);
          return n.set(u, f), f;
        }) : ko(c, l.value, !0), !0;
      },
      deleteProperty(i, u) {
        var l = n.get(u);
        if (l === void 0) {
          if (u in i) {
            const c = s(() => /* @__PURE__ */ Ja(Ke));
            n.set(u, c), kg(a);
          }
        } else
          ko(l, Ke), kg(a);
        return !0;
      },
      get(i, u, l) {
        if (u === Dg)
          return e;
        var c = n.get(u), f = u in i;
        if (c === void 0 && (!f || Sg(i, u)?.writable) && (c = s(() => {
          var m = mi(f ? i[u] : Ke), p = /* @__PURE__ */ Ja(m);
          return p;
        }), n.set(u, c)), c !== void 0) {
          var d = ju(c);
          return d === Ke ? void 0 : d;
        }
        return Reflect.get(i, u, l);
      },
      getOwnPropertyDescriptor(i, u) {
        var l = Reflect.getOwnPropertyDescriptor(i, u);
        if (l && "value" in l) {
          var c = n.get(u);
          c && (l.value = ju(c));
        } else if (l === void 0) {
          var f = n.get(u), d = f?.v;
          if (f !== void 0 && d !== Ke)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return l;
      },
      has(i, u) {
        if (u === Dg)
          return !0;
        var l = n.get(u), c = l !== void 0 && l.v !== Ke || Reflect.has(i, u);
        if (l !== void 0 || ne !== null && (!c || Sg(i, u)?.writable)) {
          l === void 0 && (l = s(() => {
            var d = c ? mi(i[u]) : Ke, m = /* @__PURE__ */ Ja(d);
            return m;
          }), n.set(u, l));
          var f = ju(l);
          if (f === Ke)
            return !1;
        }
        return c;
      },
      set(i, u, l, c) {
        var f = n.get(u), d = u in i;
        if (r && u === "length")
          for (var m = l; m < /** @type {Source<number>} */
          f.v; m += 1) {
            var p = n.get(m + "");
            p !== void 0 ? ko(p, Ke) : m in i && (p = s(() => /* @__PURE__ */ Ja(Ke)), n.set(m + "", p));
          }
        if (f === void 0)
          (!d || Sg(i, u)?.writable) && (f = s(() => /* @__PURE__ */ Ja(void 0)), ko(f, mi(l)), n.set(u, f));
        else {
          d = f.v !== Ke;
          var b = s(() => mi(l));
          ko(f, b);
        }
        var g = Reflect.getOwnPropertyDescriptor(i, u);
        if (g?.set && g.set.call(c, l), !d) {
          if (r && typeof u == "string") {
            var S = (
              /** @type {Source<number>} */
              n.get("length")
            ), D = Number(u);
            Number.isInteger(D) && D >= S.v && ko(S, D + 1);
          }
          kg(a);
        }
        return !0;
      },
      ownKeys(i) {
        ju(a);
        var u = Reflect.ownKeys(i).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== Ke;
        });
        for (var [l, c] of n)
          c.v !== Ke && !(l in i) && u.push(l);
        return u;
      },
      setPrototypeOf() {
        ZK();
      }
    }
  );
}
var f5, m5, d5;
// @__NO_SIDE_EFFECTS__
function PF(e) {
  return (
    /** @type {TemplateNode | null} */
    m5.call(e)
  );
}
// @__NO_SIDE_EFFECTS__
function VF(e) {
  return (
    /** @type {TemplateNode | null} */
    d5.call(e)
  );
}
function dw(e, t) {
  return /* @__PURE__ */ PF(e);
}
function p5(e, t = 1, n = !1) {
  let r = e;
  for (; t--; )
    r = /** @type {TemplateNode} */
    /* @__PURE__ */ VF(r);
  return r;
}
function xF(e) {
  var t = P, n = ne;
  yo(null), Vi(null);
  try {
    return e();
  } finally {
    yo(t), Vi(n);
  }
}
function b5(e, t) {
  var n = t.last;
  n === null ? t.last = t.first = e : (n.next = e, e.prev = n, t.last = e);
}
function lb(e, t, n) {
  var r = ne;
  r !== null && (r.f & Li) !== 0 && (e |= Li);
  var a = {
    ctx: Wa,
    deps: null,
    nodes: null,
    f: e | _n | dr,
    first: null,
    fn: t,
    last: null,
    next: null,
    parent: r,
    b: r && r.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (n)
    try {
      ol(a), a.f |= _F;
    } catch (i) {
      throw cb(a), i;
    }
  else t !== null && Pi(a);
  var o = a;
  if (n && o.deps === null && o.teardown === null && o.nodes === null && o.first === o.last && // either `null`, or a singular child
  (o.f & FE) === 0 && (o = o.first, (e & Qs) !== 0 && (e & cw) !== 0 && o !== null && (o.f |= cw)), o !== null && (o.parent = r, r !== null && b5(o, r), P !== null && (P.f & Ce) !== 0 && (e & Eu) === 0)) {
    var s = (
      /** @type {Derived} */
      P
    );
    (s.effects ??= []).push(o);
  }
  return a;
}
function Od() {
  return P !== null && !Jo;
}
function g5(e) {
  const t = lb(wF, null, !1);
  return mt(t, ft), t.teardown = e, t;
}
function h5(e) {
  return lb(IF | KK, e, !1);
}
function y5(e) {
  return lb(UE | FE, e, !0);
}
function N5(e, t = [], n = [], r = []) {
  o5(r, t, n, (a) => {
    lb(wF, () => e(...a.map(ju)), !0);
  });
}
function YF(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = Vc, r = P;
    pw(!0), yo(null);
    try {
      t.call(null);
    } finally {
      pw(n), yo(r);
    }
  }
}
function jF(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const a = n.ac;
    a !== null && xF(() => {
      a.abort(ci);
    });
    var r = n.next;
    (n.f & Eu) !== 0 ? n.parent = null : cb(n, t), n = r;
  }
}
function E5(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & Pc) === 0 && cb(t), t = n;
  }
}
function cb(e, t = !0) {
  var n = !1;
  (t || (e.f & OF) !== 0) && e.nodes !== null && e.nodes.end !== null && (v5(
    e.nodes.start,
    /** @type {TemplateNode} */
    e.nodes.end
  ), n = !0), jF(e, t && !n), Dd(e, 0), mt(e, ao);
  var r = e.nodes && e.nodes.t;
  if (r !== null)
    for (const o of r)
      o.stop();
  YF(e);
  var a = e.parent;
  a !== null && a.first !== null && BF(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes = e.ac = null;
}
function v5(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : /* @__PURE__ */ VF(e);
    e.remove(), e = n;
  }
}
function BF(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
let as = !1;
function Sd(e) {
  as = e;
}
let Vc = !1;
function pw(e) {
  Vc = e;
}
let P = null, Jo = !1;
function yo(e) {
  P = e;
}
let ne = null;
function Vi(e) {
  ne = e;
}
let Va = null;
function T5(e) {
  P !== null && (Va === null ? Va = [e] : Va.push(e));
}
let tt = null, bn = 0, On = null;
function I5(e) {
  On = e;
}
let GF = 1, al = 0, os = al;
function bw(e) {
  os = e;
}
function MF() {
  return ++GF;
}
function xc(e) {
  var t = e.f;
  if ((t & _n) !== 0)
    return !0;
  if (t & Ce && (e.f &= ~Rs), (t & Gr) !== 0) {
    var n = e.deps;
    if (n !== null)
      for (var r = n.length, a = 0; a < r; a++) {
        var o = n[a];
        if (xc(
          /** @type {Derived} */
          o
        ) && FF(
          /** @type {Derived} */
          o
        ), o.wv > e.wv)
          return !0;
      }
    (t & dr) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Pn === null && mt(e, ft);
  }
  return !1;
}
function CF(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !Va?.includes(e))
    for (var a = 0; a < r.length; a++) {
      var o = r[a];
      (o.f & Ce) !== 0 ? CF(
        /** @type {Derived} */
        o,
        t,
        !1
      ) : t === o && (n ? mt(o, _n) : (o.f & ft) !== 0 && mt(o, Gr), Pi(
        /** @type {Effect} */
        o
      ));
    }
}
function KF(e) {
  var t = tt, n = bn, r = On, a = P, o = Va, s = Wa, i = Jo, u = os, l = e.f;
  tt = /** @type {null | Value[]} */
  null, bn = 0, On = null, P = (l & (Pc | Eu)) === 0 ? e : null, Va = null, Id(e.ctx), Jo = !1, os = ++al, e.ac !== null && (xF(() => {
    e.ac.abort(ci);
  }), e.ac = null);
  try {
    e.f |= dy;
    var c = (
      /** @type {Function} */
      e.fn
    ), f = c(), d = e.deps;
    if (tt !== null) {
      var m;
      if (Dd(e, bn), d !== null && bn > 0)
        for (d.length = bn + tt.length, m = 0; m < tt.length; m++)
          d[bn + m] = tt[m];
      else
        e.deps = d = tt;
      if (Od() && (e.f & dr) !== 0)
        for (m = bn; m < d.length; m++)
          (d[m].reactions ??= []).push(e);
    } else d !== null && bn < d.length && (Dd(e, bn), d.length = bn);
    if (DF() && On !== null && !Jo && d !== null && (e.f & (Ce | Gr | _n)) === 0)
      for (m = 0; m < /** @type {Source[]} */
      On.length; m++)
        CF(
          On[m],
          /** @type {Effect} */
          e
        );
    return a !== null && a !== e && (al++, On !== null && (r === null ? r = On : r.push(.../** @type {Source[]} */
    On))), (e.f & oo) !== 0 && (e.f ^= oo), f;
  } catch (p) {
    return n5(p);
  } finally {
    e.f ^= dy, tt = t, bn = n, On = r, P = a, Va = o, Id(s), Jo = i, os = u;
  }
}
function w5(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = YK.call(n, e);
    if (r !== -1) {
      var a = n.length - 1;
      a === 0 ? n = t.reactions = null : (n[r] = n[a], n.pop());
    }
  }
  n === null && (t.f & Ce) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (tt === null || !tt.includes(t)) && (mt(t, Gr), (t.f & dr) !== 0 && (t.f ^= dr, t.f &= ~Rs), LF(
    /** @type {Derived} **/
    t
  ), Dd(
    /** @type {Derived} **/
    t,
    0
  ));
}
function Dd(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      w5(e, n[r]);
}
function ol(e) {
  var t = e.f;
  if ((t & ao) === 0) {
    mt(e, ft);
    var n = ne, r = as;
    ne = e, as = !0;
    try {
      (t & (Qs | CK)) !== 0 ? E5(e) : jF(e), YF(e);
      var a = KF(e);
      e.teardown = typeof a == "function" ? a : null, e.wv = GF;
      var o;
      my && zK && (e.f & _n) !== 0 && e.deps;
    } finally {
      as = r, ne = n;
    }
  }
}
function ju(e) {
  var t = e.f, n = (t & Ce) !== 0;
  if (P !== null && !Jo) {
    var r = ne !== null && (ne.f & ao) !== 0;
    if (!r && !Va?.includes(e)) {
      var a = P.deps;
      if ((P.f & dy) !== 0)
        e.rv < al && (e.rv = al, tt === null && a !== null && a[bn] === e ? bn++ : tt === null ? tt = [e] : tt.includes(e) || tt.push(e));
      else {
        (P.deps ??= []).push(e);
        var o = e.reactions;
        o === null ? e.reactions = [P] : o.includes(P) || o.push(P);
      }
    }
  }
  if (Vc) {
    if (so.has(e))
      return so.get(e);
    if (n) {
      var s = (
        /** @type {Derived} */
        e
      ), i = s.v;
      return ((s.f & ft) === 0 && s.reactions !== null || WF(s)) && (i = $E(s)), so.set(s, i), i;
    }
  } else n && (!Pn?.has(e) || be?.is_fork && !Od()) && (s = /** @type {Derived} */
  e, xc(s) && FF(s), as && Od() && (s.f & dr) === 0 && XF(s));
  if (Pn?.has(e))
    return Pn.get(e);
  if ((e.f & oo) !== 0)
    throw e.v;
  return e.v;
}
function XF(e) {
  if (e.deps !== null) {
    e.f ^= dr;
    for (const t of e.deps)
      (t.reactions ??= []).push(e), (t.f & Ce) !== 0 && (t.f & dr) === 0 && XF(
        /** @type {Derived} */
        t
      );
  }
}
function WF(e) {
  if (e.v === Ke) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (so.has(t) || (t.f & Ce) !== 0 && WF(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
const _5 = -7169;
function mt(e, t) {
  e.f = e.f & _5 | t;
}
function O5(e) {
  var t = document.createElement("template");
  return t.innerHTML = e.replaceAll("<!>", "<!---->"), t.content;
}
function S5(e, t) {
  var n = (
    /** @type {Effect} */
    ne
  );
  n.nodes === null && (n.nodes = { start: e, end: t, a: null, t: null });
}
// @__NO_SIDE_EFFECTS__
function D5(e, t) {
  var n = (t & VK) !== 0, r, a = !e.startsWith("<!>");
  return () => {
    r === void 0 && (r = O5(a ? e : "<!>" + e), r = /** @type {TemplateNode} */
    /* @__PURE__ */ PF(r));
    var o = (
      /** @type {TemplateNode} */
      n || f5 ? document.importNode(r, !0) : r.cloneNode(!0)
    );
    return S5(o, o), o;
  };
}
function k5(e, t) {
  e !== null && e.before(
    /** @type {Node} */
    t
  );
}
function A5(e, t) {
  var n = t == null ? "" : typeof t == "object" ? t + "" : t;
  n !== (e.__t ??= e.nodeValue) && (e.__t = n, e.nodeValue = n + "");
}
const gw = [...` 	
\r\f\v\uFEFF`];
function L5(e, t, n) {
  var r = e == null ? "" : "" + e;
  if (n) {
    for (var a in n)
      if (n[a])
        r = r ? r + " " + a : a;
      else if (r.length)
        for (var o = a.length, s = 0; (s = r.indexOf(a, s)) >= 0; ) {
          var i = s + o;
          (s === 0 || gw.includes(r[s - 1])) && (i === r.length || gw.includes(r[i])) ? r = (s === 0 ? "" : r.substring(0, s)) + r.substring(i + 1) : s = i;
        }
  }
  return r === "" ? null : r;
}
function F5(e, t) {
  return e == null ? null : String(e);
}
function hw(e, t, n, r, a, o) {
  var s = e.__className;
  if (s !== n || s === void 0) {
    var i = L5(n, r, o);
    i == null ? e.removeAttribute("class") : e.className = i, e.__className = n;
  } else if (o && a !== o)
    for (var u in o) {
      var l = !!o[u];
      (a == null || l !== !!a[u]) && e.classList.toggle(u, l);
    }
  return o;
}
function U5(e, t, n, r) {
  var a = e.__style;
  if (a !== t) {
    var o = F5(t);
    o == null ? e.removeAttribute("style") : e.style.cssText = o, e.__style = t;
  }
  return r;
}
function Ag(e, t, n, r) {
  var a = (
    /** @type {V} */
    r
  ), o = !0, s = () => (o && (o = !1, a = /** @type {V} */
  r), a), i;
  i = /** @type {V} */
  e[t], i === void 0 && r !== void 0 && (i = s());
  var u;
  return u = () => {
    var l = (
      /** @type {V} */
      e[t]
    );
    return l === void 0 ? s() : (o = !0, l);
  }, u;
}
function TNe() {
  const e = window.location.hash == "#night";
  return e && (document.documentElement.className = "night-mode", document.documentElement.dataset.bsTheme = "dark"), e;
}
function JF() {
  return {
    isDark: document.documentElement.classList.contains("night-mode")
  };
}
const R5 = mi(JF()), $5 = new MutationObserver((e, t) => {
  R5.isDark = JF().isDark;
});
$5.observe(document.documentElement, { attributeFilter: ["class"] });
const P5 = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(P5);
var V;
(function(e) {
  e[e.Canceled = 1] = "Canceled", e[e.Unknown = 2] = "Unknown", e[e.InvalidArgument = 3] = "InvalidArgument", e[e.DeadlineExceeded = 4] = "DeadlineExceeded", e[e.NotFound = 5] = "NotFound", e[e.AlreadyExists = 6] = "AlreadyExists", e[e.PermissionDenied = 7] = "PermissionDenied", e[e.ResourceExhausted = 8] = "ResourceExhausted", e[e.FailedPrecondition = 9] = "FailedPrecondition", e[e.Aborted = 10] = "Aborted", e[e.OutOfRange = 11] = "OutOfRange", e[e.Unimplemented = 12] = "Unimplemented", e[e.Internal = 13] = "Internal", e[e.Unavailable = 14] = "Unavailable", e[e.DataLoss = 15] = "DataLoss", e[e.Unauthenticated = 16] = "Unauthenticated";
})(V || (V = {}));
function PE(e, t) {
  return e !== null && typeof e == "object" && "$typeName" in e && typeof e.$typeName == "string" ? t === void 0 ? !0 : t.typeName === e.$typeName : !1;
}
var y;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(y || (y = {}));
function V5() {
  let e = 0, t = 0;
  for (let r = 0; r < 28; r += 7) {
    let a = this.buf[this.pos++];
    if (e |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  let n = this.buf[this.pos++];
  if (e |= (n & 15) << 28, t = (n & 112) >> 4, (n & 128) == 0)
    return this.assertBounds(), [e, t];
  for (let r = 3; r <= 31; r += 7) {
    let a = this.buf[this.pos++];
    if (t |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  throw new Error("invalid varint");
}
function Lg(e, t, n) {
  for (let o = 0; o < 28; o = o + 7) {
    const s = e >>> o, i = !(!(s >>> 7) && t == 0), u = (i ? s | 128 : s) & 255;
    if (n.push(u), !i)
      return;
  }
  const r = e >>> 28 & 15 | (t & 7) << 4, a = t >> 3 != 0;
  if (n.push((a ? r | 128 : r) & 255), !!a) {
    for (let o = 3; o < 31; o = o + 7) {
      const s = t >>> o, i = !!(s >>> 7), u = (i ? s | 128 : s) & 255;
      if (n.push(u), !i)
        return;
    }
    n.push(t >>> 31 & 1);
  }
}
const Xm = 4294967296;
function yw(e) {
  const t = e[0] === "-";
  t && (e = e.slice(1));
  const n = 1e6;
  let r = 0, a = 0;
  function o(s, i) {
    const u = Number(e.slice(s, i));
    a *= n, r = r * n + u, r >= Xm && (a = a + (r / Xm | 0), r = r % Xm);
  }
  return o(-24, -18), o(-18, -12), o(-12, -6), o(-6), t ? HF(r, a) : VE(r, a);
}
function x5(e, t) {
  let n = VE(e, t);
  const r = n.hi & 2147483648;
  r && (n = HF(n.lo, n.hi));
  const a = ZF(n.lo, n.hi);
  return r ? "-" + a : a;
}
function ZF(e, t) {
  if ({ lo: e, hi: t } = Y5(e, t), t <= 2097151)
    return String(Xm * t + e);
  const n = e & 16777215, r = (e >>> 24 | t << 8) & 16777215, a = t >> 16 & 65535;
  let o = n + r * 6777216 + a * 6710656, s = r + a * 8147497, i = a * 2;
  const u = 1e7;
  return o >= u && (s += Math.floor(o / u), o %= u), s >= u && (i += Math.floor(s / u), s %= u), i.toString() + Nw(s) + Nw(o);
}
function Y5(e, t) {
  return { lo: e >>> 0, hi: t >>> 0 };
}
function VE(e, t) {
  return { lo: e | 0, hi: t | 0 };
}
function HF(e, t) {
  return t = ~t, e ? e = ~e + 1 : t += 1, VE(e, t);
}
const Nw = (e) => {
  const t = String(e);
  return "0000000".slice(t.length) + t;
};
function hy(e, t) {
  if (e >= 0) {
    for (; e > 127; )
      t.push(e & 127 | 128), e = e >>> 7;
    t.push(e);
  } else {
    for (let n = 0; n < 9; n++)
      t.push(e & 127 | 128), e = e >> 7;
    t.push(1);
  }
}
function j5() {
  let e = this.buf[this.pos++], t = e & 127;
  if ((e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 7, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 14, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 21, (e & 128) == 0)
    return this.assertBounds(), t;
  e = this.buf[this.pos++], t |= (e & 15) << 28;
  for (let n = 5; (e & 128) !== 0 && n < 10; n++)
    e = this.buf[this.pos++];
  if ((e & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
const W = /* @__PURE__ */ B5();
function B5() {
  const e = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof e.getBigInt64 == "function" && typeof e.getBigUint64 == "function" && typeof e.setBigInt64 == "function" && typeof e.setBigUint64 == "function" && (globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const t = BigInt("-9223372036854775808"), n = BigInt("9223372036854775807"), r = BigInt("0"), a = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > n || s < t)
          throw new Error(`invalid int64: ${o}`);
        return s;
      },
      uParse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > a || s < r)
          throw new Error(`invalid uint64: ${o}`);
        return s;
      },
      enc(o) {
        return e.setBigInt64(0, this.parse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      uEnc(o) {
        return e.setBigInt64(0, this.uParse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      dec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigInt64(0, !0);
      },
      uDec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigUint64(0, !0);
      }
    };
  }
  return {
    zero: "0",
    supported: !1,
    parse(t) {
      return typeof t != "string" && (t = t.toString()), Ew(t), t;
    },
    uParse(t) {
      return typeof t != "string" && (t = t.toString()), vw(t), t;
    },
    enc(t) {
      return typeof t != "string" && (t = t.toString()), Ew(t), yw(t);
    },
    uEnc(t) {
      return typeof t != "string" && (t = t.toString()), vw(t), yw(t);
    },
    dec(t, n) {
      return x5(t, n);
    },
    uDec(t, n) {
      return ZF(t, n);
    }
  };
}
function Ew(e) {
  if (!/^-?[0-9]+$/.test(e))
    throw new Error("invalid int64: " + e);
}
function vw(e) {
  if (!/^[0-9]+$/.test(e))
    throw new Error("invalid uint64: " + e);
}
function $s(e, t) {
  switch (e) {
    case y.STRING:
      return "";
    case y.BOOL:
      return !1;
    case y.DOUBLE:
    case y.FLOAT:
      return 0;
    case y.INT64:
    case y.UINT64:
    case y.SFIXED64:
    case y.FIXED64:
    case y.SINT64:
      return t ? "0" : W.zero;
    case y.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function G5(e, t) {
  switch (e) {
    case y.BOOL:
      return t === !1;
    case y.STRING:
      return t === "";
    case y.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
const zF = 2, Da = /* @__PURE__ */ Symbol.for("reflect unsafe local");
function qF(e, t) {
  const n = e[t.localName].case;
  return n === void 0 ? n : t.fields.find((r) => r.localName === n);
}
function M5(e, t) {
  const n = t.localName;
  if (t.oneof)
    return e[t.oneof.localName].case === n;
  if (t.presence != zF)
    return e[n] !== void 0 && Object.prototype.hasOwnProperty.call(e, n);
  switch (t.fieldKind) {
    case "list":
      return e[n].length > 0;
    case "map":
      return Object.keys(e[n]).length > 0;
    case "scalar":
      return !G5(t.scalar, e[n]);
    case "enum":
      return e[n] !== t.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function sl(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) && e[t] !== void 0;
}
function QF(e, t) {
  if (t.oneof) {
    const n = e[t.oneof.localName];
    return n.case === t.localName ? n.value : void 0;
  }
  return e[t.localName];
}
function eU(e, t, n) {
  t.oneof ? e[t.oneof.localName] = {
    case: t.localName,
    value: n
  } : e[t.localName] = n;
}
function C5(e, t) {
  const n = t.localName;
  if (t.oneof) {
    const r = t.oneof.localName;
    e[r].case === n && (e[r] = { case: void 0 });
  } else if (t.presence != zF)
    delete e[n];
  else
    switch (t.fieldKind) {
      case "map":
        e[n] = {};
        break;
      case "list":
        e[n] = [];
        break;
      case "enum":
        e[n] = t.enum.values[0].number;
        break;
      case "scalar":
        e[n] = $s(t.scalar, t.longAsString);
        break;
    }
}
function No(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function xE(e, t) {
  var n, r, a, o;
  if (No(e) && Da in e && "add" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.listKind == i.listKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function YE(e, t) {
  var n, r, a, o;
  if (No(e) && Da in e && "has" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.mapKey === i.mapKey && s.mapKind == i.mapKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function jE(e, t) {
  return No(e) && Da in e && "desc" in e && No(e.desc) && e.desc.kind === "message" && (t === void 0 || e.desc.typeName == t.typeName);
}
function K5(e) {
  return tU(e.$typeName);
}
function Yc(e) {
  const t = e.fields[0];
  return tU(e.typeName) && t !== void 0 && t.fieldKind == "scalar" && t.name == "value" && t.number == 1;
}
function tU(e) {
  return e.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(e.substring(16));
}
const X5 = 999, W5 = 998, Wm = 2;
function pr(e, t) {
  if (PE(t, e))
    return t;
  const n = q5(e);
  return t !== void 0 && J5(e, n, t), n;
}
function J5(e, t, n) {
  for (const r of e.members) {
    let a = n[r.localName];
    if (a == null)
      continue;
    let o;
    if (r.kind == "oneof") {
      const s = qF(n, r);
      if (!s)
        continue;
      o = s, a = QF(n, s);
    } else
      o = r;
    switch (o.fieldKind) {
      case "message":
        a = BE(o, a);
        break;
      case "scalar":
        a = nU(o, a);
        break;
      case "list":
        a = H5(o, a);
        break;
      case "map":
        a = Z5(o, a);
        break;
    }
    eU(t, o, a);
  }
  return t;
}
function nU(e, t) {
  return e.scalar == y.BYTES ? GE(t) : t;
}
function Z5(e, t) {
  if (No(t)) {
    if (e.scalar == y.BYTES)
      return Tw(t, GE);
    if (e.mapKind == "message")
      return Tw(t, (n) => BE(e, n));
  }
  return t;
}
function H5(e, t) {
  if (Array.isArray(t)) {
    if (e.scalar == y.BYTES)
      return t.map(GE);
    if (e.listKind == "message")
      return t.map((n) => BE(e, n));
  }
  return t;
}
function BE(e, t) {
  if (e.fieldKind == "message" && !e.oneof && Yc(e.message))
    return nU(e.message.fields[0], t);
  if (No(t)) {
    if (e.message.typeName == "google.protobuf.Struct" && e.parent.typeName !== "google.protobuf.Value")
      return t;
    if (!PE(t, e.message))
      return pr(e.message, t);
  }
  return t;
}
function GE(e) {
  return Array.isArray(e) ? new Uint8Array(e) : e;
}
function Tw(e, t) {
  const n = {};
  for (const r of Object.entries(e))
    n[r[0]] = t(r[1]);
  return n;
}
const z5 = /* @__PURE__ */ Symbol(), Iw = /* @__PURE__ */ new WeakMap();
function q5(e) {
  let t;
  if (Q5(e)) {
    const n = Iw.get(e);
    let r, a;
    if (n)
      ({ prototype: r, members: a } = n);
    else {
      r = {}, a = /* @__PURE__ */ new Set();
      for (const o of e.members)
        o.kind != "oneof" && (o.fieldKind != "scalar" && o.fieldKind != "enum" || o.presence != Wm && (a.add(o), r[o.localName] = Fg(o)));
      Iw.set(e, { prototype: r, members: a });
    }
    t = Object.create(r), t.$typeName = e.typeName;
    for (const o of e.members)
      a.has(o) || o.kind == "field" && (o.fieldKind == "message" || (o.fieldKind == "scalar" || o.fieldKind == "enum") && o.presence != Wm) || (t[o.localName] = Fg(o));
  } else {
    t = {
      $typeName: e.typeName
    };
    for (const n of e.members)
      (n.kind == "oneof" || n.presence == Wm) && (t[n.localName] = Fg(n));
  }
  return t;
}
function Q5(e) {
  switch (e.file.edition) {
    case X5:
      return !1;
    case W5:
      return !0;
    default:
      return e.fields.some((t) => t.presence != Wm && t.fieldKind != "message" && !t.oneof);
  }
}
function Fg(e) {
  if (e.kind == "oneof")
    return { case: void 0 };
  if (e.fieldKind == "list")
    return [];
  if (e.fieldKind == "map")
    return {};
  if (e.fieldKind == "message")
    return z5;
  const t = e.getDefaultValue();
  return t !== void 0 ? e.fieldKind == "scalar" && e.longAsString ? t.toString() : t : e.fieldKind == "scalar" ? $s(e.scalar, e.longAsString) : e.enum.values[0].number;
}
const eX = [
  "FieldValueInvalidError",
  "FieldListRangeError",
  "ForeignFieldError"
];
class Ft extends Error {
  constructor(t, n, r = "FieldValueInvalidError") {
    super(n), this.name = r, this.field = () => t;
  }
}
function tX(e) {
  return e instanceof Error && eX.includes(e.name) && "field" in e && typeof e.field == "function";
}
const Ug = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
function ME() {
  if (globalThis[Ug] == null) {
    const e = new globalThis.TextEncoder(), t = new globalThis.TextDecoder();
    globalThis[Ug] = {
      encodeUtf8(n) {
        return e.encode(n);
      },
      decodeUtf8(n) {
        return t.decode(n);
      },
      checkUtf8(n) {
        try {
          return encodeURIComponent(n), !0;
        } catch {
          return !1;
        }
      }
    };
  }
  return globalThis[Ug];
}
var oe;
(function(e) {
  e[e.Varint = 0] = "Varint", e[e.Bit64 = 1] = "Bit64", e[e.LengthDelimited = 2] = "LengthDelimited", e[e.StartGroup = 3] = "StartGroup", e[e.EndGroup = 4] = "EndGroup", e[e.Bit32 = 5] = "Bit32";
})(oe || (oe = {}));
const rU = 34028234663852886e22, aU = -34028234663852886e22, oU = 4294967295, sU = 2147483647, iU = -2147483648;
class uU {
  constructor(t = ME().encodeUtf8) {
    this.encodeUtf8 = t, this.stack = [], this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []);
    let t = 0;
    for (let a = 0; a < this.chunks.length; a++)
      t += this.chunks[a].length;
    let n = new Uint8Array(t), r = 0;
    for (let a = 0; a < this.chunks.length; a++)
      n.set(this.chunks[a], r), r += this.chunks[a].length;
    return this.chunks = [], n;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), n = this.stack.pop();
    if (!n)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = n.chunks, this.buf = n.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, n) {
    return this.uint32((t << 3 | n) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (ww(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return Rg(t), hy(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let n = this.encodeUtf8(t);
    return this.uint32(n.byteLength), this.raw(n);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    nX(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setFloat32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let n = new Uint8Array(8);
    return new DataView(n.buffer).setFloat64(0, t, !0), this.raw(n);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    ww(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    Rg(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setInt32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return Rg(t), t = (t << 1 ^ t >> 31) >>> 0, hy(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = W.enc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = W.uEnc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let n = W.enc(t);
    return Lg(n.lo, n.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    const n = W.enc(t), r = n.hi >> 31, a = n.lo << 1 ^ r, o = (n.hi << 1 | n.lo >>> 31) ^ r;
    return Lg(a, o, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    const n = W.uEnc(t);
    return Lg(n.lo, n.hi, this.buf), this;
  }
}
class CE {
  constructor(t, n = ME().decodeUtf8) {
    this.decodeUtf8 = n, this.varint64 = V5, this.uint32 = j5, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), n = t >>> 3, r = t & 7;
    if (n <= 0 || r < 0 || r > 5)
      throw new Error("illegal tag: field no " + n + " wire type " + r);
    return [n, r];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, n) {
    let r = this.pos;
    switch (t) {
      case oe.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case oe.Bit64:
        this.pos += 4;
      case oe.Bit32:
        this.pos += 4;
        break;
      case oe.LengthDelimited:
        let a = this.uint32();
        this.pos += a;
        break;
      case oe.StartGroup:
        for (; ; ) {
          const [o, s] = this.tag();
          if (s === oe.EndGroup) {
            if (n !== void 0 && o !== n)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(s, o);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return W.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return W.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, n] = this.varint64(), r = -(t & 1);
    return t = (t >>> 1 | (n & 1) << 31) ^ r, n = n >>> 1 ^ r, W.dec(t, n);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, n] = this.varint64();
    return t !== 0 || n !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return W.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return W.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), n = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(n, n + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function Rg(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid int32: " + typeof e);
  if (!Number.isInteger(e) || e > sU || e < iU)
    throw new Error("invalid int32: " + e);
}
function ww(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid uint32: " + typeof e);
  if (!Number.isInteger(e) || e > oU || e < 0)
    throw new Error("invalid uint32: " + e);
}
function nX(e) {
  if (typeof e == "string") {
    const t = e;
    if (e = Number(e), Number.isNaN(e) && t !== "NaN")
      throw new Error("invalid float32: " + t);
  } else if (typeof e != "number")
    throw new Error("invalid float32: " + typeof e);
  if (Number.isFinite(e) && (e > rU || e < aU))
    throw new Error("invalid float32: " + e);
}
function Ao(e, t) {
  const n = e.fieldKind == "list" ? xE(t, e) : e.fieldKind == "map" ? YE(t, e) : KE(e, t);
  if (n === !0)
    return;
  let r;
  switch (e.fieldKind) {
    case "list":
      r = `expected ${fU(e)}, got ${$e(t)}`;
      break;
    case "map":
      r = `expected ${mU(e)}, got ${$e(t)}`;
      break;
    default:
      r = kd(e, t, n);
  }
  return new Ft(e, r);
}
function _w(e, t, n) {
  const r = KE(e, n);
  if (r !== !0)
    return new Ft(e, `list item #${t + 1}: ${kd(e, n, r)}`);
}
function rX(e, t, n) {
  const r = lU(t, e.mapKey);
  if (r !== !0)
    return new Ft(e, `invalid map key: ${kd({ scalar: e.mapKey }, t, r)}`);
  const a = KE(e, n);
  if (a !== !0)
    return new Ft(e, `map entry ${$e(t)}: ${kd(e, n, a)}`);
}
function KE(e, t) {
  return e.scalar !== void 0 ? lU(t, e.scalar) : e.enum !== void 0 ? e.enum.open ? Number.isInteger(t) : e.enum.values.some((n) => n.number === t) : jE(t, e.message);
}
function lU(e, t) {
  switch (t) {
    case y.DOUBLE:
      return typeof e == "number";
    case y.FLOAT:
      return typeof e != "number" ? !1 : Number.isNaN(e) || !Number.isFinite(e) ? !0 : e > rU || e < aU ? `${e.toFixed()} out of range` : !0;
    case y.INT32:
    case y.SFIXED32:
    case y.SINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > sU || e < iU ? `${e.toFixed()} out of range` : !0;
    case y.FIXED32:
    case y.UINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > oU || e < 0 ? `${e.toFixed()} out of range` : !0;
    case y.BOOL:
      return typeof e == "boolean";
    case y.STRING:
      return typeof e != "string" ? !1 : ME().checkUtf8(e) || "invalid UTF8";
    case y.BYTES:
      return e instanceof Uint8Array;
    case y.INT64:
    case y.SFIXED64:
    case y.SINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return W.parse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
    case y.FIXED64:
    case y.UINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return W.uParse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
  }
}
function kd(e, t, n) {
  return n = typeof n == "string" ? `: ${n}` : `, got ${$e(t)}`, e.scalar !== void 0 ? `expected ${aX(e.scalar)}` + n : e.enum !== void 0 ? `expected ${e.enum.toString()}` + n : `expected ${cU(e.message)}` + n;
}
function $e(e) {
  switch (typeof e) {
    case "object":
      return e === null ? "null" : e instanceof Uint8Array ? `Uint8Array(${e.length})` : Array.isArray(e) ? `Array(${e.length})` : xE(e) ? fU(e.field()) : YE(e) ? mU(e.field()) : jE(e) ? cU(e.desc) : PE(e) ? `message ${e.$typeName}` : "object";
    case "string":
      return e.length > 30 ? "string" : `"${e.split('"').join('\\"')}"`;
    case "boolean":
      return String(e);
    case "number":
      return String(e);
    case "bigint":
      return String(e) + "n";
    default:
      return typeof e;
  }
}
function cU(e) {
  return `ReflectMessage (${e.typeName})`;
}
function fU(e) {
  switch (e.listKind) {
    case "message":
      return `ReflectList (${e.message.toString()})`;
    case "enum":
      return `ReflectList (${e.enum.toString()})`;
    case "scalar":
      return `ReflectList (${y[e.scalar]})`;
  }
}
function mU(e) {
  switch (e.mapKind) {
    case "message":
      return `ReflectMap (${y[e.mapKey]}, ${e.message.toString()})`;
    case "enum":
      return `ReflectMap (${y[e.mapKey]}, ${e.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${y[e.mapKey]}, ${y[e.scalar]})`;
  }
}
function aX(e) {
  switch (e) {
    case y.STRING:
      return "string";
    case y.BOOL:
      return "boolean";
    case y.INT64:
    case y.SINT64:
    case y.SFIXED64:
      return "bigint (int64)";
    case y.UINT64:
    case y.FIXED64:
      return "bigint (uint64)";
    case y.BYTES:
      return "Uint8Array";
    case y.DOUBLE:
      return "number (float64)";
    case y.FLOAT:
      return "number (float32)";
    case y.FIXED32:
    case y.UINT32:
      return "number (uint32)";
    case y.INT32:
    case y.SFIXED32:
    case y.SINT32:
      return "number (int32)";
  }
}
function Wn(e, t, n = !0) {
  return new dU(e, t, n);
}
const Ow = /* @__PURE__ */ new WeakMap();
class dU {
  get sortedFields() {
    const t = Ow.get(this.desc);
    if (t)
      return t;
    const n = this.desc.fields.concat().sort((r, a) => r.number - a.number);
    return Ow.set(this.desc, n), n;
  }
  constructor(t, n, r = !0) {
    this.lists = /* @__PURE__ */ new Map(), this.maps = /* @__PURE__ */ new Map(), this.check = r, this.desc = t, this.message = this[Da] = n ?? pr(t), this.fields = t.fields, this.oneofs = t.oneofs, this.members = t.members;
  }
  findNumber(t) {
    return this._fieldsByNumber || (this._fieldsByNumber = new Map(this.desc.fields.map((n) => [n.number, n]))), this._fieldsByNumber.get(t);
  }
  oneofCase(t) {
    return Lu(this.message, t), qF(this.message, t);
  }
  isSet(t) {
    return Lu(this.message, t), M5(this.message, t);
  }
  clear(t) {
    Lu(this.message, t), C5(this.message, t);
  }
  get(t) {
    Lu(this.message, t);
    const n = QF(this.message, t);
    switch (t.fieldKind) {
      case "list":
        let r = this.lists.get(t);
        return (!r || r[Da] !== n) && this.lists.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          r = new oX(t, n, this.check)
        ), r;
      case "map":
        let a = this.maps.get(t);
        return (!a || a[Da] !== n) && this.maps.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = new sX(t, n, this.check)
        ), a;
      case "message":
        return WE(t, n, this.check);
      case "scalar":
        return n === void 0 ? $s(t.scalar, !1) : JE(t, n);
      case "enum":
        return n ?? t.enum.values[0].number;
    }
  }
  set(t, n) {
    if (Lu(this.message, t), this.check) {
      const a = Ao(t, n);
      if (a)
        throw a;
    }
    let r;
    t.fieldKind == "message" ? r = XE(t, n) : YE(n) || xE(n) ? r = n[Da] : r = ZE(t, n), eU(this.message, t, r);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(t) {
    this.message.$unknown = t;
  }
}
function Lu(e, t) {
  if (t.parent.typeName !== e.$typeName)
    throw new Ft(t, `cannot use ${t.toString()} with message ${e.$typeName}`, "ForeignFieldError");
}
class oX {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(t, n, r) {
    this._field = t, this._arr = this[Da] = n, this.check = r;
  }
  get(t) {
    const n = this._arr[t];
    return n === void 0 ? void 0 : $g(this._field, n, this.check);
  }
  set(t, n) {
    if (t < 0 || t >= this._arr.length)
      throw new Ft(this._field, `list item #${t + 1}: out of range`);
    if (this.check) {
      const r = _w(this._field, t, n);
      if (r)
        throw r;
    }
    this._arr[t] = Sw(this._field, n);
  }
  add(t) {
    if (this.check) {
      const n = _w(this._field, this._arr.length, t);
      if (n)
        throw n;
    }
    this._arr.push(Sw(this._field, t));
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const t of this._arr)
      yield $g(this._field, t, this.check);
  }
  *entries() {
    for (let t = 0; t < this._arr.length; t++)
      yield [t, $g(this._field, this._arr[t], this.check)];
  }
}
class sX {
  constructor(t, n, r = !0) {
    this.obj = this[Da] = n ?? {}, this.check = r, this._field = t;
  }
  field() {
    return this._field;
  }
  set(t, n) {
    if (this.check) {
      const r = rX(this._field, t, n);
      if (r)
        throw r;
    }
    return this.obj[Qf(t)] = iX(this._field, n), this;
  }
  delete(t) {
    const n = Qf(t), r = Object.prototype.hasOwnProperty.call(this.obj, n);
    return r && delete this.obj[n], r;
  }
  clear() {
    for (const t of Object.keys(this.obj))
      delete this.obj[t];
  }
  get(t) {
    let n = this.obj[Qf(t)];
    return n !== void 0 && (n = Pg(this._field, n, this.check)), n;
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.obj, Qf(t));
  }
  *keys() {
    for (const t of Object.keys(this.obj))
      yield Dw(t, this._field.mapKey);
  }
  *entries() {
    for (const t of Object.entries(this.obj))
      yield [
        Dw(t[0], this._field.mapKey),
        Pg(this._field, t[1], this.check)
      ];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const t of Object.values(this.obj))
      yield Pg(this._field, t, this.check);
  }
  forEach(t, n) {
    for (const r of this.entries())
      t.call(n, r[1], r[0], this);
  }
}
function XE(e, t) {
  return jE(t) ? K5(t.message) && !e.oneof && e.fieldKind == "message" ? t.message.value : t.desc.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" ? bU(t.message) : t.message : t;
}
function WE(e, t, n) {
  return t !== void 0 && (Yc(e.message) && !e.oneof && e.fieldKind == "message" ? t = {
    $typeName: e.message.typeName,
    value: JE(e.message.fields[0], t)
  } : e.message.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" && No(t) && (t = pU(t))), new dU(e.message, t, n);
}
function Sw(e, t) {
  return e.listKind == "message" ? XE(e, t) : ZE(e, t);
}
function $g(e, t, n) {
  return e.listKind == "message" ? WE(e, t, n) : JE(e, t);
}
function iX(e, t) {
  return e.mapKind == "message" ? XE(e, t) : ZE(e, t);
}
function Pg(e, t, n) {
  return e.mapKind == "message" ? WE(e, t, n) : t;
}
function Qf(e) {
  return typeof e == "string" || typeof e == "number" ? e : String(e);
}
function Dw(e, t) {
  switch (t) {
    case y.STRING:
      return e;
    case y.INT32:
    case y.FIXED32:
    case y.UINT32:
    case y.SFIXED32:
    case y.SINT32: {
      const n = Number.parseInt(e);
      if (Number.isFinite(n))
        return n;
      break;
    }
    case y.BOOL:
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      break;
    case y.UINT64:
    case y.FIXED64:
      try {
        return W.uParse(e);
      } catch {
      }
      break;
    default:
      try {
        return W.parse(e);
      } catch {
      }
      break;
  }
  return e;
}
function JE(e, t) {
  switch (e.scalar) {
    case y.INT64:
    case y.SFIXED64:
    case y.SINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = W.parse(t));
      break;
    case y.FIXED64:
    case y.UINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = W.uParse(t));
      break;
  }
  return t;
}
function ZE(e, t) {
  switch (e.scalar) {
    case y.INT64:
    case y.SFIXED64:
    case y.SINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = W.parse(t));
      break;
    case y.FIXED64:
    case y.UINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = W.uParse(t));
      break;
  }
  return t;
}
function pU(e) {
  const t = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (No(e))
    for (const [n, r] of Object.entries(e))
      t.fields[n] = hU(r);
  return t;
}
function bU(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = gU(r);
  return t;
}
function gU(e) {
  switch (e.kind.case) {
    case "structValue":
      return bU(e.kind.value);
    case "listValue":
      return e.kind.value.values.map(gU);
    case "nullValue":
    case void 0:
      return null;
    default:
      return e.kind.value;
  }
}
function hU(e) {
  const t = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof e) {
    case "number":
      t.kind = { case: "numberValue", value: e };
      break;
    case "string":
      t.kind = { case: "stringValue", value: e };
      break;
    case "boolean":
      t.kind = { case: "boolValue", value: e };
      break;
    case "object":
      if (e === null)
        t.kind = { case: "nullValue", value: 0 };
      else if (Array.isArray(e)) {
        const n = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(e))
          for (const r of e)
            n.values.push(hU(r));
        t.kind = {
          case: "listValue",
          value: n
        };
      } else
        t.kind = {
          case: "structValue",
          value: pU(e)
        };
      break;
  }
  return t;
}
function HE(e) {
  const t = uX();
  let n = e.length * 3 / 4;
  e[e.length - 2] == "=" ? n -= 2 : e[e.length - 1] == "=" && (n -= 1);
  let r = new Uint8Array(n), a = 0, o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++) {
    if (s = t[e.charCodeAt(u)], s === void 0)
      switch (e[u]) {
        // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
        case "=":
          o = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string");
      }
    switch (o) {
      case 0:
        i = s, o = 1;
        break;
      case 1:
        r[a++] = i << 2 | (s & 48) >> 4, i = s, o = 2;
        break;
      case 2:
        r[a++] = (i & 15) << 4 | (s & 60) >> 2, i = s, o = 3;
        break;
      case 3:
        r[a++] = (i & 3) << 6 | s, o = 0;
        break;
    }
  }
  if (o == 1)
    throw Error("invalid base64 string");
  return r.subarray(0, a);
}
function yU(e, t = "std") {
  const n = NU(t), r = t == "std";
  let a = "", o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++)
    switch (s = e[u], o) {
      case 0:
        a += n[s >> 2], i = (s & 3) << 4, o = 1;
        break;
      case 1:
        a += n[i | s >> 4], i = (s & 15) << 2, o = 2;
        break;
      case 2:
        a += n[i | s >> 6], a += n[s & 63], o = 0;
        break;
    }
  return o && (a += n[i], r && (a += "=", o == 1 && (a += "="))), a;
}
let em, kw, ti;
function NU(e) {
  return em || (em = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), kw = em.slice(0, -2).concat("-", "_")), e == "url" ? (
    // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
    kw
  ) : em;
}
function uX() {
  if (!ti) {
    ti = [];
    const e = NU("std");
    for (let t = 0; t < e.length; t++)
      ti[e[t].charCodeAt(0)] = t;
    ti[45] = e.indexOf("+"), ti[95] = e.indexOf("/");
  }
  return ti;
}
function il(e) {
  let t = !1;
  const n = [];
  for (let r = 0; r < e.length; r++) {
    let a = e.charAt(r);
    switch (a) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        n.push(a), t = !1;
        break;
      default:
        t && (t = !1, a = a.toUpperCase()), n.push(a);
        break;
    }
  }
  return n.join("");
}
const lX = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function ul(e) {
  return lX.has(e) ? e + "$" : e;
}
function zE(e) {
  for (const t of e.field)
    sl(t, "jsonName") || (t.jsonName = il(t.name));
  e.nestedType.forEach(zE);
}
function cX(e, t) {
  const n = e.values.find((r) => r.name === t);
  if (!n)
    throw new Error(`cannot parse ${e} default value: ${t}`);
  return n.number;
}
function fX(e, t) {
  switch (e) {
    case y.STRING:
      return t;
    case y.BYTES: {
      const n = mX(t);
      if (n === !1)
        throw new Error(`cannot parse ${y[e]} default value: ${t}`);
      return n;
    }
    case y.INT64:
    case y.SFIXED64:
    case y.SINT64:
      return W.parse(t);
    case y.UINT64:
    case y.FIXED64:
      return W.uParse(t);
    case y.DOUBLE:
    case y.FLOAT:
      switch (t) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(t);
      }
    case y.BOOL:
      return t === "true";
    case y.INT32:
    case y.UINT32:
    case y.SINT32:
    case y.FIXED32:
    case y.SFIXED32:
      return parseInt(t, 10);
  }
}
function mX(e) {
  const t = [], n = {
    tail: e,
    c: "",
    next() {
      return this.tail.length == 0 ? !1 : (this.c = this.tail[0], this.tail = this.tail.substring(1), !0);
    },
    take(r) {
      if (this.tail.length >= r) {
        const a = this.tail.substring(0, r);
        return this.tail = this.tail.substring(r), a;
      }
      return !1;
    }
  };
  for (; n.next(); )
    switch (n.c) {
      case "\\":
        if (n.next())
          switch (n.c) {
            case "\\":
              t.push(n.c.charCodeAt(0));
              break;
            case "b":
              t.push(8);
              break;
            case "f":
              t.push(12);
              break;
            case "n":
              t.push(10);
              break;
            case "r":
              t.push(13);
              break;
            case "t":
              t.push(9);
              break;
            case "v":
              t.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 8);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "x": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "u": {
              const r = n.c, a = n.take(4);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              const s = new Uint8Array(4);
              new DataView(s.buffer).setInt32(0, o, !0), t.push(s[0], s[1], s[2], s[3]);
              break;
            }
            case "U": {
              const r = n.c, a = n.take(8);
              if (a === !1)
                return !1;
              const o = W.uEnc(r + a), s = new Uint8Array(8), i = new DataView(s.buffer);
              i.setInt32(0, o.lo, !0), i.setInt32(4, o.hi, !0), t.push(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
              break;
            }
          }
        break;
      default:
        t.push(n.c.charCodeAt(0));
    }
  return new Uint8Array(t);
}
function* yy(e) {
  switch (e.kind) {
    case "file":
      for (const t of e.messages)
        yield t, yield* yy(t);
      yield* e.enums, yield* e.services, yield* e.extensions;
      break;
    case "message":
      for (const t of e.nestedMessages)
        yield t, yield* yy(t);
      yield* e.nestedEnums, yield* e.nestedExtensions;
      break;
  }
}
function EU(...e) {
  const t = dX();
  if (!e.length)
    return t;
  if ("$typeName" in e[0] && e[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const n of e[0].file)
      Rw(n, t);
    return t;
  }
  if ("$typeName" in e[0]) {
    let n = function(s) {
      const i = [];
      for (const u of s.dependency) {
        if (t.getFile(u) != null || o.has(u))
          continue;
        const l = a(u);
        if (!l)
          throw new Error(`Unable to resolve ${u}, imported by ${s.name}`);
        "kind" in l ? t.addFile(l, !1, !0) : (o.add(l.name), i.push(l));
      }
      return i.concat(...i.map(n));
    };
    const r = e[0], a = e[1], o = /* @__PURE__ */ new Set();
    for (const s of [r, ...n(r)].reverse())
      Rw(s, t);
  } else
    for (const n of e)
      for (const r of n.files)
        t.addFile(r);
  return t;
}
function dX() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    kind: "registry",
    types: e,
    extendees: t,
    [Symbol.iterator]() {
      return e.values();
    },
    get files() {
      return n.values();
    },
    addFile(r, a, o) {
      if (n.set(r.proto.name, r), !a)
        for (const s of yy(r))
          this.add(s);
      if (o)
        for (const s of r.dependencies)
          this.addFile(s, a, o);
    },
    add(r) {
      if (r.kind == "extension") {
        let a = t.get(r.extendee.typeName);
        a || t.set(
          r.extendee.typeName,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = /* @__PURE__ */ new Map()
        ), a.set(r.number, r);
      }
      e.set(r.typeName, r);
    },
    get(r) {
      return e.get(r);
    },
    getFile(r) {
      return n.get(r);
    },
    getMessage(r) {
      const a = e.get(r);
      return a?.kind == "message" ? a : void 0;
    },
    getEnum(r) {
      const a = e.get(r);
      return a?.kind == "enum" ? a : void 0;
    },
    getExtension(r) {
      const a = e.get(r);
      return a?.kind == "extension" ? a : void 0;
    },
    getExtensionFor(r, a) {
      var o;
      return (o = t.get(r.typeName)) === null || o === void 0 ? void 0 : o.get(a);
    },
    getService(r) {
      const a = e.get(r);
      return a?.kind == "service" ? a : void 0;
    }
  };
}
const pX = 998, bX = 999, gX = 9, ll = 10, Gu = 11, hX = 12, Aw = 14, qE = 3, yX = 2, Lw = 1, NX = 0, Fw = 1, Uw = 2, EX = 3, vX = 1, TX = 2, IX = 1, vU = {
  // EDITION_PROTO2
  998: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 2,
    // CLOSED,
    repeatedFieldEncoding: 2,
    // EXPANDED,
    utf8Validation: 3,
    // NONE,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 2,
    // LEGACY_BEST_EFFORT,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_PROTO3
  999: {
    fieldPresence: 2,
    // IMPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2023
  1e3: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2024
  1001: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 1,
    // STYLE2024,
    defaultSymbolVisibility: 2
    // EXPORT_TOP_LEVEL,
  }
};
function Rw(e, t) {
  var n, r;
  const a = {
    kind: "file",
    proto: e,
    deprecated: (r = (n = e.options) === null || n === void 0 ? void 0 : n.deprecated) !== null && r !== void 0 ? r : !1,
    edition: SX(e),
    name: e.name.replace(/\.proto$/, ""),
    dependencies: DX(e, t),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${e.name}`;
    }
  }, o = /* @__PURE__ */ new Map(), s = {
    get(i) {
      return o.get(i);
    },
    add(i) {
      var u;
      rr(((u = i.proto.options) === null || u === void 0 ? void 0 : u.mapEntry) === !0), o.set(i.typeName, i);
    }
  };
  for (const i of e.enumType)
    TU(i, a, void 0, t);
  for (const i of e.messageType)
    IU(i, a, void 0, t, s);
  for (const i of e.service)
    wX(i, a, t);
  Ny(a, t);
  for (const i of o.values())
    Ey(i, t, s);
  for (const i of a.messages)
    Ey(i, t, s), Ny(i, t);
  t.addFile(a, !0);
}
function Ny(e, t) {
  switch (e.kind) {
    case "file":
      for (const n of e.proto.extension) {
        const r = vy(n, e, t);
        e.extensions.push(r), t.add(r);
      }
      break;
    case "message":
      for (const n of e.proto.extension) {
        const r = vy(n, e, t);
        e.nestedExtensions.push(r), t.add(r);
      }
      for (const n of e.nestedMessages)
        Ny(n, t);
      break;
  }
}
function Ey(e, t, n) {
  const r = e.proto.oneofDecl.map((o) => OX(o, e)), a = /* @__PURE__ */ new Set();
  for (const o of e.proto.field) {
    const s = LX(o, r), i = vy(o, e, t, s, n);
    e.fields.push(i), e.field[i.localName] = i, s === void 0 ? e.members.push(i) : (s.fields.push(i), a.has(s) || (a.add(s), e.members.push(s)));
  }
  for (const o of r.filter((s) => a.has(s)))
    e.oneofs.push(o);
  for (const o of e.nestedMessages)
    Ey(o, t, n);
}
function TU(e, t, n, r) {
  var a, o, s, i, u;
  const l = kX(e.name, e.value), c = {
    kind: "enum",
    proto: e,
    deprecated: (o = (a = e.options) === null || a === void 0 ? void 0 : a.deprecated) !== null && o !== void 0 ? o : !1,
    file: t,
    parent: n,
    open: !0,
    name: e.name,
    typeName: fb(e, n, t),
    value: {},
    values: [],
    sharedPrefix: l,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  c.open = $X(c), r.add(c);
  for (const f of e.value) {
    const d = f.name;
    c.values.push(
      // biome-ignore lint/suspicious/noAssignInExpressions: no
      c.value[f.number] = {
        kind: "enum_value",
        proto: f,
        deprecated: (i = (s = f.options) === null || s === void 0 ? void 0 : s.deprecated) !== null && i !== void 0 ? i : !1,
        parent: c,
        name: d,
        localName: ul(l == null ? d : d.substring(l.length)),
        number: f.number,
        toString() {
          return `enum value ${c.typeName}.${d}`;
        }
      }
    );
  }
  ((u = n?.nestedEnums) !== null && u !== void 0 ? u : t.enums).push(c);
}
function IU(e, t, n, r, a) {
  var o, s, i, u;
  const l = {
    kind: "message",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    file: t,
    parent: n,
    name: e.name,
    typeName: fb(e, n, t),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  ((i = e.options) === null || i === void 0 ? void 0 : i.mapEntry) === !0 ? a.add(l) : (((u = n?.nestedMessages) !== null && u !== void 0 ? u : t.messages).push(l), r.add(l));
  for (const c of e.enumType)
    TU(c, t, l, r);
  for (const c of e.nestedType)
    IU(c, t, l, r, a);
}
function wX(e, t, n) {
  var r, a;
  const o = {
    kind: "service",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    file: t,
    name: e.name,
    typeName: fb(e, void 0, t),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  t.services.push(o), n.add(o);
  for (const s of e.method) {
    const i = _X(s, o, n);
    o.methods.push(i), o.method[i.localName] = i;
  }
}
function _X(e, t, n) {
  var r, a, o, s;
  let i;
  e.clientStreaming && e.serverStreaming ? i = "bidi_streaming" : e.clientStreaming ? i = "client_streaming" : e.serverStreaming ? i = "server_streaming" : i = "unary";
  const u = n.getMessage(la(e.inputType)), l = n.getMessage(la(e.outputType));
  rr(u, `invalid MethodDescriptorProto: input_type ${e.inputType} not found`), rr(l, `invalid MethodDescriptorProto: output_type ${e.inputType} not found`);
  const c = e.name;
  return {
    kind: "rpc",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    parent: t,
    name: c,
    localName: ul(c.length ? ul(c[0].toLowerCase() + c.substring(1)) : c),
    methodKind: i,
    input: u,
    output: l,
    idempotency: (s = (o = e.options) === null || o === void 0 ? void 0 : o.idempotencyLevel) !== null && s !== void 0 ? s : NX,
    toString() {
      return `rpc ${t.typeName}.${c}`;
    }
  };
}
function OX(e, t) {
  return {
    kind: "oneof",
    proto: e,
    deprecated: !1,
    parent: t,
    fields: [],
    name: e.name,
    localName: ul(il(e.name)),
    toString() {
      return `oneof ${t.typeName}.${this.name}`;
    }
  };
}
function vy(e, t, n, r, a) {
  var o, s, i;
  const u = a === void 0, l = {
    kind: "field",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    name: e.name,
    number: e.number,
    scalar: void 0,
    message: void 0,
    enum: void 0,
    presence: FX(e, r, u, t),
    listKind: void 0,
    mapKind: void 0,
    mapKey: void 0,
    delimitedEncoding: void 0,
    packed: void 0,
    longAsString: !1,
    getDefaultValue: void 0
  };
  if (u) {
    const m = t.kind == "file" ? t : t.file, p = t.kind == "file" ? void 0 : t, b = fb(e, p, m);
    l.kind = "extension", l.file = m, l.parent = p, l.oneof = void 0, l.typeName = b, l.jsonName = `[${b}]`, l.toString = () => `extension ${b}`;
    const g = n.getMessage(la(e.extendee));
    rr(g, `invalid FieldDescriptorProto: extendee ${e.extendee} not found`), l.extendee = g;
  } else {
    const m = t;
    rr(m.kind == "message"), l.parent = m, l.oneof = r, l.localName = r ? il(e.name) : ul(il(e.name)), l.jsonName = e.jsonName, l.toString = () => `field ${m.typeName}.${e.name}`;
  }
  const c = e.label, f = e.type, d = (i = e.options) === null || i === void 0 ? void 0 : i.jstype;
  if (c === qE) {
    const m = f == Gu ? a?.get(la(e.typeName)) : void 0;
    if (m) {
      l.fieldKind = "map";
      const { key: p, value: b } = RX(m);
      return l.mapKey = p.scalar, l.mapKind = b.fieldKind, l.message = b.message, l.delimitedEncoding = !1, l.enum = b.enum, l.scalar = b.scalar, l;
    }
    switch (l.fieldKind = "list", f) {
      case Gu:
      case ll:
        l.listKind = "message", l.message = n.getMessage(la(e.typeName)), rr(l.message), l.delimitedEncoding = $w(e, t);
        break;
      case Aw:
        l.listKind = "enum", l.enum = n.getEnum(la(e.typeName)), rr(l.enum);
        break;
      default:
        l.listKind = "scalar", l.scalar = f, l.longAsString = d == Lw;
        break;
    }
    return l.packed = UX(e, t), l;
  }
  switch (f) {
    case Gu:
    case ll:
      l.fieldKind = "message", l.message = n.getMessage(la(e.typeName)), rr(l.message, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.delimitedEncoding = $w(e, t), l.getDefaultValue = () => {
      };
      break;
    case Aw: {
      const m = n.getEnum(la(e.typeName));
      rr(m !== void 0, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.fieldKind = "enum", l.enum = n.getEnum(la(e.typeName)), l.getDefaultValue = () => sl(e, "defaultValue") ? cX(m, e.defaultValue) : void 0;
      break;
    }
    default: {
      l.fieldKind = "scalar", l.scalar = f, l.longAsString = d == Lw, l.getDefaultValue = () => sl(e, "defaultValue") ? fX(f, e.defaultValue) : void 0;
      break;
    }
  }
  return l;
}
function SX(e) {
  switch (e.syntax) {
    case "":
    case "proto2":
      return pX;
    case "proto3":
      return bX;
    case "editions":
      if (e.edition in vU)
        return e.edition;
      throw new Error(`${e.name}: unsupported edition`);
    default:
      throw new Error(`${e.name}: unsupported syntax "${e.syntax}"`);
  }
}
function DX(e, t) {
  return e.dependency.map((n) => {
    const r = t.getFile(n);
    if (!r)
      throw new Error(`Cannot find ${n}, imported by ${e.name}`);
    return r;
  });
}
function kX(e, t) {
  const n = AX(e) + "_";
  for (const r of t) {
    if (!r.name.toLowerCase().startsWith(n))
      return;
    const a = r.name.substring(n.length);
    if (a.length == 0 || /^\d/.test(a))
      return;
  }
  return n;
}
function AX(e) {
  return (e.substring(0, 1) + e.substring(1).replace(/[A-Z]/g, (t) => "_" + t)).toLowerCase();
}
function fb(e, t, n) {
  let r;
  return t ? r = `${t.typeName}.${e.name}` : n.proto.package.length > 0 ? r = `${n.proto.package}.${e.name}` : r = `${e.name}`, r;
}
function la(e) {
  return e.startsWith(".") ? e.substring(1) : e;
}
function LX(e, t) {
  if (!sl(e, "oneofIndex") || e.proto3Optional)
    return;
  const n = t[e.oneofIndex];
  return rr(n, `invalid FieldDescriptorProto: oneof #${e.oneofIndex} for field #${e.number} not found`), n;
}
function FX(e, t, n, r) {
  if (e.label == yX)
    return EX;
  if (e.label == qE)
    return Uw;
  if (t || e.proto3Optional || n)
    return Fw;
  const a = xi("fieldPresence", { proto: e, parent: r });
  return a == Uw && (e.type == Gu || e.type == ll) ? Fw : a;
}
function UX(e, t) {
  if (e.label != qE)
    return !1;
  switch (e.type) {
    case gX:
    case hX:
    case ll:
    case Gu:
      return !1;
  }
  const n = e.options;
  return n && sl(n, "packed") ? n.packed : vX == xi("repeatedFieldEncoding", {
    proto: e,
    parent: t
  });
}
function RX(e) {
  const t = e.fields.find((r) => r.number === 1), n = e.fields.find((r) => r.number === 2);
  return rr(t && t.fieldKind == "scalar" && t.scalar != y.BYTES && t.scalar != y.FLOAT && t.scalar != y.DOUBLE && n && n.fieldKind != "list" && n.fieldKind != "map"), { key: t, value: n };
}
function $X(e) {
  var t;
  return IX == xi("enumType", {
    proto: e.proto,
    parent: (t = e.parent) !== null && t !== void 0 ? t : e.file
  });
}
function $w(e, t) {
  return e.type == ll ? !0 : TX == xi("messageEncoding", {
    proto: e,
    parent: t
  });
}
function xi(e, t) {
  var n, r;
  const a = (n = t.proto.options) === null || n === void 0 ? void 0 : n.features;
  if (a) {
    const o = a[e];
    if (o != 0)
      return o;
  }
  if ("kind" in t) {
    if (t.kind == "message")
      return xi(e, (r = t.parent) !== null && r !== void 0 ? r : t.file);
    const o = vU[t.edition];
    if (!o)
      throw new Error(`feature default for edition ${t.edition} not found`);
    return o[e];
  }
  return xi(e, t.parent);
}
function rr(e, t) {
  if (!e)
    throw new Error(t);
}
function PX(e) {
  const t = VX(e);
  return t.messageType.forEach(zE), EU(t, () => {
  }).getFile(t.name);
}
function VX(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    syntax: "",
    edition: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, e), { messageType: e.messageType.map(wU), enumType: e.enumType.map(_U) }));
}
function wU(e) {
  var t, n, r, a, o, s, i, u;
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.DescriptorProto",
    name: e.name,
    field: (n = (t = e.field) === null || t === void 0 ? void 0 : t.map(xX)) !== null && n !== void 0 ? n : [],
    extension: [],
    nestedType: (a = (r = e.nestedType) === null || r === void 0 ? void 0 : r.map(wU)) !== null && a !== void 0 ? a : [],
    enumType: (s = (o = e.enumType) === null || o === void 0 ? void 0 : o.map(_U)) !== null && s !== void 0 ? s : [],
    extensionRange: (u = (i = e.extensionRange) === null || i === void 0 ? void 0 : i.map((l) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, l))) !== null && u !== void 0 ? u : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function xX(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: !1
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, e), { options: e.options ? YX(e.options) : void 0 }));
}
function YX(e) {
  var t, n, r;
  return Object.assign(/* @__PURE__ */ Object.create({
    ctype: 0,
    packed: !1,
    jstype: 0,
    lazy: !1,
    unverifiedLazy: !1,
    deprecated: !1,
    weak: !1,
    debugRedact: !1,
    retention: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, e), { targets: (t = e.targets) !== null && t !== void 0 ? t : [], editionDefaults: (r = (n = e.editionDefaults) === null || n === void 0 ? void 0 : n.map((a) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, a))) !== null && r !== void 0 ? r : [], uninterpretedOption: [] }));
}
function _U(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: e.name,
    reservedName: [],
    reservedRange: [],
    value: e.value.map((t) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, t))
  });
}
function jc(e, t, ...n) {
  return n.reduce((r, a) => r.nestedMessages[a], e.messages[t]);
}
const jX = /* @__PURE__ */ PX({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: !0 } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false", options: { deprecated: !0 } }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1e3 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1e3, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: !0 } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1e3 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_UNSTABLE", number: 9999 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] }), BX = /* @__PURE__ */ jc(jX, 1);
var Pw;
(function(e) {
  e[e.DECLARATION = 0] = "DECLARATION", e[e.UNVERIFIED = 1] = "UNVERIFIED";
})(Pw || (Pw = {}));
var Vw;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.GROUP = 10] = "GROUP", e[e.MESSAGE = 11] = "MESSAGE", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.ENUM = 14] = "ENUM", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(Vw || (Vw = {}));
var xw;
(function(e) {
  e[e.OPTIONAL = 1] = "OPTIONAL", e[e.REPEATED = 3] = "REPEATED", e[e.REQUIRED = 2] = "REQUIRED";
})(xw || (xw = {}));
var Yw;
(function(e) {
  e[e.SPEED = 1] = "SPEED", e[e.CODE_SIZE = 2] = "CODE_SIZE", e[e.LITE_RUNTIME = 3] = "LITE_RUNTIME";
})(Yw || (Yw = {}));
var jw;
(function(e) {
  e[e.STRING = 0] = "STRING", e[e.CORD = 1] = "CORD", e[e.STRING_PIECE = 2] = "STRING_PIECE";
})(jw || (jw = {}));
var Bw;
(function(e) {
  e[e.JS_NORMAL = 0] = "JS_NORMAL", e[e.JS_STRING = 1] = "JS_STRING", e[e.JS_NUMBER = 2] = "JS_NUMBER";
})(Bw || (Bw = {}));
var Gw;
(function(e) {
  e[e.RETENTION_UNKNOWN = 0] = "RETENTION_UNKNOWN", e[e.RETENTION_RUNTIME = 1] = "RETENTION_RUNTIME", e[e.RETENTION_SOURCE = 2] = "RETENTION_SOURCE";
})(Gw || (Gw = {}));
var Mw;
(function(e) {
  e[e.TARGET_TYPE_UNKNOWN = 0] = "TARGET_TYPE_UNKNOWN", e[e.TARGET_TYPE_FILE = 1] = "TARGET_TYPE_FILE", e[e.TARGET_TYPE_EXTENSION_RANGE = 2] = "TARGET_TYPE_EXTENSION_RANGE", e[e.TARGET_TYPE_MESSAGE = 3] = "TARGET_TYPE_MESSAGE", e[e.TARGET_TYPE_FIELD = 4] = "TARGET_TYPE_FIELD", e[e.TARGET_TYPE_ONEOF = 5] = "TARGET_TYPE_ONEOF", e[e.TARGET_TYPE_ENUM = 6] = "TARGET_TYPE_ENUM", e[e.TARGET_TYPE_ENUM_ENTRY = 7] = "TARGET_TYPE_ENUM_ENTRY", e[e.TARGET_TYPE_SERVICE = 8] = "TARGET_TYPE_SERVICE", e[e.TARGET_TYPE_METHOD = 9] = "TARGET_TYPE_METHOD";
})(Mw || (Mw = {}));
var Ty;
(function(e) {
  e[e.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e[e.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e[e.IDEMPOTENT = 2] = "IDEMPOTENT";
})(Ty || (Ty = {}));
var Cw;
(function(e) {
  e[e.DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", e[e.EXPORT_ALL = 1] = "EXPORT_ALL", e[e.EXPORT_TOP_LEVEL = 2] = "EXPORT_TOP_LEVEL", e[e.LOCAL_ALL = 3] = "LOCAL_ALL", e[e.STRICT = 4] = "STRICT";
})(Cw || (Cw = {}));
var Kw;
(function(e) {
  e[e.FIELD_PRESENCE_UNKNOWN = 0] = "FIELD_PRESENCE_UNKNOWN", e[e.EXPLICIT = 1] = "EXPLICIT", e[e.IMPLICIT = 2] = "IMPLICIT", e[e.LEGACY_REQUIRED = 3] = "LEGACY_REQUIRED";
})(Kw || (Kw = {}));
var Xw;
(function(e) {
  e[e.ENUM_TYPE_UNKNOWN = 0] = "ENUM_TYPE_UNKNOWN", e[e.OPEN = 1] = "OPEN", e[e.CLOSED = 2] = "CLOSED";
})(Xw || (Xw = {}));
var Ww;
(function(e) {
  e[e.REPEATED_FIELD_ENCODING_UNKNOWN = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN", e[e.PACKED = 1] = "PACKED", e[e.EXPANDED = 2] = "EXPANDED";
})(Ww || (Ww = {}));
var Jw;
(function(e) {
  e[e.UTF8_VALIDATION_UNKNOWN = 0] = "UTF8_VALIDATION_UNKNOWN", e[e.VERIFY = 2] = "VERIFY", e[e.NONE = 3] = "NONE";
})(Jw || (Jw = {}));
var Zw;
(function(e) {
  e[e.MESSAGE_ENCODING_UNKNOWN = 0] = "MESSAGE_ENCODING_UNKNOWN", e[e.LENGTH_PREFIXED = 1] = "LENGTH_PREFIXED", e[e.DELIMITED = 2] = "DELIMITED";
})(Zw || (Zw = {}));
var Hw;
(function(e) {
  e[e.JSON_FORMAT_UNKNOWN = 0] = "JSON_FORMAT_UNKNOWN", e[e.ALLOW = 1] = "ALLOW", e[e.LEGACY_BEST_EFFORT = 2] = "LEGACY_BEST_EFFORT";
})(Hw || (Hw = {}));
var zw;
(function(e) {
  e[e.ENFORCE_NAMING_STYLE_UNKNOWN = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN", e[e.STYLE2024 = 1] = "STYLE2024", e[e.STYLE_LEGACY = 2] = "STYLE_LEGACY";
})(zw || (zw = {}));
var qw;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SET = 1] = "SET", e[e.ALIAS = 2] = "ALIAS";
})(qw || (qw = {}));
var Qw;
(function(e) {
  e[e.EDITION_UNKNOWN = 0] = "EDITION_UNKNOWN", e[e.EDITION_LEGACY = 900] = "EDITION_LEGACY", e[e.EDITION_PROTO2 = 998] = "EDITION_PROTO2", e[e.EDITION_PROTO3 = 999] = "EDITION_PROTO3", e[e.EDITION_2023 = 1e3] = "EDITION_2023", e[e.EDITION_2024 = 1001] = "EDITION_2024", e[e.EDITION_UNSTABLE = 9999] = "EDITION_UNSTABLE", e[e.EDITION_1_TEST_ONLY = 1] = "EDITION_1_TEST_ONLY", e[e.EDITION_2_TEST_ONLY = 2] = "EDITION_2_TEST_ONLY", e[e.EDITION_99997_TEST_ONLY = 99997] = "EDITION_99997_TEST_ONLY", e[e.EDITION_99998_TEST_ONLY = 99998] = "EDITION_99998_TEST_ONLY", e[e.EDITION_99999_TEST_ONLY = 99999] = "EDITION_99999_TEST_ONLY", e[e.EDITION_MAX = 2147483647] = "EDITION_MAX";
})(Qw || (Qw = {}));
var e_;
(function(e) {
  e[e.VISIBILITY_UNSET = 0] = "VISIBILITY_UNSET", e[e.VISIBILITY_LOCAL = 1] = "VISIBILITY_LOCAL", e[e.VISIBILITY_EXPORT = 2] = "VISIBILITY_EXPORT";
})(e_ || (e_ = {}));
const t_ = {
  readUnknownFields: !0
};
function GX(e) {
  return e ? Object.assign(Object.assign({}, t_), e) : t_;
}
function mb(e, t, n) {
  const r = Wn(e, void 0, !1);
  return OU(r, new CE(t), GX(n), !1, t.byteLength), r.message;
}
function OU(e, t, n, r, a) {
  var o;
  const s = r ? t.len : t.pos + a;
  let i, u;
  const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
  for (; t.pos < s && ([i, u] = t.tag(), !(r && u == oe.EndGroup)); ) {
    const c = e.findNumber(i);
    if (!c) {
      const f = t.skip(u, i);
      n.readUnknownFields && l.push({ no: i, wireType: u, data: f });
      continue;
    }
    SU(e, t, c, u, n);
  }
  if (r && (u != oe.EndGroup || i !== a))
    throw new Error("invalid end group tag");
  l.length > 0 && e.setUnknown(l);
}
function SU(e, t, n, r, a) {
  var o;
  switch (n.fieldKind) {
    case "scalar":
      e.set(n, Yi(t, n.scalar));
      break;
    case "enum":
      const s = Yi(t, y.INT32);
      if (n.enum.open)
        e.set(n, s);
      else if (n.enum.values.some((i) => i.number === s))
        e.set(n, s);
      else if (a.readUnknownFields) {
        const i = [];
        hy(s, i);
        const u = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
        u.push({
          no: n.number,
          wireType: r,
          data: new Uint8Array(i)
        }), e.setUnknown(u);
      }
      break;
    case "message":
      e.set(n, QE(t, a, n, e.get(n)));
      break;
    case "list":
      CX(t, r, e.get(n), a);
      break;
    case "map":
      MX(t, e.get(n), a);
      break;
  }
}
function MX(e, t, n) {
  const r = t.field();
  let a, o;
  const s = e.uint32(), i = e.pos + s;
  for (; e.pos < i; ) {
    const [u] = e.tag();
    switch (u) {
      case 1:
        a = Yi(e, r.mapKey);
        break;
      case 2:
        switch (r.mapKind) {
          case "scalar":
            o = Yi(e, r.scalar);
            break;
          case "enum":
            o = e.int32();
            break;
          case "message":
            o = QE(e, n, r);
            break;
        }
        break;
    }
  }
  if (a === void 0 && (a = $s(r.mapKey, !1)), o === void 0)
    switch (r.mapKind) {
      case "scalar":
        o = $s(r.scalar, !1);
        break;
      case "enum":
        o = r.enum.values[0].number;
        break;
      case "message":
        o = Wn(r.message, void 0, !1);
        break;
    }
  t.set(a, o);
}
function CX(e, t, n, r) {
  var a;
  const o = n.field();
  if (o.listKind === "message") {
    n.add(QE(e, r, o));
    return;
  }
  const s = (a = o.scalar) !== null && a !== void 0 ? a : y.INT32;
  if (!(t == oe.LengthDelimited && s != y.STRING && s != y.BYTES)) {
    n.add(Yi(e, s));
    return;
  }
  const i = e.uint32() + e.pos;
  for (; e.pos < i; )
    n.add(Yi(e, s));
}
function QE(e, t, n, r) {
  const a = n.delimitedEncoding, o = r ?? Wn(n.message, void 0, !1);
  return OU(o, e, t, a, a ? n.number : e.uint32()), o;
}
function Yi(e, t) {
  switch (t) {
    case y.STRING:
      return e.string();
    case y.BOOL:
      return e.bool();
    case y.DOUBLE:
      return e.double();
    case y.FLOAT:
      return e.float();
    case y.INT32:
      return e.int32();
    case y.INT64:
      return e.int64();
    case y.UINT64:
      return e.uint64();
    case y.FIXED64:
      return e.fixed64();
    case y.BYTES:
      return e.bytes();
    case y.FIXED32:
      return e.fixed32();
    case y.SFIXED32:
      return e.sfixed32();
    case y.SFIXED64:
      return e.sfixed64();
    case y.SINT64:
      return e.sint64();
    case y.UINT32:
      return e.uint32();
    case y.SINT32:
      return e.sint32();
  }
}
function DU(e, t) {
  var n;
  const r = mb(BX, HE(e));
  return r.messageType.forEach(zE), r.dependency = (n = void 0) !== null && n !== void 0 ? n : [], EU(r, (a) => {
  }).getFile(r.name);
}
const KX = /* @__PURE__ */ DU("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), XX = /* @__PURE__ */ jc(KX, 0), WX = 3, n_ = {
  writeUnknownFields: !0
};
function JX(e) {
  return e ? Object.assign(Object.assign({}, n_), e) : n_;
}
function kU(e, t, n) {
  return Ad(new uU(), JX(n), Wn(e, t)).finish();
}
function Ad(e, t, n) {
  var r;
  for (const a of n.sortedFields) {
    if (!n.isSet(a)) {
      if (a.presence == WX)
        throw new Error(`cannot encode ${a} to binary: required field not set`);
      continue;
    }
    AU(e, t, n, a);
  }
  if (t.writeUnknownFields)
    for (const { no: a, wireType: o, data: s } of (r = n.getUnknown()) !== null && r !== void 0 ? r : [])
      e.tag(a, o).raw(s);
  return e;
}
function AU(e, t, n, r) {
  var a;
  switch (r.fieldKind) {
    case "scalar":
    case "enum":
      Ld(e, n.desc.typeName, r.name, (a = r.scalar) !== null && a !== void 0 ? a : y.INT32, r.number, n.get(r));
      break;
    case "list":
      ZX(e, t, r, n.get(r));
      break;
    case "message":
      LU(e, t, r, n.get(r));
      break;
    case "map":
      for (const [o, s] of n.get(r))
        HX(e, t, r, o, s);
      break;
  }
}
function Ld(e, t, n, r, a, o) {
  FU(e.tag(a, zX(r)), t, n, r, o);
}
function LU(e, t, n, r) {
  n.delimitedEncoding ? Ad(e.tag(n.number, oe.StartGroup), t, r).tag(n.number, oe.EndGroup) : Ad(e.tag(n.number, oe.LengthDelimited).fork(), t, r).join();
}
function ZX(e, t, n, r) {
  var a;
  if (n.listKind == "message") {
    for (const s of r)
      LU(e, t, n, s);
    return;
  }
  const o = (a = n.scalar) !== null && a !== void 0 ? a : y.INT32;
  if (n.packed) {
    if (!r.size)
      return;
    e.tag(n.number, oe.LengthDelimited).fork();
    for (const s of r)
      FU(e, n.parent.typeName, n.name, o, s);
    e.join();
    return;
  }
  for (const s of r)
    Ld(e, n.parent.typeName, n.name, o, n.number, s);
}
function HX(e, t, n, r, a) {
  var o;
  switch (e.tag(n.number, oe.LengthDelimited).fork(), Ld(e, n.parent.typeName, n.name, n.mapKey, 1, r), n.mapKind) {
    case "scalar":
    case "enum":
      Ld(e, n.parent.typeName, n.name, (o = n.scalar) !== null && o !== void 0 ? o : y.INT32, 2, a);
      break;
    case "message":
      Ad(e.tag(2, oe.LengthDelimited).fork(), t, a).join();
      break;
  }
  e.join();
}
function FU(e, t, n, r, a) {
  try {
    switch (r) {
      case y.STRING:
        e.string(a);
        break;
      case y.BOOL:
        e.bool(a);
        break;
      case y.DOUBLE:
        e.double(a);
        break;
      case y.FLOAT:
        e.float(a);
        break;
      case y.INT32:
        e.int32(a);
        break;
      case y.INT64:
        e.int64(a);
        break;
      case y.UINT64:
        e.uint64(a);
        break;
      case y.FIXED64:
        e.fixed64(a);
        break;
      case y.BYTES:
        e.bytes(a);
        break;
      case y.FIXED32:
        e.fixed32(a);
        break;
      case y.SFIXED32:
        e.sfixed32(a);
        break;
      case y.SFIXED64:
        e.sfixed64(a);
        break;
      case y.SINT64:
        e.sint64(a);
        break;
      case y.UINT32:
        e.uint32(a);
        break;
      case y.SINT32:
        e.sint32(a);
        break;
    }
  } catch (o) {
    throw o instanceof Error ? new Error(`cannot encode field ${t}.${n} to binary: ${o.message}`) : o;
  }
}
function zX(e) {
  switch (e) {
    case y.BYTES:
    case y.STRING:
      return oe.LengthDelimited;
    case y.DOUBLE:
    case y.FIXED64:
    case y.SFIXED64:
      return oe.Bit64;
    case y.FIXED32:
    case y.SFIXED32:
    case y.FLOAT:
      return oe.Bit32;
    default:
      return oe.Varint;
  }
}
function qX(e, t, n) {
  let r = !1;
  return n || (n = pr(XX), r = !0), n.value = kU(e, t), n.typeUrl = t7(t.$typeName), r ? n : void 0;
}
function QX(e, t) {
  if (e.typeUrl === "")
    return !1;
  const n = typeof t == "string" ? t : t.typeName, r = UU(e.typeUrl);
  return n === r;
}
function e7(e, t) {
  if (e.typeUrl === "")
    return;
  const n = t.kind == "message" ? t : t.getMessage(UU(e.typeUrl));
  if (!(!n || !QX(e, n)))
    return mb(n, e.value);
}
function t7(e) {
  return `type.googleapis.com/${e}`;
}
function UU(e) {
  const t = e.lastIndexOf("/"), n = t >= 0 ? e.substring(t + 1) : e;
  if (!n.length)
    throw new Error(`invalid type url: ${e}`);
  return n;
}
const e0 = /* @__PURE__ */ DU("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), n7 = /* @__PURE__ */ jc(e0, 0), RU = /* @__PURE__ */ jc(e0, 1), r7 = /* @__PURE__ */ jc(e0, 2);
var Iy;
(function(e) {
  e[e.NULL_VALUE = 0] = "NULL_VALUE";
})(Iy || (Iy = {}));
function a7(e, t) {
  $U(t, e);
  const n = s7(e.$unknown, t), [r, a, o] = db(t);
  for (const s of n)
    SU(r, new CE(s.data), a, s.wireType, {
      readUnknownFields: !0
    });
  return o();
}
function o7(e, t, n) {
  var r;
  $U(t, e);
  const a = ((r = e.$unknown) !== null && r !== void 0 ? r : []).filter((l) => l.no !== t.number), [o, s] = db(t, n), i = new uU();
  AU(i, { writeUnknownFields: !0 }, o, s);
  const u = new CE(i.finish());
  for (; u.pos < u.len; ) {
    const [l, c] = u.tag(), f = u.skip(c, l);
    a.push({ no: l, wireType: c, data: f });
  }
  e.$unknown = a;
}
function s7(e, t) {
  if (e === void 0)
    return [];
  if (t.fieldKind === "enum" || t.fieldKind === "scalar") {
    for (let n = e.length - 1; n >= 0; --n)
      if (e[n].no == t.number)
        return [e[n]];
    return [];
  }
  return e.filter((n) => n.no === t.number);
}
function db(e, t) {
  const n = e.typeName, r = Object.assign(Object.assign({}, e), { kind: "field", parent: e.extendee, localName: n }), a = Object.assign(Object.assign({}, e.extendee), { fields: [r], members: [r], oneofs: [] }), o = pr(a, t !== void 0 ? { [n]: t } : void 0);
  return [
    Wn(a, o),
    r,
    () => {
      const s = o[n];
      if (s === void 0) {
        const i = e.message;
        return Yc(i) ? $s(i.fields[0].scalar, i.fields[0].longAsString) : pr(i);
      }
      return s;
    }
  ];
}
function $U(e, t) {
  if (e.extendee.typeName != t.$typeName)
    throw new Error(`extension ${e.typeName} can only be applied to message ${e.extendee.typeName}`);
}
const i7 = 3, u7 = 2, r_ = {
  alwaysEmitImplicit: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1
};
function l7(e) {
  return e ? Object.assign(Object.assign({}, r_), e) : r_;
}
function c7(e, t, n) {
  return Bc(Wn(e, t), l7(n));
}
function f7(e, t, n) {
  var r;
  const a = c7(e, t, n);
  return JSON.stringify(a, null, (r = n?.prettySpaces) !== null && r !== void 0 ? r : 0);
}
function Bc(e, t) {
  var n;
  const r = b7(e, t);
  if (r !== void 0)
    return r;
  const a = {};
  for (const o of e.sortedFields) {
    if (!e.isSet(o)) {
      if (o.presence == i7)
        throw new Error(`cannot encode ${o} to JSON: required field not set`);
      if (!t.alwaysEmitImplicit || o.presence !== u7)
        continue;
    }
    const s = a_(o, e.get(o), t);
    s !== void 0 && (a[p7(o, t)] = s);
  }
  if (t.registry) {
    const o = /* @__PURE__ */ new Set();
    for (const { no: s } of (n = e.getUnknown()) !== null && n !== void 0 ? n : [])
      if (!o.has(s)) {
        o.add(s);
        const i = t.registry.getExtensionFor(e.desc, s);
        if (!i)
          continue;
        const u = a7(e.message, i), [l, c] = db(i, u), f = a_(c, l.get(c), t);
        f !== void 0 && (a[i.jsonName] = f);
      }
  }
  return a;
}
function a_(e, t, n) {
  switch (e.fieldKind) {
    case "scalar":
      return pb(e, t);
    case "message":
      return Bc(t, n);
    case "enum":
      return t0(e.enum, t, n.enumAsInteger);
    case "list":
      return d7(t, n);
    case "map":
      return m7(t, n);
  }
}
function m7(e, t) {
  const n = e.field(), r = {};
  switch (n.mapKind) {
    case "scalar":
      for (const [a, o] of e)
        r[a] = pb(n, o);
      break;
    case "message":
      for (const [a, o] of e)
        r[a] = Bc(o, t);
      break;
    case "enum":
      for (const [a, o] of e)
        r[a] = t0(n.enum, o, t.enumAsInteger);
      break;
  }
  return t.alwaysEmitImplicit || e.size > 0 ? r : void 0;
}
function d7(e, t) {
  const n = e.field(), r = [];
  switch (n.listKind) {
    case "scalar":
      for (const a of e)
        r.push(pb(n, a));
      break;
    case "enum":
      for (const a of e)
        r.push(t0(n.enum, a, t.enumAsInteger));
      break;
    case "message":
      for (const a of e)
        r.push(Bc(a, t));
      break;
  }
  return t.alwaysEmitImplicit || r.length > 0 ? r : void 0;
}
function t0(e, t, n) {
  var r;
  if (typeof t != "number")
    throw new Error(`cannot encode ${e} to JSON: expected number, got ${$e(t)}`);
  return e.typeName == "google.protobuf.NullValue" ? null : n ? t : (r = e.value[t]?.name) !== null && r !== void 0 ? r : t;
}
function pb(e, t) {
  var n, r, a, o, s, i;
  switch (e.scalar) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case y.INT32:
    case y.SFIXED32:
    case y.SINT32:
    case y.FIXED32:
    case y.UINT32:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(n = Ao(e, t)) === null || n === void 0 ? void 0 : n.message}`);
      return t;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case y.FLOAT:
    case y.DOUBLE:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(r = Ao(e, t)) === null || r === void 0 ? void 0 : r.message}`);
      return Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    // string:
    case y.STRING:
      if (typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(a = Ao(e, t)) === null || a === void 0 ? void 0 : a.message}`);
      return t;
    // bool:
    case y.BOOL:
      if (typeof t != "boolean")
        throw new Error(`cannot encode ${e} to JSON: ${(o = Ao(e, t)) === null || o === void 0 ? void 0 : o.message}`);
      return t;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case y.UINT64:
    case y.FIXED64:
    case y.INT64:
    case y.SFIXED64:
    case y.SINT64:
      if (typeof t != "bigint" && typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(s = Ao(e, t)) === null || s === void 0 ? void 0 : s.message}`);
      return t.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case y.BYTES:
      if (t instanceof Uint8Array)
        return yU(t);
      throw new Error(`cannot encode ${e} to JSON: ${(i = Ao(e, t)) === null || i === void 0 ? void 0 : i.message}`);
  }
}
function p7(e, t) {
  return t.useProtoFieldName ? e.name : e.jsonName;
}
function b7(e, t) {
  if (e.desc.typeName.startsWith("google.protobuf."))
    switch (e.desc.typeName) {
      case "google.protobuf.Any":
        return g7(e.message, t);
      case "google.protobuf.Timestamp":
        return N7(e.message);
      case "google.protobuf.Duration":
        return h7(e.message);
      case "google.protobuf.FieldMask":
        return y7(e.message);
      case "google.protobuf.Struct":
        return PU(e.message);
      case "google.protobuf.Value":
        return n0(e.message);
      case "google.protobuf.ListValue":
        return VU(e.message);
      default:
        if (Yc(e.desc)) {
          const n = e.desc.fields[0];
          return pb(n, e.get(n));
        }
        return;
    }
}
function g7(e, t) {
  if (e.typeUrl === "")
    return {};
  const { registry: n } = t;
  let r, a;
  if (n && (r = e7(e, n), r && (a = n.getMessage(r.$typeName))), !a || !r)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: "${e.typeUrl}" is not in the type registry`);
  let o = Bc(Wn(a, r), t);
  return (a.typeName.startsWith("google.protobuf.") || o === null || Array.isArray(o) || typeof o != "object") && (o = { value: o }), o["@type"] = e.typeUrl, o;
}
function h7(e) {
  const t = Number(e.seconds), n = e.nanos;
  if (t > 315576e6 || t < -315576e6)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: value out of range`);
  if (t > 0 && n < 0 || t < 0 && n > 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos sign must match seconds sign`);
  let r = e.seconds.toString();
  if (n !== 0) {
    let a = Math.abs(n).toString();
    a = "0".repeat(9 - a.length) + a, a.substring(3) === "000000" ? a = a.substring(0, 3) : a.substring(6) === "000" && (a = a.substring(0, 6)), r += "." + a, n < 0 && t == 0 && (r = "-" + r);
  }
  return r + "s";
}
function y7(e) {
  return e.paths.map((t) => {
    if (t.match(/_[0-9]?_/g) || t.match(/[A-Z]/g))
      throw new Error(`cannot encode message ${e.$typeName} to JSON: lowerCamelCase of path name "` + t + '" is irreversible');
    return il(t);
  }).join(",");
}
function PU(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = n0(r);
  return t;
}
function n0(e) {
  switch (e.kind.case) {
    case "nullValue":
      return null;
    case "numberValue":
      if (!Number.isFinite(e.kind.value))
        throw new Error(`${e.$typeName} cannot be NaN or Infinity`);
      return e.kind.value;
    case "boolValue":
      return e.kind.value;
    case "stringValue":
      return e.kind.value;
    case "structValue":
      return PU(e.kind.value);
    case "listValue":
      return VU(e.kind.value);
    default:
      throw new Error(`${e.$typeName} must have a value`);
  }
}
function VU(e) {
  return e.values.map(n0);
}
function N7(e) {
  const t = Number(e.seconds) * 1e3;
  if (t < Date.parse("0001-01-01T00:00:00Z") || t > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot encode message ${e.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  if (e.nanos < 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be negative`);
  if (e.nanos > 999999999)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be greater than 99999999`);
  let n = "Z";
  if (e.nanos > 0) {
    const r = (e.nanos + 1e9).toString().substring(1);
    r.substring(3) === "000000" ? n = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? n = "." + r.substring(0, 6) + "Z" : n = "." + r + "Z";
  }
  return new Date(t).toISOString().replace(".000Z", n);
}
const o_ = {
  ignoreUnknownFields: !1
};
function E7(e) {
  return e ? Object.assign(Object.assign({}, o_), e) : o_;
}
function v7(e, t, n) {
  return xU(e, D7(t, e.typeName), n);
}
function xU(e, t, n) {
  const r = Wn(e);
  try {
    ji(r, t, E7(n));
  } catch (a) {
    throw tX(a) ? new Error(`cannot decode ${a.field()} from JSON: ${a.message}`, {
      cause: a
    }) : a;
  }
  return r.message;
}
function ji(e, t, n) {
  var r;
  if (k7(e, t, n))
    return;
  if (t == null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode ${e.desc} from JSON: ${$e(t)}`);
  const a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const s of e.desc.fields)
    o.set(s.name, s).set(s.jsonName, s);
  for (const [s, i] of Object.entries(t)) {
    const u = o.get(s);
    if (u) {
      if (u.oneof) {
        if (i === null && u.fieldKind == "scalar")
          continue;
        const l = a.get(u.oneof);
        if (l !== void 0)
          throw new Ft(u.oneof, `oneof set multiple times by ${l.name} and ${u.name}`);
        a.set(u.oneof, u);
      }
      s_(e, u, i, n);
    } else {
      let l;
      if (s.startsWith("[") && s.endsWith("]") && // biome-ignore lint/suspicious/noAssignInExpressions: no
      (l = (r = n.registry) === null || r === void 0 ? void 0 : r.getExtension(s.substring(1, s.length - 1))) && l.extendee.typeName === e.desc.typeName) {
        const [c, f, d] = db(l);
        s_(c, f, i, n), o7(e.message, l, d());
      }
      if (!l && !n.ignoreUnknownFields)
        throw new Error(`cannot decode ${e.desc} from JSON: key "${s}" is unknown`);
    }
  }
}
function s_(e, t, n, r) {
  switch (t.fieldKind) {
    case "scalar":
      O7(e, t, n);
      break;
    case "enum":
      _7(e, t, n, r);
      break;
    case "message":
      w7(e, t, n, r);
      break;
    case "list":
      I7(e.get(t), n, r);
      break;
    case "map":
      T7(e.get(t), n, r);
      break;
  }
}
function T7(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (typeof t != "object" || Array.isArray(t))
    throw new Ft(r, "expected object, got " + $e(t));
  for (const [a, o] of Object.entries(t)) {
    if (o === null && !YU(r))
      throw new Ft(r, "map value must not be null");
    let s;
    switch (r.mapKind) {
      case "message":
        const u = Wn(r.message);
        ji(u, o, n), s = u;
        break;
      case "enum":
        if (s = r0(r.enum, o, n.ignoreUnknownFields, !0), s === bb)
          return;
        break;
      case "scalar":
        s = hb(r, o, !0);
        break;
    }
    const i = S7(r.mapKey, a);
    e.set(i, s);
  }
}
function I7(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (!Array.isArray(t))
    throw new Ft(r, "expected Array, got " + $e(t));
  for (const a of t) {
    if (a === null && !YU(r))
      throw new Ft(r, "list item must not be null");
    switch (r.listKind) {
      case "message":
        const o = Wn(r.message);
        ji(o, a, n), e.add(o);
        break;
      case "enum":
        const s = r0(r.enum, a, n.ignoreUnknownFields, !0);
        s !== bb && e.add(s);
        break;
      case "scalar":
        e.add(hb(r, a, !0));
        break;
    }
  }
}
function YU(e) {
  var t, n;
  return ((t = e.message) === null || t === void 0 ? void 0 : t.typeName) == "google.protobuf.Value" || ((n = e.enum) === null || n === void 0 ? void 0 : n.typeName) == "google.protobuf.NullValue";
}
function w7(e, t, n, r) {
  if (n === null && t.message.typeName != "google.protobuf.Value") {
    e.clear(t);
    return;
  }
  const a = e.isSet(t) ? e.get(t) : Wn(t.message);
  ji(a, n, r), e.set(t, a);
}
function _7(e, t, n, r) {
  const a = r0(t.enum, n, r.ignoreUnknownFields, !1);
  a === gb ? e.clear(t) : a !== bb && e.set(t, a);
}
function O7(e, t, n) {
  const r = hb(t, n, !1);
  r === gb ? e.clear(t) : e.set(t, r);
}
const bb = /* @__PURE__ */ Symbol();
function r0(e, t, n, r) {
  if (t === null)
    return e.typeName == "google.protobuf.NullValue" ? 0 : r ? e.values[0].number : gb;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const a = e.values.find((o) => o.name === t);
      if (a !== void 0)
        return a.number;
      if (n)
        return bb;
      break;
  }
  throw new Error(`cannot decode ${e} from JSON: ${$e(t)}`);
}
const gb = /* @__PURE__ */ Symbol();
function hb(e, t, n) {
  if (t === null)
    return n ? $s(e.scalar, !1) : gb;
  switch (e.scalar) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case y.DOUBLE:
    case y.FLOAT:
      if (t === "NaN")
        return NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (typeof t == "number") {
        if (Number.isNaN(t))
          throw new Ft(e, "unexpected NaN number");
        if (!Number.isFinite(t))
          throw new Ft(e, "unexpected infinite number");
        break;
      }
      if (typeof t == "string") {
        if (t === "" || t.trim().length !== t.length)
          break;
        const r = Number(t);
        if (!Number.isFinite(r))
          break;
        return r;
      }
      break;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case y.INT32:
    case y.FIXED32:
    case y.SFIXED32:
    case y.SINT32:
    case y.UINT32:
      return jU(t);
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case y.BYTES:
      if (typeof t == "string") {
        if (t === "")
          return new Uint8Array(0);
        try {
          return HE(t);
        } catch (r) {
          const a = r instanceof Error ? r.message : String(r);
          throw new Ft(e, a);
        }
      }
      break;
  }
  return t;
}
function S7(e, t) {
  switch (e) {
    case y.BOOL:
      switch (t) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      return t;
    case y.INT32:
    case y.FIXED32:
    case y.UINT32:
    case y.SFIXED32:
    case y.SINT32:
      return jU(t);
    default:
      return t;
  }
}
function jU(e) {
  if (typeof e == "string") {
    if (e === "" || e.trim().length !== e.length)
      return e;
    const t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
function D7(e, t) {
  try {
    return JSON.parse(e);
  } catch (n) {
    const r = n instanceof Error ? n.message : String(n);
    throw new Error(
      `cannot decode message ${t} from JSON: ${r}`,
      // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
      { cause: n }
    );
  }
}
function k7(e, t, n) {
  if (!e.desc.typeName.startsWith("google.protobuf."))
    return !1;
  switch (e.desc.typeName) {
    case "google.protobuf.Any":
      return A7(e.message, t, n), !0;
    case "google.protobuf.Timestamp":
      return L7(e.message, t), !0;
    case "google.protobuf.Duration":
      return F7(e.message, t), !0;
    case "google.protobuf.FieldMask":
      return U7(e.message, t), !0;
    case "google.protobuf.Struct":
      return BU(e.message, t), !0;
    case "google.protobuf.Value":
      return a0(e.message, t), !0;
    case "google.protobuf.ListValue":
      return GU(e.message, t), !0;
    default:
      if (Yc(e.desc)) {
        const r = e.desc.fields[0];
        return t === null ? e.clear(r) : e.set(r, hb(r, t, !0)), !0;
      }
      return !1;
  }
}
function A7(e, t, n) {
  var r;
  if (t === null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: expected object but got ${$e(t)}`);
  if (Object.keys(t).length == 0)
    return;
  const a = t["@type"];
  if (typeof a != "string" || a == "")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is empty`);
  const o = a.includes("/") ? a.substring(a.lastIndexOf("/") + 1) : a;
  if (!o.length)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is invalid`);
  const s = (r = n.registry) === null || r === void 0 ? void 0 : r.getMessage(o);
  if (!s)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${a} is not in the type registry`);
  const i = Wn(s);
  if (o.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(t, "value")) {
    const u = t.value;
    ji(i, u, n);
  } else {
    const u = Object.assign({}, t);
    delete u["@type"], ji(i, u, n);
  }
  qX(i.desc, i.message, e);
}
function L7(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${$e(t)}`);
  const n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
  if (!n)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  const r = Date.parse(
    // biome-ignore format: want this to read well
    n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z")
  );
  if (Number.isNaN(r))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  e.seconds = W.parse(r / 1e3), e.nanos = 0, n[7] && (e.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9);
}
function F7(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${$e(t)}`);
  const n = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
  if (n === null)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${$e(t)}`);
  const r = Number(n[1]);
  if (r > 315576e6 || r < -315576e6)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${$e(t)}`);
  if (e.seconds = W.parse(r), typeof n[2] != "string")
    return;
  const a = n[2] + "0".repeat(9 - n[2].length);
  e.nanos = parseInt(a), (r < 0 || Object.is(r, -0)) && (e.nanos = -e.nanos);
}
function U7(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${$e(t)}`);
  if (t === "")
    return;
  function n(r) {
    if (r.includes("_"))
      throw new Error(`cannot decode message ${e.$typeName} from JSON: path names must be lowerCamelCase`);
    const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase());
    return a[0] === "_" ? a.substring(1) : a;
  }
  e.paths = t.split(",").map(n);
}
function BU(e, t) {
  if (typeof t != "object" || t == null || Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${$e(t)}`);
  for (const [n, r] of Object.entries(t)) {
    const a = pr(RU);
    a0(a, r), e.fields[n] = a;
  }
}
function a0(e, t) {
  switch (typeof t) {
    case "number":
      e.kind = { case: "numberValue", value: t };
      break;
    case "string":
      e.kind = { case: "stringValue", value: t };
      break;
    case "boolean":
      e.kind = { case: "boolValue", value: t };
      break;
    case "object":
      if (t === null)
        e.kind = { case: "nullValue", value: Iy.NULL_VALUE };
      else if (Array.isArray(t)) {
        const n = pr(r7);
        GU(n, t), e.kind = { case: "listValue", value: n };
      } else {
        const n = pr(n7);
        BU(n, t), e.kind = { case: "structValue", value: n };
      }
      break;
    default:
      throw new Error(`cannot decode message ${e.$typeName} from JSON ${$e(t)}`);
  }
  return e;
}
function GU(e, t) {
  if (!Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${$e(t)}`);
  for (const n of t) {
    const r = pr(RU);
    a0(r, n), e.values.push(r);
  }
}
function wy(e) {
  const t = V[e];
  return typeof t != "string" ? e.toString() : t[0].toLowerCase() + t.substring(1).replace(/[A-Z]/g, (n) => "_" + n.toLowerCase());
}
let tm;
function R7(e) {
  if (!tm) {
    tm = {};
    for (const t of Object.values(V))
      typeof t != "string" && (tm[wy(t)] = t);
  }
  return tm[e];
}
class _e extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(t, n = V.Unknown, r, a, o) {
    super($7(t, n)), this.name = "ConnectError", Object.setPrototypeOf(this, new.target.prototype), this.rawMessage = t, this.code = n, this.metadata = new Headers(r ?? {}), this.details = a ?? [], this.cause = o;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(t, n = V.Unknown) {
    return t instanceof _e ? t : t instanceof Error ? t.name == "AbortError" || t.name == "TimeoutError" ? new _e(t.message, V.Canceled) : new _e(t.message, n, void 0, void 0, t) : new _e(String(t), n, void 0, void 0, t);
  }
  static [Symbol.hasInstance](t) {
    return t instanceof Error ? Object.getPrototypeOf(t) === _e.prototype ? !0 : t.name === "ConnectError" && "code" in t && typeof t.code == "number" && "metadata" in t && "details" in t && Array.isArray(t.details) && "rawMessage" in t && typeof t.rawMessage == "string" && "cause" in t : !1;
  }
  findDetails(t) {
    const n = t.kind === "message" ? {
      getMessage: (a) => a === t.typeName ? t : void 0
    } : t, r = [];
    for (const a of this.details) {
      if ("desc" in a) {
        n.getMessage(a.desc.typeName) && r.push(pr(a.desc, a.value));
        continue;
      }
      const o = n.getMessage(a.type);
      if (o)
        try {
          r.push(mb(o, a.value));
        } catch {
        }
    }
    return r;
  }
}
function $7(e, t) {
  return e.length ? `[${wy(t)}] ${e}` : `[${wy(t)}]`;
}
function P7(...e) {
  const t = new Headers();
  for (const n of e)
    n.forEach((r, a) => {
      t.append(a, r);
    });
  return t;
}
const i_ = 1;
function V7(e, t, n = !1) {
  if (t > e) {
    let r = `message size is larger than configured readMaxBytes ${e}`;
    throw n && (r = `message size ${t} is larger than configured readMaxBytes ${e}`), new _e(r, V.ResourceExhausted);
  }
}
function x7(e) {
  return new Y7(e);
}
class Y7 {
  constructor(t) {
    this.readMaxBytes = t, this.header = new Uint8Array(5), this.headerView = new DataView(this.header.buffer), this.buf = [];
  }
  get byteLength() {
    return this.buf.reduce((t, n) => t + n.byteLength, 0);
  }
  decode(t) {
    this.buf.push(t);
    const n = [];
    for (; ; ) {
      let r = this.pop();
      if (!r)
        break;
      n.push(r);
    }
    return n;
  }
  // consume an enveloped message
  pop() {
    if (!(!this.env && (this.env = this.head(), !this.env)) && this.cons(this.env.data)) {
      const t = this.env;
      return this.env = void 0, t;
    }
  }
  // consume header
  head() {
    if (!this.cons(this.header))
      return;
    const t = this.headerView.getUint8(0), n = this.headerView.getUint32(1);
    return V7(this.readMaxBytes, n, !0), {
      flags: t,
      data: new Uint8Array(n)
    };
  }
  // consume from buffer, fill target
  cons(t) {
    const n = t.byteLength;
    if (this.byteLength < n)
      return !1;
    let r = 0;
    for (; r < n; ) {
      const a = this.buf.shift();
      a.byteLength > n - r ? (t.set(a.subarray(0, n - r), r), this.buf.unshift(a.subarray(n - r)), r += n - r) : (t.set(a, r), r += a.byteLength);
    }
    return !0;
  }
}
function j7(e) {
  let t;
  const n = x7(4294967295);
  return new ReadableStream({
    start() {
      t = e.getReader();
    },
    async pull(r) {
      let a = !1;
      for (; !a; ) {
        const o = await t.read();
        if (o.done)
          n.byteLength > 0 && r.error(new _e("protocol error: incomplete envelope", V.InvalidArgument)), r.close();
        else
          for (const s of n.decode(o.value))
            r.enqueue(s), a = !0;
      }
    }
  });
}
function B7(e, t) {
  const n = new Uint8Array(t.length + 5);
  n.set(t, 5);
  const r = new DataView(n.buffer, n.byteOffset, n.byteLength);
  return r.setUint8(0, e), r.setUint32(1, t.length), n;
}
function G7(...e) {
  const t = new AbortController(), n = e.filter((a) => a !== void 0).concat(t.signal);
  for (const a of n) {
    if (a.aborted) {
      r.apply(a);
      break;
    }
    a.addEventListener("abort", r);
  }
  function r() {
    t.signal.aborted || t.abort(MU(this));
    for (const a of n)
      a.removeEventListener("abort", r);
  }
  return t;
}
function M7(e) {
  const t = new AbortController(), n = () => {
    t.abort(new _e("the operation timed out", V.DeadlineExceeded));
  };
  let r;
  return e !== void 0 && (e <= 0 ? n() : r = setTimeout(n, e)), {
    signal: t.signal,
    cleanup: () => clearTimeout(r)
  };
}
function MU(e) {
  if (!e.aborted)
    return;
  if (e.reason !== void 0)
    return e.reason;
  const t = new Error("This operation was aborted");
  return t.name = "AbortError", t;
}
function u_() {
  return {
    get(e) {
      return e.id in this ? this[e.id] : e.defaultValue;
    },
    set(e, t) {
      return this[e.id] = t, this;
    },
    delete(e) {
      return delete this[e.id], this;
    }
  };
}
function l_(e, t) {
  return e.toString().replace(/\/?$/, `/${t.parent.typeName}/${t.name}`);
}
function CU(e, t) {
  return pr(e, t);
}
function C7(e, t) {
  function n(r) {
    return r.done === !0 ? r : {
      done: r.done,
      value: CU(e, r.value)
    };
  }
  return {
    [Symbol.asyncIterator]() {
      const r = t[Symbol.asyncIterator](), a = {
        next: () => r.next().then(n)
      };
      return r.throw !== void 0 && (a.throw = (o) => r.throw(o).then(n)), r.return !== void 0 && (a.return = (o) => r.return(o).then(n)), a;
    }
  };
}
function KU(e, t) {
  if (!t)
    return e;
  for (const n of t.concat().reverse())
    e = n(e);
  return e;
}
function XU(e) {
  var t;
  const n = Object.assign({}, e);
  return (t = n.ignoreUnknownFields) !== null && t !== void 0 || (n.ignoreUnknownFields = !0), n;
}
function c_(e, t, n, r) {
  const a = t ? f_(e.input, r) : m_(e.input, n);
  return { parse: (t ? f_(e.output, r) : m_(e.output, n)).parse, serialize: a.serialize };
}
function f_(e, t) {
  return {
    parse(n) {
      try {
        return mb(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new _e(`parse binary: ${a}`, V.Internal);
      }
    },
    serialize(n) {
      try {
        return kU(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new _e(`serialize binary: ${a}`, V.Internal);
      }
    }
  };
}
function m_(e, t) {
  var n, r;
  const a = (n = t?.textEncoder) !== null && n !== void 0 ? n : new TextEncoder(), o = (r = t?.textDecoder) !== null && r !== void 0 ? r : new TextDecoder(), s = XU(t);
  return {
    parse(i) {
      try {
        const u = o.decode(i);
        return v7(e, u, s);
      } catch (u) {
        throw _e.from(u, V.InvalidArgument);
      }
    },
    serialize(i) {
      try {
        const u = f7(e, i, s);
        return a.encode(u);
      } catch (u) {
        throw _e.from(u, V.Internal);
      }
    }
  };
}
const K7 = /^application\/(connect\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i, X7 = "application/proto", W7 = "application/json", J7 = "application/connect+proto", Z7 = "application/connect+json";
function H7(e) {
  const t = e?.match(K7);
  if (!t)
    return;
  const n = !!t[1], r = !!t[3];
  return { stream: n, binary: r };
}
function WU(e, t, n) {
  var r;
  if (t && new Headers(t).forEach((i, u) => n.metadata.append(u, i)), typeof e != "object" || e == null || Array.isArray(e))
    throw n;
  let a = n.code;
  "code" in e && typeof e.code == "string" && (a = (r = R7(e.code)) !== null && r !== void 0 ? r : a);
  const o = e.message;
  if (o != null && typeof o != "string")
    throw n;
  const s = new _e(o ?? "", a, t);
  if ("details" in e && Array.isArray(e.details))
    for (const i of e.details) {
      if (i === null || typeof i != "object" || Array.isArray(i) || typeof i.type != "string" || typeof i.value != "string")
        throw n;
      try {
        s.details.push({
          type: i.type,
          value: HE(i.value),
          debug: i.debug
        });
      } catch {
        throw n;
      }
    }
  return s;
}
const d_ = 2;
function z7(e) {
  const t = new _e("invalid end stream", V.Unknown);
  let n;
  try {
    n = JSON.parse(typeof e == "string" ? e : new TextDecoder().decode(e));
  } catch {
    throw t;
  }
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw t;
  const r = new Headers();
  if ("metadata" in n) {
    if (typeof n.metadata != "object" || n.metadata == null || Array.isArray(n.metadata))
      throw t;
    for (const [o, s] of Object.entries(n.metadata)) {
      if (!Array.isArray(s) || s.some((i) => typeof i != "string"))
        throw t;
      for (const i of s)
        r.append(o, i);
    }
  }
  const a = "error" in n && n.error != null ? WU(n.error, r, t) : void 0;
  return { metadata: r, error: a };
}
const Fd = "Content-Type", q7 = "Content-Length", p_ = "Content-Encoding", Q7 = "Accept-Encoding", eW = "Connect-Timeout-Ms", JU = "Connect-Protocol-Version", tW = "User-Agent";
function nW(e) {
  switch (e) {
    case 400:
      return V.Internal;
    case 401:
      return V.Unauthenticated;
    case 403:
      return V.PermissionDenied;
    case 404:
      return V.Unimplemented;
    case 429:
      return V.Unavailable;
    case 502:
      return V.Unavailable;
    case 503:
      return V.Unavailable;
    case 504:
      return V.Unavailable;
    default:
      return V.Unknown;
  }
}
function b_(e) {
  const t = new Headers(), n = new Headers();
  return e.forEach((r, a) => {
    a.toLowerCase().startsWith("trailer-") ? n.append(a.substring(8), r) : t.append(a, r);
  }), [t, n];
}
const ZU = "1";
function g_(e, t, n, r, a) {
  const o = new Headers(r ?? {});
  return n !== void 0 && o.set(eW, `${n}`), o.set(Fd, e == "unary" ? t ? X7 : W7 : t ? J7 : Z7), o.set(JU, ZU), o.has(tW), o;
}
function h_(e, t, n, r) {
  const a = r.get(Fd), o = H7(a);
  if (n !== 200) {
    const i = new _e(`HTTP ${n}`, nW(n), r);
    if (e == "unary" && o && !o.binary)
      return { isUnaryError: !0, unaryError: i };
    throw i;
  }
  const s = {
    binary: t,
    stream: e !== "unary"
  };
  if (o?.binary !== s.binary || o.stream !== s.stream)
    throw new _e(`unsupported content type ${a}`, o === void 0 ? V.Unknown : V.Internal, r);
  return { isUnaryError: !1 };
}
const y_ = "application/";
function rW(e, t) {
  return t ? yU(e, "url") : encodeURIComponent(new TextDecoder().decode(e));
}
function aW(e, t, n) {
  let r = `?connect=v${ZU}`;
  const a = e.header.get(Fd);
  a?.indexOf(y_) === 0 && (r += "&encoding=" + encodeURIComponent(a.slice(y_.length)));
  const o = e.header.get(p_);
  o !== null && o !== "identity" && (r += "&compression=" + encodeURIComponent(o), n = !0), n && (r += "&base64=1"), r += "&message=" + rW(t, n);
  const s = e.url + r, i = new Headers(e.header);
  for (const u of [
    JU,
    Fd,
    q7,
    p_,
    Q7
  ])
    i.delete(u);
  return Object.assign(Object.assign({}, e), {
    requestMethod: "GET",
    url: s,
    header: i
  });
}
function oW(e) {
  const t = KU(e.next, e.interceptors), [n, r, a] = HU(e), o = Object.assign(Object.assign({}, e.req), { message: CU(e.req.method.input, e.req.message), signal: n });
  return t(o).then((s) => (a(), s), r);
}
function sW(e) {
  const t = KU(e.next, e.interceptors), [n, r, a] = HU(e), o = Object.assign(Object.assign({}, e.req), { message: C7(e.req.method.input, e.req.message), signal: n });
  let s = !1;
  return n.addEventListener("abort", function() {
    var i, u;
    const l = e.req.message[Symbol.asyncIterator]();
    s || (i = l.throw) === null || i === void 0 || i.call(l, this.reason).catch(() => {
    }), (u = l.return) === null || u === void 0 || u.call(l).catch(() => {
    });
  }), t(o).then((i) => Object.assign(Object.assign({}, i), { message: {
    [Symbol.asyncIterator]() {
      const u = i.message[Symbol.asyncIterator]();
      return {
        next() {
          return u.next().then((l) => (l.done == !0 && (s = !0, a()), l), r);
        }
        // We deliberately omit throw/return.
      };
    }
  } }), r);
}
function HU(e) {
  const { signal: t, cleanup: n } = M7(e.timeoutMs), r = G7(e.signal, t);
  return [
    r.signal,
    function(a) {
      const o = _e.from(t.aborted ? MU(t) : a);
      return r.abort(o), n(), Promise.reject(o);
    },
    function() {
      n(), r.abort();
    }
  ];
}
function iW() {
  try {
    new Headers();
  } catch {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}
var cl = function(e) {
  return this instanceof cl ? (this.v = e, this) : new cl(e);
}, uW = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof cl ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
const N_ = {
  redirect: "error"
};
function lW(e) {
  var t;
  iW();
  const n = (t = e.useBinaryFormat) !== null && t !== void 0 ? t : !1;
  return {
    async unary(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = c_(r, n, e.jsonOptions, e.binaryOptions);
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await oW({
        interceptors: e.interceptors,
        signal: a,
        timeoutMs: o,
        req: {
          stream: !1,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: l_(e.baseUrl, r),
          header: g_(r.methodKind, n, o, s),
          contextValues: u ?? u_(),
          message: i
        },
        next: async (f) => {
          var d;
          const m = e.useHttpGet === !0 && r.idempotency === Ty.NO_SIDE_EFFECTS;
          let p = null;
          m ? f = aW(f, l(f.message), n) : p = l(f.message);
          const b = await ((d = e.fetch) !== null && d !== void 0 ? d : globalThis.fetch)(f.url, Object.assign(Object.assign({}, N_), { method: f.requestMethod, headers: f.header, signal: f.signal, body: p })), { isUnaryError: g, unaryError: S } = h_(r.methodKind, n, b.status, b.headers);
          if (g)
            throw WU(await b.json(), P7(...b_(b.headers)), S);
          const [D, k] = b_(b.headers);
          return {
            stream: !1,
            service: r.parent,
            method: r,
            header: D,
            message: n ? c(new Uint8Array(await b.arrayBuffer())) : xU(r.output, await b.json(), XU(e.jsonOptions)),
            trailer: k
          };
        }
      });
    },
    async stream(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = c_(r, n, e.jsonOptions, e.binaryOptions);
      function f(m, p, b, g) {
        return uW(this, arguments, function* () {
          const S = j7(m).getReader();
          let D = !1;
          for (; ; ) {
            const k = yield cl(S.read());
            if (k.done)
              break;
            const { flags: U, data: R } = k.value;
            if ((U & i_) === i_)
              throw new _e("protocol error: received unsupported compressed output", V.Internal);
            if ((U & d_) === d_) {
              D = !0;
              const F = z7(R);
              if (F.error) {
                const A = F.error;
                throw b.forEach((L, re) => {
                  A.metadata.append(re, L);
                }), A;
              }
              F.metadata.forEach((A, L) => p.set(L, A));
              continue;
            }
            yield yield cl(c(R));
          }
          if ("throwIfAborted" in g && g.throwIfAborted(), !D)
            throw "missing EndStreamResponse";
        });
      }
      async function d(m) {
        if (r.methodKind != "server_streaming")
          throw "The fetch API does not support streaming request bodies";
        const p = await m[Symbol.asyncIterator]().next();
        if (p.done == !0)
          throw "missing request message";
        return B7(0, l(p.value));
      }
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await sW({
        interceptors: e.interceptors,
        timeoutMs: o,
        signal: a,
        req: {
          stream: !0,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: l_(e.baseUrl, r),
          header: g_(r.methodKind, n, o, s),
          contextValues: u ?? u_(),
          message: i
        },
        next: async (m) => {
          var p;
          const b = await ((p = e.fetch) !== null && p !== void 0 ? p : globalThis.fetch)(m.url, Object.assign(Object.assign({}, N_), { method: m.requestMethod, headers: m.header, signal: m.signal, body: await d(m.message) }));
          if (h_(r.methodKind, n, b.status, b.headers), b.body === null)
            throw "missing response body";
          const g = new Headers();
          return Object.assign(Object.assign({}, m), { header: b.headers, trailer: g, message: f(b.body, g, b.headers, m.signal) });
        }
      });
    }
  };
}
lW({
  baseUrl: "/api",
  useBinaryFormat: !0,
  fetch: (e, t) => {
    const n = t?.headers ?? {};
    return fetch(e, {
      ...t,
      headers: {
        ...n,
        "qt-widget-id": window.qtWidgetId
      }
    });
  }
});
const dt = /* @__PURE__ */ Symbol(), cW = !1;
var fW = Array.isArray, mW = Array.prototype.indexOf, Vg = Object.getOwnPropertyDescriptor, dW = Object.prototype, pW = Array.prototype, bW = Object.getPrototypeOf;
function gW(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function hW() {
  var e, t, n = new Promise((r, a) => {
    e = r, t = a;
  });
  return { promise: n, resolve: e, reject: t };
}
const on = 2, yW = 4, NW = 1 << 24, vu = 16, Gc = 32, Mc = 64, o0 = 128, Mr = 512, Tt = 1024, br = 2048, Cr = 4096, Jm = 8192, ss = 16384, EW = 32768, E_ = 1 << 17, zU = 1 << 18, Ps = 32768, _y = 1 << 21, qU = 1 << 22, fl = 1 << 23, xg = /* @__PURE__ */ Symbol("$state"), QU = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function vW() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function TW() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function IW() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function wW() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function _W(e) {
  return e === this.v;
}
let OW = !1;
function e4() {
  return !0;
}
let di = [];
function SW() {
  var e = di;
  di = [], gW(e);
}
function DW(e) {
  if (di.length === 0) {
    var t = di;
    queueMicrotask(() => {
      t === di && SW();
    });
  }
  di.push(e);
}
function kW(e) {
  var t = Ut;
  if (t === null)
    return ge.f |= fl, e;
  if ((t.f & EW) === 0) {
    if ((t.f & o0) === 0)
      throw e;
    t.b.error(e);
  } else
    t4(e, t);
}
function t4(e, t) {
  for (; t !== null; ) {
    if ((t.f & o0) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e;
}
const nm = /* @__PURE__ */ new Set();
let Xe = null, Vn = null, Ur = [], s0 = null, Oy = !1;
class ml {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #e = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #i = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    Ur = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const r of t)
      this.#u(r, n);
    this.is_fork || this.#c(), this.is_deferred() ? (this.#n(n.effects), this.#n(n.render_effects)) : (Xe = null, v_(n.render_effects), v_(n.effects), this.#i?.resolve()), Vn = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #u(t, n) {
    t.f ^= Tt;
    for (var r = t.first; r !== null; ) {
      var a = r.f, o = (a & (Gc | Mc)) !== 0, s = o && (a & Tt) !== 0, i = s || (a & Jm) !== 0 || this.skipped_effects.has(r);
      if ((r.f & o0) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: []
      }), !i && r.fn !== null) {
        o ? r.f ^= Tt : (a & yW) !== 0 ? n.effects.push(r) : Kc(r) && ((r.f & vu) !== 0 && this.#o.add(r), Vd(r));
        var u = r.first;
        if (u !== null) {
          r = u;
          continue;
        }
      }
      var l = r.parent;
      for (r = r.next; r === null && l !== null; )
        l === n.effect && (this.#n(n.effects), this.#n(n.render_effects), n = /** @type {EffectTarget} */
        n.parent), r = l.next, l = l.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #n(t) {
    for (const n of t)
      (n.f & br) !== 0 ? this.#o.add(n) : (n.f & Cr) !== 0 && this.#s.add(n), this.#l(n.deps), Rt(n, Tt);
  }
  /**
   * @param {Value[] | null} deps
   */
  #l(t) {
    if (t !== null)
      for (const n of t)
        (n.f & on) === 0 || (n.f & Ps) === 0 || (n.f ^= Ps, this.#l(
          /** @type {Derived} */
          n.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.previous.has(t) || this.previous.set(t, n), (t.f & fl) === 0 && (this.current.set(t, t.v), Vn?.set(t, t.v));
  }
  activate() {
    Xe = this, this.apply();
  }
  deactivate() {
    Xe === this && (Xe = null, Vn = null);
  }
  flush() {
    if (this.activate(), Ur.length > 0) {
      if (AW(), Xe !== null && Xe !== this)
        return;
    } else this.#e === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const t of this.#a) t(this);
    this.#a.clear();
  }
  #c() {
    if (this.#t === 0) {
      for (const t of this.#r) t();
      this.#r.clear();
    }
    this.#e === 0 && this.#f();
  }
  #f() {
    if (nm.size > 1) {
      this.previous.clear();
      var t = Vn, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const o of nm) {
        if (o === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [u, l] of this.current) {
          if (o.current.has(u))
            if (n && l !== o.current.get(u))
              o.current.set(u, l);
            else
              continue;
          s.push(u);
        }
        if (s.length === 0)
          continue;
        const i = [...o.current.keys()].filter((u) => !this.current.has(u));
        if (i.length > 0) {
          var a = Ur;
          Ur = [];
          const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            n4(c, i, u, l);
          if (Ur.length > 0) {
            Xe = o, o.apply();
            for (const c of Ur)
              o.#u(c, r);
            o.deactivate();
          }
          Ur = a;
        }
      }
      Xe = null, Vn = t;
    }
    this.committed = !0, nm.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(t) {
    this.#e += 1, t && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(t) {
    this.#e -= 1, t && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const t of this.#o)
      this.#s.delete(t), Rt(t, br), dl(t);
    for (const t of this.#s)
      Rt(t, Cr), dl(t);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(t) {
    this.#r.add(t);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(t) {
    this.#a.add(t);
  }
  settled() {
    return (this.#i ??= hW()).promise;
  }
  static ensure() {
    if (Xe === null) {
      const t = Xe = new ml();
      nm.add(Xe), ml.enqueue(() => {
        Xe === t && t.flush();
      });
    }
    return Xe;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    DW(t);
  }
  apply() {
  }
}
function AW() {
  var e = is;
  Oy = !0;
  try {
    var t = 0;
    for (Rd(!0); Ur.length > 0; ) {
      var n = ml.ensure();
      if (t++ > 1e3) {
        var r, a;
        LW();
      }
      n.process(Ur), io.clear();
    }
  } finally {
    Oy = !1, Rd(e), s0 = null;
  }
}
function LW() {
  try {
    vW();
  } catch (e) {
    t4(e, s0);
  }
}
let ca = null;
function v_(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (ss | Jm)) === 0 && Kc(r) && (ca = /* @__PURE__ */ new Set(), Vd(r), r.deps === null && r.first === null && r.nodes === null && (r.teardown === null && r.ac === null ? f4(r) : r.fn = null), ca?.size > 0)) {
        io.clear();
        for (const a of ca) {
          if ((a.f & (ss | Jm)) !== 0) continue;
          const o = [a];
          let s = a.parent;
          for (; s !== null; )
            ca.has(s) && (ca.delete(s), o.push(s)), s = s.parent;
          for (let i = o.length - 1; i >= 0; i--) {
            const u = o[i];
            (u.f & (ss | Jm)) === 0 && Vd(u);
          }
        }
        ca.clear();
      }
    }
    ca = null;
  }
}
function n4(e, t, n, r) {
  if (!n.has(e) && (n.add(e), e.reactions !== null))
    for (const a of e.reactions) {
      const o = a.f;
      (o & on) !== 0 ? n4(
        /** @type {Derived} */
        a,
        t,
        n,
        r
      ) : (o & (qU | vu)) !== 0 && (o & br) === 0 && r4(a, t, r) && (Rt(a, br), dl(
        /** @type {Effect} */
        a
      ));
    }
}
function r4(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (e.deps !== null)
    for (const a of e.deps) {
      if (t.includes(a))
        return !0;
      if ((a.f & on) !== 0 && r4(
        /** @type {Derived} */
        a,
        t,
        n
      ))
        return n.set(
          /** @type {Derived} */
          a,
          !0
        ), !0;
    }
  return n.set(e, !1), !1;
}
function dl(e) {
  for (var t = s0 = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (Oy && t === Ut && (n & vu) !== 0 && (n & zU) === 0)
      return;
    if ((n & (Mc | Gc)) !== 0) {
      if ((n & Tt) === 0) return;
      t.f ^= Tt;
    }
  }
  Ur.push(t);
}
function a4(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      u0(
        /** @type {Effect} */
        t[n]
      );
  }
}
function FW(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & on) === 0)
      return (t.f & ss) === 0 ? (
        /** @type {Effect} */
        t
      ) : null;
    t = t.parent;
  }
  return null;
}
function i0(e) {
  var t, n = Ut;
  $d(FW(e));
  try {
    e.f &= ~Ps, a4(e), t = b4(e);
  } finally {
    $d(n);
  }
  return t;
}
function o4(e) {
  var t = i0(e);
  if (e.equals(t) || (Xe?.is_fork || (e.v = t), e.wv = d4()), !Cc)
    if (Vn !== null)
      (Ud() || Xe?.is_fork) && Vn.set(e, t);
    else {
      var n = (e.f & Mr) === 0 ? Cr : Tt;
      Rt(e, n);
    }
}
let Sy = /* @__PURE__ */ new Set();
const io = /* @__PURE__ */ new Map();
let s4 = !1;
function UW(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: _W,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function Za(e, t) {
  const n = UW(e);
  return jW(n), n;
}
function Lo(e, t, n = !1) {
  ge !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Zo || (ge.f & E_) !== 0) && e4() && (ge.f & (on | vu | qU | E_)) !== 0 && !xa?.includes(e) && wW();
  let r = n ? pi(t) : t;
  return RW(e, r);
}
function RW(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    Cc ? io.set(e, t) : io.set(e, n), e.v = t;
    var r = ml.ensure();
    r.capture(e, n), (e.f & on) !== 0 && ((e.f & br) !== 0 && i0(
      /** @type {Derived} */
      e
    ), Rt(e, (e.f & Mr) !== 0 ? Tt : Cr)), e.wv = d4(), i4(e, br), Ut !== null && (Ut.f & Tt) !== 0 && (Ut.f & (Gc | Mc)) === 0 && (Sn === null ? BW([e]) : Sn.push(e)), !r.is_fork && Sy.size > 0 && !s4 && $W();
  }
  return t;
}
function $W() {
  s4 = !1;
  var e = is;
  Rd(!0);
  const t = Array.from(Sy);
  try {
    for (const n of t)
      (n.f & Tt) !== 0 && Rt(n, Cr), Kc(n) && Vd(n);
  } finally {
    Rd(e);
  }
  Sy.clear();
}
function Yg(e) {
  Lo(e, e.v + 1);
}
function i4(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, a = 0; a < r; a++) {
      var o = n[a], s = o.f, i = (s & br) === 0;
      if (i && Rt(o, t), (s & on) !== 0) {
        var u = (
          /** @type {Derived} */
          o
        );
        Vn?.delete(u), (s & Ps) === 0 && (s & Mr && (o.f |= Ps), i4(u, Cr));
      } else i && ((s & vu) !== 0 && ca !== null && ca.add(
        /** @type {Effect} */
        o
      ), dl(
        /** @type {Effect} */
        o
      ));
    }
}
function pi(e) {
  if (typeof e != "object" || e === null || xg in e)
    return e;
  const t = bW(e);
  if (t !== dW && t !== pW)
    return e;
  var n = /* @__PURE__ */ new Map(), r = fW(e), a = /* @__PURE__ */ Za(0), o = us, s = (i) => {
    if (us === o)
      return i();
    var u = ge, l = us;
    Bi(null), I_(o);
    var c = i();
    return Bi(u), I_(l), c;
  };
  return r && n.set("length", /* @__PURE__ */ Za(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(i, u, l) {
        (!("value" in l) || l.configurable === !1 || l.enumerable === !1 || l.writable === !1) && TW();
        var c = n.get(u);
        return c === void 0 ? c = s(() => {
          var f = /* @__PURE__ */ Za(l.value);
          return n.set(u, f), f;
        }) : Lo(c, l.value, !0), !0;
      },
      deleteProperty(i, u) {
        var l = n.get(u);
        if (l === void 0) {
          if (u in i) {
            const c = s(() => /* @__PURE__ */ Za(dt));
            n.set(u, c), Yg(a);
          }
        } else
          Lo(l, dt), Yg(a);
        return !0;
      },
      get(i, u, l) {
        if (u === xg)
          return e;
        var c = n.get(u), f = u in i;
        if (c === void 0 && (!f || Vg(i, u)?.writable) && (c = s(() => {
          var m = pi(f ? i[u] : dt), p = /* @__PURE__ */ Za(m);
          return p;
        }), n.set(u, c)), c !== void 0) {
          var d = rm(c);
          return d === dt ? void 0 : d;
        }
        return Reflect.get(i, u, l);
      },
      getOwnPropertyDescriptor(i, u) {
        var l = Reflect.getOwnPropertyDescriptor(i, u);
        if (l && "value" in l) {
          var c = n.get(u);
          c && (l.value = rm(c));
        } else if (l === void 0) {
          var f = n.get(u), d = f?.v;
          if (f !== void 0 && d !== dt)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return l;
      },
      has(i, u) {
        if (u === xg)
          return !0;
        var l = n.get(u), c = l !== void 0 && l.v !== dt || Reflect.has(i, u);
        if (l !== void 0 || Ut !== null && (!c || Vg(i, u)?.writable)) {
          l === void 0 && (l = s(() => {
            var d = c ? pi(i[u]) : dt, m = /* @__PURE__ */ Za(d);
            return m;
          }), n.set(u, l));
          var f = rm(l);
          if (f === dt)
            return !1;
        }
        return c;
      },
      set(i, u, l, c) {
        var f = n.get(u), d = u in i;
        if (r && u === "length")
          for (var m = l; m < /** @type {Source<number>} */
          f.v; m += 1) {
            var p = n.get(m + "");
            p !== void 0 ? Lo(p, dt) : m in i && (p = s(() => /* @__PURE__ */ Za(dt)), n.set(m + "", p));
          }
        if (f === void 0)
          (!d || Vg(i, u)?.writable) && (f = s(() => /* @__PURE__ */ Za(void 0)), Lo(f, pi(l)), n.set(u, f));
        else {
          d = f.v !== dt;
          var b = s(() => pi(l));
          Lo(f, b);
        }
        var g = Reflect.getOwnPropertyDescriptor(i, u);
        if (g?.set && g.set.call(c, l), !d) {
          if (r && typeof u == "string") {
            var S = (
              /** @type {Source<number>} */
              n.get("length")
            ), D = Number(u);
            Number.isInteger(D) && D >= S.v && Lo(S, D + 1);
          }
          Yg(a);
        }
        return !0;
      },
      ownKeys(i) {
        rm(a);
        var u = Reflect.ownKeys(i).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== dt;
        });
        for (var [l, c] of n)
          c.v !== dt && !(l in i) && u.push(l);
        return u;
      },
      setPrototypeOf() {
        IW();
      }
    }
  );
}
var PW;
// @__NO_SIDE_EFFECTS__
function VW(e) {
  return (
    /** @type {TemplateNode | null} */
    PW.call(e)
  );
}
function u4(e) {
  var t = ge, n = Ut;
  Bi(null), $d(null);
  try {
    return e();
  } finally {
    Bi(t), $d(n);
  }
}
function Ud() {
  return ge !== null && !Zo;
}
function l4(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = Cc, r = ge;
    T_(!0), Bi(null);
    try {
      t.call(null);
    } finally {
      T_(n), Bi(r);
    }
  }
}
function c4(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const a = n.ac;
    a !== null && u4(() => {
      a.abort(QU);
    });
    var r = n.next;
    (n.f & Mc) !== 0 ? n.parent = null : u0(n, t), n = r;
  }
}
function xW(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & Gc) === 0 && u0(t), t = n;
  }
}
function u0(e, t = !0) {
  var n = !1;
  (t || (e.f & zU) !== 0) && e.nodes !== null && e.nodes.end !== null && (YW(
    e.nodes.start,
    /** @type {TemplateNode} */
    e.nodes.end
  ), n = !0), c4(e, t && !n), Pd(e, 0), Rt(e, ss);
  var r = e.nodes && e.nodes.t;
  if (r !== null)
    for (const o of r)
      o.stop();
  l4(e);
  var a = e.parent;
  a !== null && a.first !== null && f4(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes = e.ac = null;
}
function YW(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : /* @__PURE__ */ VW(e);
    e.remove(), e = n;
  }
}
function f4(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
let is = !1;
function Rd(e) {
  is = e;
}
let Cc = !1;
function T_(e) {
  Cc = e;
}
let ge = null, Zo = !1;
function Bi(e) {
  ge = e;
}
let Ut = null;
function $d(e) {
  Ut = e;
}
let xa = null;
function jW(e) {
  ge !== null && (xa === null ? xa = [e] : xa.push(e));
}
let nt = null, gn = 0, Sn = null;
function BW(e) {
  Sn = e;
}
let m4 = 1, pl = 0, us = pl;
function I_(e) {
  us = e;
}
function d4() {
  return ++m4;
}
function Kc(e) {
  var t = e.f;
  if ((t & br) !== 0)
    return !0;
  if (t & on && (e.f &= ~Ps), (t & Cr) !== 0) {
    var n = e.deps;
    if (n !== null)
      for (var r = n.length, a = 0; a < r; a++) {
        var o = n[a];
        if (Kc(
          /** @type {Derived} */
          o
        ) && o4(
          /** @type {Derived} */
          o
        ), o.wv > e.wv)
          return !0;
      }
    (t & Mr) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Vn === null && Rt(e, Tt);
  }
  return !1;
}
function p4(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !xa?.includes(e))
    for (var a = 0; a < r.length; a++) {
      var o = r[a];
      (o.f & on) !== 0 ? p4(
        /** @type {Derived} */
        o,
        t,
        !1
      ) : t === o && (n ? Rt(o, br) : (o.f & Tt) !== 0 && Rt(o, Cr), dl(
        /** @type {Effect} */
        o
      ));
    }
}
function b4(e) {
  var t = nt, n = gn, r = Sn, a = ge, o = xa, s = Zo, i = us, u = e.f;
  nt = /** @type {null | Value[]} */
  null, gn = 0, Sn = null, ge = (u & (Gc | Mc)) === 0 ? e : null, xa = null, e.ctx, Zo = !1, us = ++pl, e.ac !== null && (u4(() => {
    e.ac.abort(QU);
  }), e.ac = null);
  try {
    e.f |= _y;
    var l = (
      /** @type {Function} */
      e.fn
    ), c = l(), f = e.deps;
    if (nt !== null) {
      var d;
      if (Pd(e, gn), f !== null && gn > 0)
        for (f.length = gn + nt.length, d = 0; d < nt.length; d++)
          f[gn + d] = nt[d];
      else
        e.deps = f = nt;
      if (Ud() && (e.f & Mr) !== 0)
        for (d = gn; d < f.length; d++)
          (f[d].reactions ??= []).push(e);
    } else f !== null && gn < f.length && (Pd(e, gn), f.length = gn);
    if (e4() && Sn !== null && !Zo && f !== null && (e.f & (on | Cr | br)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      Sn.length; d++)
        p4(
          Sn[d],
          /** @type {Effect} */
          e
        );
    return a !== null && a !== e && (pl++, Sn !== null && (r === null ? r = Sn : r.push(.../** @type {Source[]} */
    Sn))), (e.f & fl) !== 0 && (e.f ^= fl), c;
  } catch (m) {
    return kW(m);
  } finally {
    e.f ^= _y, nt = t, gn = n, Sn = r, ge = a, xa = o, Zo = s, us = i;
  }
}
function GW(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = mW.call(n, e);
    if (r !== -1) {
      var a = n.length - 1;
      a === 0 ? n = t.reactions = null : (n[r] = n[a], n.pop());
    }
  }
  n === null && (t.f & on) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (nt === null || !nt.includes(t)) && (Rt(t, Cr), (t.f & Mr) !== 0 && (t.f ^= Mr, t.f &= ~Ps), a4(
    /** @type {Derived} **/
    t
  ), Pd(
    /** @type {Derived} **/
    t,
    0
  ));
}
function Pd(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      GW(e, n[r]);
}
function Vd(e) {
  var t = e.f;
  if ((t & ss) === 0) {
    Rt(e, Tt);
    var n = Ut, r = is;
    Ut = e, is = !0;
    try {
      (t & (vu | NW)) !== 0 ? xW(e) : c4(e), l4(e);
      var a = b4(e);
      e.teardown = typeof a == "function" ? a : null, e.wv = m4;
      var o;
      cW && OW && (e.f & br) !== 0 && e.deps;
    } finally {
      is = r, Ut = n;
    }
  }
}
function rm(e) {
  var t = e.f, n = (t & on) !== 0;
  if (ge !== null && !Zo) {
    var r = Ut !== null && (Ut.f & ss) !== 0;
    if (!r && !xa?.includes(e)) {
      var a = ge.deps;
      if ((ge.f & _y) !== 0)
        e.rv < pl && (e.rv = pl, nt === null && a !== null && a[gn] === e ? gn++ : nt === null ? nt = [e] : nt.includes(e) || nt.push(e));
      else {
        (ge.deps ??= []).push(e);
        var o = e.reactions;
        o === null ? e.reactions = [ge] : o.includes(ge) || o.push(ge);
      }
    }
  }
  if (Cc) {
    if (io.has(e))
      return io.get(e);
    if (n) {
      var s = (
        /** @type {Derived} */
        e
      ), i = s.v;
      return ((s.f & Tt) === 0 && s.reactions !== null || h4(s)) && (i = i0(s)), io.set(s, i), i;
    }
  } else n && (!Vn?.has(e) || Xe?.is_fork && !Ud()) && (s = /** @type {Derived} */
  e, Kc(s) && o4(s), is && Ud() && (s.f & Mr) === 0 && g4(s));
  if (Vn?.has(e))
    return Vn.get(e);
  if ((e.f & fl) !== 0)
    throw e.v;
  return e.v;
}
function g4(e) {
  if (e.deps !== null) {
    e.f ^= Mr;
    for (const t of e.deps)
      (t.reactions ??= []).push(e), (t.f & on) !== 0 && (t.f & Mr) === 0 && g4(
        /** @type {Derived} */
        t
      );
  }
}
function h4(e) {
  if (e.v === dt) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (io.has(t) || (t.f & on) !== 0 && h4(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
const MW = -7169;
function Rt(e, t) {
  e.f = e.f & MW | t;
}
function y4() {
  return {
    isDark: document.documentElement.classList.contains("night-mode")
  };
}
const N4 = pi(y4()), CW = new MutationObserver((e, t) => {
  N4.isDark = y4().isDark;
});
CW.observe(document.documentElement, { attributeFilter: ["class"] });
const KW = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(KW);
var x;
(function(e) {
  e[e.Canceled = 1] = "Canceled", e[e.Unknown = 2] = "Unknown", e[e.InvalidArgument = 3] = "InvalidArgument", e[e.DeadlineExceeded = 4] = "DeadlineExceeded", e[e.NotFound = 5] = "NotFound", e[e.AlreadyExists = 6] = "AlreadyExists", e[e.PermissionDenied = 7] = "PermissionDenied", e[e.ResourceExhausted = 8] = "ResourceExhausted", e[e.FailedPrecondition = 9] = "FailedPrecondition", e[e.Aborted = 10] = "Aborted", e[e.OutOfRange = 11] = "OutOfRange", e[e.Unimplemented = 12] = "Unimplemented", e[e.Internal = 13] = "Internal", e[e.Unavailable = 14] = "Unavailable", e[e.DataLoss = 15] = "DataLoss", e[e.Unauthenticated = 16] = "Unauthenticated";
})(x || (x = {}));
function l0(e, t) {
  return e !== null && typeof e == "object" && "$typeName" in e && typeof e.$typeName == "string" ? t === void 0 ? !0 : t.typeName === e.$typeName : !1;
}
var N;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(N || (N = {}));
function XW() {
  let e = 0, t = 0;
  for (let r = 0; r < 28; r += 7) {
    let a = this.buf[this.pos++];
    if (e |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  let n = this.buf[this.pos++];
  if (e |= (n & 15) << 28, t = (n & 112) >> 4, (n & 128) == 0)
    return this.assertBounds(), [e, t];
  for (let r = 3; r <= 31; r += 7) {
    let a = this.buf[this.pos++];
    if (t |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  throw new Error("invalid varint");
}
function jg(e, t, n) {
  for (let o = 0; o < 28; o = o + 7) {
    const s = e >>> o, i = !(!(s >>> 7) && t == 0), u = (i ? s | 128 : s) & 255;
    if (n.push(u), !i)
      return;
  }
  const r = e >>> 28 & 15 | (t & 7) << 4, a = t >> 3 != 0;
  if (n.push((a ? r | 128 : r) & 255), !!a) {
    for (let o = 3; o < 31; o = o + 7) {
      const s = t >>> o, i = !!(s >>> 7), u = (i ? s | 128 : s) & 255;
      if (n.push(u), !i)
        return;
    }
    n.push(t >>> 31 & 1);
  }
}
const Zm = 4294967296;
function w_(e) {
  const t = e[0] === "-";
  t && (e = e.slice(1));
  const n = 1e6;
  let r = 0, a = 0;
  function o(s, i) {
    const u = Number(e.slice(s, i));
    a *= n, r = r * n + u, r >= Zm && (a = a + (r / Zm | 0), r = r % Zm);
  }
  return o(-24, -18), o(-18, -12), o(-12, -6), o(-6), t ? v4(r, a) : c0(r, a);
}
function WW(e, t) {
  let n = c0(e, t);
  const r = n.hi & 2147483648;
  r && (n = v4(n.lo, n.hi));
  const a = E4(n.lo, n.hi);
  return r ? "-" + a : a;
}
function E4(e, t) {
  if ({ lo: e, hi: t } = JW(e, t), t <= 2097151)
    return String(Zm * t + e);
  const n = e & 16777215, r = (e >>> 24 | t << 8) & 16777215, a = t >> 16 & 65535;
  let o = n + r * 6777216 + a * 6710656, s = r + a * 8147497, i = a * 2;
  const u = 1e7;
  return o >= u && (s += Math.floor(o / u), o %= u), s >= u && (i += Math.floor(s / u), s %= u), i.toString() + __(s) + __(o);
}
function JW(e, t) {
  return { lo: e >>> 0, hi: t >>> 0 };
}
function c0(e, t) {
  return { lo: e | 0, hi: t | 0 };
}
function v4(e, t) {
  return t = ~t, e ? e = ~e + 1 : t += 1, c0(e, t);
}
const __ = (e) => {
  const t = String(e);
  return "0000000".slice(t.length) + t;
};
function Dy(e, t) {
  if (e >= 0) {
    for (; e > 127; )
      t.push(e & 127 | 128), e = e >>> 7;
    t.push(e);
  } else {
    for (let n = 0; n < 9; n++)
      t.push(e & 127 | 128), e = e >> 7;
    t.push(1);
  }
}
function ZW() {
  let e = this.buf[this.pos++], t = e & 127;
  if ((e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 7, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 14, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 21, (e & 128) == 0)
    return this.assertBounds(), t;
  e = this.buf[this.pos++], t |= (e & 15) << 28;
  for (let n = 5; (e & 128) !== 0 && n < 10; n++)
    e = this.buf[this.pos++];
  if ((e & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
const J = /* @__PURE__ */ HW();
function HW() {
  const e = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof e.getBigInt64 == "function" && typeof e.getBigUint64 == "function" && typeof e.setBigInt64 == "function" && typeof e.setBigUint64 == "function" && (globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const t = BigInt("-9223372036854775808"), n = BigInt("9223372036854775807"), r = BigInt("0"), a = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > n || s < t)
          throw new Error(`invalid int64: ${o}`);
        return s;
      },
      uParse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > a || s < r)
          throw new Error(`invalid uint64: ${o}`);
        return s;
      },
      enc(o) {
        return e.setBigInt64(0, this.parse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      uEnc(o) {
        return e.setBigInt64(0, this.uParse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      dec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigInt64(0, !0);
      },
      uDec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigUint64(0, !0);
      }
    };
  }
  return {
    zero: "0",
    supported: !1,
    parse(t) {
      return typeof t != "string" && (t = t.toString()), O_(t), t;
    },
    uParse(t) {
      return typeof t != "string" && (t = t.toString()), S_(t), t;
    },
    enc(t) {
      return typeof t != "string" && (t = t.toString()), O_(t), w_(t);
    },
    uEnc(t) {
      return typeof t != "string" && (t = t.toString()), S_(t), w_(t);
    },
    dec(t, n) {
      return WW(t, n);
    },
    uDec(t, n) {
      return E4(t, n);
    }
  };
}
function O_(e) {
  if (!/^-?[0-9]+$/.test(e))
    throw new Error("invalid int64: " + e);
}
function S_(e) {
  if (!/^[0-9]+$/.test(e))
    throw new Error("invalid uint64: " + e);
}
function Vs(e, t) {
  switch (e) {
    case N.STRING:
      return "";
    case N.BOOL:
      return !1;
    case N.DOUBLE:
    case N.FLOAT:
      return 0;
    case N.INT64:
    case N.UINT64:
    case N.SFIXED64:
    case N.FIXED64:
    case N.SINT64:
      return t ? "0" : J.zero;
    case N.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function zW(e, t) {
  switch (e) {
    case N.BOOL:
      return t === !1;
    case N.STRING:
      return t === "";
    case N.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
const T4 = 2, ka = /* @__PURE__ */ Symbol.for("reflect unsafe local");
function I4(e, t) {
  const n = e[t.localName].case;
  return n === void 0 ? n : t.fields.find((r) => r.localName === n);
}
function qW(e, t) {
  const n = t.localName;
  if (t.oneof)
    return e[t.oneof.localName].case === n;
  if (t.presence != T4)
    return e[n] !== void 0 && Object.prototype.hasOwnProperty.call(e, n);
  switch (t.fieldKind) {
    case "list":
      return e[n].length > 0;
    case "map":
      return Object.keys(e[n]).length > 0;
    case "scalar":
      return !zW(t.scalar, e[n]);
    case "enum":
      return e[n] !== t.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function bl(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) && e[t] !== void 0;
}
function w4(e, t) {
  if (t.oneof) {
    const n = e[t.oneof.localName];
    return n.case === t.localName ? n.value : void 0;
  }
  return e[t.localName];
}
function _4(e, t, n) {
  t.oneof ? e[t.oneof.localName] = {
    case: t.localName,
    value: n
  } : e[t.localName] = n;
}
function QW(e, t) {
  const n = t.localName;
  if (t.oneof) {
    const r = t.oneof.localName;
    e[r].case === n && (e[r] = { case: void 0 });
  } else if (t.presence != T4)
    delete e[n];
  else
    switch (t.fieldKind) {
      case "map":
        e[n] = {};
        break;
      case "list":
        e[n] = [];
        break;
      case "enum":
        e[n] = t.enum.values[0].number;
        break;
      case "scalar":
        e[n] = Vs(t.scalar, t.longAsString);
        break;
    }
}
function Eo(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function f0(e, t) {
  var n, r, a, o;
  if (Eo(e) && ka in e && "add" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.listKind == i.listKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function m0(e, t) {
  var n, r, a, o;
  if (Eo(e) && ka in e && "has" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.mapKey === i.mapKey && s.mapKind == i.mapKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function d0(e, t) {
  return Eo(e) && ka in e && "desc" in e && Eo(e.desc) && e.desc.kind === "message" && (t === void 0 || e.desc.typeName == t.typeName);
}
function eJ(e) {
  return O4(e.$typeName);
}
function Xc(e) {
  const t = e.fields[0];
  return O4(e.typeName) && t !== void 0 && t.fieldKind == "scalar" && t.name == "value" && t.number == 1;
}
function O4(e) {
  return e.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(e.substring(16));
}
const tJ = 999, nJ = 998, Hm = 2;
function gr(e, t) {
  if (l0(t, e))
    return t;
  const n = iJ(e);
  return t !== void 0 && rJ(e, n, t), n;
}
function rJ(e, t, n) {
  for (const r of e.members) {
    let a = n[r.localName];
    if (a == null)
      continue;
    let o;
    if (r.kind == "oneof") {
      const s = I4(n, r);
      if (!s)
        continue;
      o = s, a = w4(n, s);
    } else
      o = r;
    switch (o.fieldKind) {
      case "message":
        a = p0(o, a);
        break;
      case "scalar":
        a = S4(o, a);
        break;
      case "list":
        a = oJ(o, a);
        break;
      case "map":
        a = aJ(o, a);
        break;
    }
    _4(t, o, a);
  }
  return t;
}
function S4(e, t) {
  return e.scalar == N.BYTES ? b0(t) : t;
}
function aJ(e, t) {
  if (Eo(t)) {
    if (e.scalar == N.BYTES)
      return D_(t, b0);
    if (e.mapKind == "message")
      return D_(t, (n) => p0(e, n));
  }
  return t;
}
function oJ(e, t) {
  if (Array.isArray(t)) {
    if (e.scalar == N.BYTES)
      return t.map(b0);
    if (e.listKind == "message")
      return t.map((n) => p0(e, n));
  }
  return t;
}
function p0(e, t) {
  if (e.fieldKind == "message" && !e.oneof && Xc(e.message))
    return S4(e.message.fields[0], t);
  if (Eo(t)) {
    if (e.message.typeName == "google.protobuf.Struct" && e.parent.typeName !== "google.protobuf.Value")
      return t;
    if (!l0(t, e.message))
      return gr(e.message, t);
  }
  return t;
}
function b0(e) {
  return Array.isArray(e) ? new Uint8Array(e) : e;
}
function D_(e, t) {
  const n = {};
  for (const r of Object.entries(e))
    n[r[0]] = t(r[1]);
  return n;
}
const sJ = /* @__PURE__ */ Symbol(), k_ = /* @__PURE__ */ new WeakMap();
function iJ(e) {
  let t;
  if (uJ(e)) {
    const n = k_.get(e);
    let r, a;
    if (n)
      ({ prototype: r, members: a } = n);
    else {
      r = {}, a = /* @__PURE__ */ new Set();
      for (const o of e.members)
        o.kind != "oneof" && (o.fieldKind != "scalar" && o.fieldKind != "enum" || o.presence != Hm && (a.add(o), r[o.localName] = Bg(o)));
      k_.set(e, { prototype: r, members: a });
    }
    t = Object.create(r), t.$typeName = e.typeName;
    for (const o of e.members)
      a.has(o) || o.kind == "field" && (o.fieldKind == "message" || (o.fieldKind == "scalar" || o.fieldKind == "enum") && o.presence != Hm) || (t[o.localName] = Bg(o));
  } else {
    t = {
      $typeName: e.typeName
    };
    for (const n of e.members)
      (n.kind == "oneof" || n.presence == Hm) && (t[n.localName] = Bg(n));
  }
  return t;
}
function uJ(e) {
  switch (e.file.edition) {
    case tJ:
      return !1;
    case nJ:
      return !0;
    default:
      return e.fields.some((t) => t.presence != Hm && t.fieldKind != "message" && !t.oneof);
  }
}
function Bg(e) {
  if (e.kind == "oneof")
    return { case: void 0 };
  if (e.fieldKind == "list")
    return [];
  if (e.fieldKind == "map")
    return {};
  if (e.fieldKind == "message")
    return sJ;
  const t = e.getDefaultValue();
  return t !== void 0 ? e.fieldKind == "scalar" && e.longAsString ? t.toString() : t : e.fieldKind == "scalar" ? Vs(e.scalar, e.longAsString) : e.enum.values[0].number;
}
const lJ = [
  "FieldValueInvalidError",
  "FieldListRangeError",
  "ForeignFieldError"
];
class $t extends Error {
  constructor(t, n, r = "FieldValueInvalidError") {
    super(n), this.name = r, this.field = () => t;
  }
}
function cJ(e) {
  return e instanceof Error && lJ.includes(e.name) && "field" in e && typeof e.field == "function";
}
const Gg = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
function g0() {
  if (globalThis[Gg] == null) {
    const e = new globalThis.TextEncoder(), t = new globalThis.TextDecoder();
    globalThis[Gg] = {
      encodeUtf8(n) {
        return e.encode(n);
      },
      decodeUtf8(n) {
        return t.decode(n);
      },
      checkUtf8(n) {
        try {
          return encodeURIComponent(n), !0;
        } catch {
          return !1;
        }
      }
    };
  }
  return globalThis[Gg];
}
var se;
(function(e) {
  e[e.Varint = 0] = "Varint", e[e.Bit64 = 1] = "Bit64", e[e.LengthDelimited = 2] = "LengthDelimited", e[e.StartGroup = 3] = "StartGroup", e[e.EndGroup = 4] = "EndGroup", e[e.Bit32 = 5] = "Bit32";
})(se || (se = {}));
const D4 = 34028234663852886e22, k4 = -34028234663852886e22, A4 = 4294967295, L4 = 2147483647, F4 = -2147483648;
class U4 {
  constructor(t = g0().encodeUtf8) {
    this.encodeUtf8 = t, this.stack = [], this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []);
    let t = 0;
    for (let a = 0; a < this.chunks.length; a++)
      t += this.chunks[a].length;
    let n = new Uint8Array(t), r = 0;
    for (let a = 0; a < this.chunks.length; a++)
      n.set(this.chunks[a], r), r += this.chunks[a].length;
    return this.chunks = [], n;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), n = this.stack.pop();
    if (!n)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = n.chunks, this.buf = n.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, n) {
    return this.uint32((t << 3 | n) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (A_(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return Mg(t), Dy(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let n = this.encodeUtf8(t);
    return this.uint32(n.byteLength), this.raw(n);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    fJ(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setFloat32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let n = new Uint8Array(8);
    return new DataView(n.buffer).setFloat64(0, t, !0), this.raw(n);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    A_(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    Mg(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setInt32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return Mg(t), t = (t << 1 ^ t >> 31) >>> 0, Dy(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = J.enc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = J.uEnc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let n = J.enc(t);
    return jg(n.lo, n.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    const n = J.enc(t), r = n.hi >> 31, a = n.lo << 1 ^ r, o = (n.hi << 1 | n.lo >>> 31) ^ r;
    return jg(a, o, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    const n = J.uEnc(t);
    return jg(n.lo, n.hi, this.buf), this;
  }
}
class h0 {
  constructor(t, n = g0().decodeUtf8) {
    this.decodeUtf8 = n, this.varint64 = XW, this.uint32 = ZW, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), n = t >>> 3, r = t & 7;
    if (n <= 0 || r < 0 || r > 5)
      throw new Error("illegal tag: field no " + n + " wire type " + r);
    return [n, r];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, n) {
    let r = this.pos;
    switch (t) {
      case se.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case se.Bit64:
        this.pos += 4;
      case se.Bit32:
        this.pos += 4;
        break;
      case se.LengthDelimited:
        let a = this.uint32();
        this.pos += a;
        break;
      case se.StartGroup:
        for (; ; ) {
          const [o, s] = this.tag();
          if (s === se.EndGroup) {
            if (n !== void 0 && o !== n)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(s, o);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return J.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return J.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, n] = this.varint64(), r = -(t & 1);
    return t = (t >>> 1 | (n & 1) << 31) ^ r, n = n >>> 1 ^ r, J.dec(t, n);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, n] = this.varint64();
    return t !== 0 || n !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return J.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return J.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), n = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(n, n + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function Mg(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid int32: " + typeof e);
  if (!Number.isInteger(e) || e > L4 || e < F4)
    throw new Error("invalid int32: " + e);
}
function A_(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid uint32: " + typeof e);
  if (!Number.isInteger(e) || e > A4 || e < 0)
    throw new Error("invalid uint32: " + e);
}
function fJ(e) {
  if (typeof e == "string") {
    const t = e;
    if (e = Number(e), Number.isNaN(e) && t !== "NaN")
      throw new Error("invalid float32: " + t);
  } else if (typeof e != "number")
    throw new Error("invalid float32: " + typeof e);
  if (Number.isFinite(e) && (e > D4 || e < k4))
    throw new Error("invalid float32: " + e);
}
function Fo(e, t) {
  const n = e.fieldKind == "list" ? f0(t, e) : e.fieldKind == "map" ? m0(t, e) : y0(e, t);
  if (n === !0)
    return;
  let r;
  switch (e.fieldKind) {
    case "list":
      r = `expected ${P4(e)}, got ${Pe(t)}`;
      break;
    case "map":
      r = `expected ${V4(e)}, got ${Pe(t)}`;
      break;
    default:
      r = xd(e, t, n);
  }
  return new $t(e, r);
}
function L_(e, t, n) {
  const r = y0(e, n);
  if (r !== !0)
    return new $t(e, `list item #${t + 1}: ${xd(e, n, r)}`);
}
function mJ(e, t, n) {
  const r = R4(t, e.mapKey);
  if (r !== !0)
    return new $t(e, `invalid map key: ${xd({ scalar: e.mapKey }, t, r)}`);
  const a = y0(e, n);
  if (a !== !0)
    return new $t(e, `map entry ${Pe(t)}: ${xd(e, n, a)}`);
}
function y0(e, t) {
  return e.scalar !== void 0 ? R4(t, e.scalar) : e.enum !== void 0 ? e.enum.open ? Number.isInteger(t) : e.enum.values.some((n) => n.number === t) : d0(t, e.message);
}
function R4(e, t) {
  switch (t) {
    case N.DOUBLE:
      return typeof e == "number";
    case N.FLOAT:
      return typeof e != "number" ? !1 : Number.isNaN(e) || !Number.isFinite(e) ? !0 : e > D4 || e < k4 ? `${e.toFixed()} out of range` : !0;
    case N.INT32:
    case N.SFIXED32:
    case N.SINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > L4 || e < F4 ? `${e.toFixed()} out of range` : !0;
    case N.FIXED32:
    case N.UINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > A4 || e < 0 ? `${e.toFixed()} out of range` : !0;
    case N.BOOL:
      return typeof e == "boolean";
    case N.STRING:
      return typeof e != "string" ? !1 : g0().checkUtf8(e) || "invalid UTF8";
    case N.BYTES:
      return e instanceof Uint8Array;
    case N.INT64:
    case N.SFIXED64:
    case N.SINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return J.parse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
    case N.FIXED64:
    case N.UINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return J.uParse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
  }
}
function xd(e, t, n) {
  return n = typeof n == "string" ? `: ${n}` : `, got ${Pe(t)}`, e.scalar !== void 0 ? `expected ${dJ(e.scalar)}` + n : e.enum !== void 0 ? `expected ${e.enum.toString()}` + n : `expected ${$4(e.message)}` + n;
}
function Pe(e) {
  switch (typeof e) {
    case "object":
      return e === null ? "null" : e instanceof Uint8Array ? `Uint8Array(${e.length})` : Array.isArray(e) ? `Array(${e.length})` : f0(e) ? P4(e.field()) : m0(e) ? V4(e.field()) : d0(e) ? $4(e.desc) : l0(e) ? `message ${e.$typeName}` : "object";
    case "string":
      return e.length > 30 ? "string" : `"${e.split('"').join('\\"')}"`;
    case "boolean":
      return String(e);
    case "number":
      return String(e);
    case "bigint":
      return String(e) + "n";
    default:
      return typeof e;
  }
}
function $4(e) {
  return `ReflectMessage (${e.typeName})`;
}
function P4(e) {
  switch (e.listKind) {
    case "message":
      return `ReflectList (${e.message.toString()})`;
    case "enum":
      return `ReflectList (${e.enum.toString()})`;
    case "scalar":
      return `ReflectList (${N[e.scalar]})`;
  }
}
function V4(e) {
  switch (e.mapKind) {
    case "message":
      return `ReflectMap (${N[e.mapKey]}, ${e.message.toString()})`;
    case "enum":
      return `ReflectMap (${N[e.mapKey]}, ${e.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${N[e.mapKey]}, ${N[e.scalar]})`;
  }
}
function dJ(e) {
  switch (e) {
    case N.STRING:
      return "string";
    case N.BOOL:
      return "boolean";
    case N.INT64:
    case N.SINT64:
    case N.SFIXED64:
      return "bigint (int64)";
    case N.UINT64:
    case N.FIXED64:
      return "bigint (uint64)";
    case N.BYTES:
      return "Uint8Array";
    case N.DOUBLE:
      return "number (float64)";
    case N.FLOAT:
      return "number (float32)";
    case N.FIXED32:
    case N.UINT32:
      return "number (uint32)";
    case N.INT32:
    case N.SFIXED32:
    case N.SINT32:
      return "number (int32)";
  }
}
function Jn(e, t, n = !0) {
  return new x4(e, t, n);
}
const F_ = /* @__PURE__ */ new WeakMap();
class x4 {
  get sortedFields() {
    const t = F_.get(this.desc);
    if (t)
      return t;
    const n = this.desc.fields.concat().sort((r, a) => r.number - a.number);
    return F_.set(this.desc, n), n;
  }
  constructor(t, n, r = !0) {
    this.lists = /* @__PURE__ */ new Map(), this.maps = /* @__PURE__ */ new Map(), this.check = r, this.desc = t, this.message = this[ka] = n ?? gr(t), this.fields = t.fields, this.oneofs = t.oneofs, this.members = t.members;
  }
  findNumber(t) {
    return this._fieldsByNumber || (this._fieldsByNumber = new Map(this.desc.fields.map((n) => [n.number, n]))), this._fieldsByNumber.get(t);
  }
  oneofCase(t) {
    return Fu(this.message, t), I4(this.message, t);
  }
  isSet(t) {
    return Fu(this.message, t), qW(this.message, t);
  }
  clear(t) {
    Fu(this.message, t), QW(this.message, t);
  }
  get(t) {
    Fu(this.message, t);
    const n = w4(this.message, t);
    switch (t.fieldKind) {
      case "list":
        let r = this.lists.get(t);
        return (!r || r[ka] !== n) && this.lists.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          r = new pJ(t, n, this.check)
        ), r;
      case "map":
        let a = this.maps.get(t);
        return (!a || a[ka] !== n) && this.maps.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = new bJ(t, n, this.check)
        ), a;
      case "message":
        return E0(t, n, this.check);
      case "scalar":
        return n === void 0 ? Vs(t.scalar, !1) : v0(t, n);
      case "enum":
        return n ?? t.enum.values[0].number;
    }
  }
  set(t, n) {
    if (Fu(this.message, t), this.check) {
      const a = Fo(t, n);
      if (a)
        throw a;
    }
    let r;
    t.fieldKind == "message" ? r = N0(t, n) : m0(n) || f0(n) ? r = n[ka] : r = T0(t, n), _4(this.message, t, r);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(t) {
    this.message.$unknown = t;
  }
}
function Fu(e, t) {
  if (t.parent.typeName !== e.$typeName)
    throw new $t(t, `cannot use ${t.toString()} with message ${e.$typeName}`, "ForeignFieldError");
}
class pJ {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(t, n, r) {
    this._field = t, this._arr = this[ka] = n, this.check = r;
  }
  get(t) {
    const n = this._arr[t];
    return n === void 0 ? void 0 : Cg(this._field, n, this.check);
  }
  set(t, n) {
    if (t < 0 || t >= this._arr.length)
      throw new $t(this._field, `list item #${t + 1}: out of range`);
    if (this.check) {
      const r = L_(this._field, t, n);
      if (r)
        throw r;
    }
    this._arr[t] = U_(this._field, n);
  }
  add(t) {
    if (this.check) {
      const n = L_(this._field, this._arr.length, t);
      if (n)
        throw n;
    }
    this._arr.push(U_(this._field, t));
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const t of this._arr)
      yield Cg(this._field, t, this.check);
  }
  *entries() {
    for (let t = 0; t < this._arr.length; t++)
      yield [t, Cg(this._field, this._arr[t], this.check)];
  }
}
class bJ {
  constructor(t, n, r = !0) {
    this.obj = this[ka] = n ?? {}, this.check = r, this._field = t;
  }
  field() {
    return this._field;
  }
  set(t, n) {
    if (this.check) {
      const r = mJ(this._field, t, n);
      if (r)
        throw r;
    }
    return this.obj[am(t)] = gJ(this._field, n), this;
  }
  delete(t) {
    const n = am(t), r = Object.prototype.hasOwnProperty.call(this.obj, n);
    return r && delete this.obj[n], r;
  }
  clear() {
    for (const t of Object.keys(this.obj))
      delete this.obj[t];
  }
  get(t) {
    let n = this.obj[am(t)];
    return n !== void 0 && (n = Kg(this._field, n, this.check)), n;
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.obj, am(t));
  }
  *keys() {
    for (const t of Object.keys(this.obj))
      yield R_(t, this._field.mapKey);
  }
  *entries() {
    for (const t of Object.entries(this.obj))
      yield [
        R_(t[0], this._field.mapKey),
        Kg(this._field, t[1], this.check)
      ];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const t of Object.values(this.obj))
      yield Kg(this._field, t, this.check);
  }
  forEach(t, n) {
    for (const r of this.entries())
      t.call(n, r[1], r[0], this);
  }
}
function N0(e, t) {
  return d0(t) ? eJ(t.message) && !e.oneof && e.fieldKind == "message" ? t.message.value : t.desc.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" ? j4(t.message) : t.message : t;
}
function E0(e, t, n) {
  return t !== void 0 && (Xc(e.message) && !e.oneof && e.fieldKind == "message" ? t = {
    $typeName: e.message.typeName,
    value: v0(e.message.fields[0], t)
  } : e.message.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" && Eo(t) && (t = Y4(t))), new x4(e.message, t, n);
}
function U_(e, t) {
  return e.listKind == "message" ? N0(e, t) : T0(e, t);
}
function Cg(e, t, n) {
  return e.listKind == "message" ? E0(e, t, n) : v0(e, t);
}
function gJ(e, t) {
  return e.mapKind == "message" ? N0(e, t) : T0(e, t);
}
function Kg(e, t, n) {
  return e.mapKind == "message" ? E0(e, t, n) : t;
}
function am(e) {
  return typeof e == "string" || typeof e == "number" ? e : String(e);
}
function R_(e, t) {
  switch (t) {
    case N.STRING:
      return e;
    case N.INT32:
    case N.FIXED32:
    case N.UINT32:
    case N.SFIXED32:
    case N.SINT32: {
      const n = Number.parseInt(e);
      if (Number.isFinite(n))
        return n;
      break;
    }
    case N.BOOL:
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      break;
    case N.UINT64:
    case N.FIXED64:
      try {
        return J.uParse(e);
      } catch {
      }
      break;
    default:
      try {
        return J.parse(e);
      } catch {
      }
      break;
  }
  return e;
}
function v0(e, t) {
  switch (e.scalar) {
    case N.INT64:
    case N.SFIXED64:
    case N.SINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = J.parse(t));
      break;
    case N.FIXED64:
    case N.UINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = J.uParse(t));
      break;
  }
  return t;
}
function T0(e, t) {
  switch (e.scalar) {
    case N.INT64:
    case N.SFIXED64:
    case N.SINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = J.parse(t));
      break;
    case N.FIXED64:
    case N.UINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = J.uParse(t));
      break;
  }
  return t;
}
function Y4(e) {
  const t = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (Eo(e))
    for (const [n, r] of Object.entries(e))
      t.fields[n] = G4(r);
  return t;
}
function j4(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = B4(r);
  return t;
}
function B4(e) {
  switch (e.kind.case) {
    case "structValue":
      return j4(e.kind.value);
    case "listValue":
      return e.kind.value.values.map(B4);
    case "nullValue":
    case void 0:
      return null;
    default:
      return e.kind.value;
  }
}
function G4(e) {
  const t = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof e) {
    case "number":
      t.kind = { case: "numberValue", value: e };
      break;
    case "string":
      t.kind = { case: "stringValue", value: e };
      break;
    case "boolean":
      t.kind = { case: "boolValue", value: e };
      break;
    case "object":
      if (e === null)
        t.kind = { case: "nullValue", value: 0 };
      else if (Array.isArray(e)) {
        const n = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(e))
          for (const r of e)
            n.values.push(G4(r));
        t.kind = {
          case: "listValue",
          value: n
        };
      } else
        t.kind = {
          case: "structValue",
          value: Y4(e)
        };
      break;
  }
  return t;
}
function I0(e) {
  const t = hJ();
  let n = e.length * 3 / 4;
  e[e.length - 2] == "=" ? n -= 2 : e[e.length - 1] == "=" && (n -= 1);
  let r = new Uint8Array(n), a = 0, o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++) {
    if (s = t[e.charCodeAt(u)], s === void 0)
      switch (e[u]) {
        // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
        case "=":
          o = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string");
      }
    switch (o) {
      case 0:
        i = s, o = 1;
        break;
      case 1:
        r[a++] = i << 2 | (s & 48) >> 4, i = s, o = 2;
        break;
      case 2:
        r[a++] = (i & 15) << 4 | (s & 60) >> 2, i = s, o = 3;
        break;
      case 3:
        r[a++] = (i & 3) << 6 | s, o = 0;
        break;
    }
  }
  if (o == 1)
    throw Error("invalid base64 string");
  return r.subarray(0, a);
}
function M4(e, t = "std") {
  const n = C4(t), r = t == "std";
  let a = "", o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++)
    switch (s = e[u], o) {
      case 0:
        a += n[s >> 2], i = (s & 3) << 4, o = 1;
        break;
      case 1:
        a += n[i | s >> 4], i = (s & 15) << 2, o = 2;
        break;
      case 2:
        a += n[i | s >> 6], a += n[s & 63], o = 0;
        break;
    }
  return o && (a += n[i], r && (a += "=", o == 1 && (a += "="))), a;
}
let om, $_, ni;
function C4(e) {
  return om || (om = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), $_ = om.slice(0, -2).concat("-", "_")), e == "url" ? (
    // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
    $_
  ) : om;
}
function hJ() {
  if (!ni) {
    ni = [];
    const e = C4("std");
    for (let t = 0; t < e.length; t++)
      ni[e[t].charCodeAt(0)] = t;
    ni[45] = e.indexOf("+"), ni[95] = e.indexOf("/");
  }
  return ni;
}
function gl(e) {
  let t = !1;
  const n = [];
  for (let r = 0; r < e.length; r++) {
    let a = e.charAt(r);
    switch (a) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        n.push(a), t = !1;
        break;
      default:
        t && (t = !1, a = a.toUpperCase()), n.push(a);
        break;
    }
  }
  return n.join("");
}
const yJ = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function hl(e) {
  return yJ.has(e) ? e + "$" : e;
}
function w0(e) {
  for (const t of e.field)
    bl(t, "jsonName") || (t.jsonName = gl(t.name));
  e.nestedType.forEach(w0);
}
function NJ(e, t) {
  const n = e.values.find((r) => r.name === t);
  if (!n)
    throw new Error(`cannot parse ${e} default value: ${t}`);
  return n.number;
}
function EJ(e, t) {
  switch (e) {
    case N.STRING:
      return t;
    case N.BYTES: {
      const n = vJ(t);
      if (n === !1)
        throw new Error(`cannot parse ${N[e]} default value: ${t}`);
      return n;
    }
    case N.INT64:
    case N.SFIXED64:
    case N.SINT64:
      return J.parse(t);
    case N.UINT64:
    case N.FIXED64:
      return J.uParse(t);
    case N.DOUBLE:
    case N.FLOAT:
      switch (t) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(t);
      }
    case N.BOOL:
      return t === "true";
    case N.INT32:
    case N.UINT32:
    case N.SINT32:
    case N.FIXED32:
    case N.SFIXED32:
      return parseInt(t, 10);
  }
}
function vJ(e) {
  const t = [], n = {
    tail: e,
    c: "",
    next() {
      return this.tail.length == 0 ? !1 : (this.c = this.tail[0], this.tail = this.tail.substring(1), !0);
    },
    take(r) {
      if (this.tail.length >= r) {
        const a = this.tail.substring(0, r);
        return this.tail = this.tail.substring(r), a;
      }
      return !1;
    }
  };
  for (; n.next(); )
    switch (n.c) {
      case "\\":
        if (n.next())
          switch (n.c) {
            case "\\":
              t.push(n.c.charCodeAt(0));
              break;
            case "b":
              t.push(8);
              break;
            case "f":
              t.push(12);
              break;
            case "n":
              t.push(10);
              break;
            case "r":
              t.push(13);
              break;
            case "t":
              t.push(9);
              break;
            case "v":
              t.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 8);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "x": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "u": {
              const r = n.c, a = n.take(4);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              const s = new Uint8Array(4);
              new DataView(s.buffer).setInt32(0, o, !0), t.push(s[0], s[1], s[2], s[3]);
              break;
            }
            case "U": {
              const r = n.c, a = n.take(8);
              if (a === !1)
                return !1;
              const o = J.uEnc(r + a), s = new Uint8Array(8), i = new DataView(s.buffer);
              i.setInt32(0, o.lo, !0), i.setInt32(4, o.hi, !0), t.push(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
              break;
            }
          }
        break;
      default:
        t.push(n.c.charCodeAt(0));
    }
  return new Uint8Array(t);
}
function* ky(e) {
  switch (e.kind) {
    case "file":
      for (const t of e.messages)
        yield t, yield* ky(t);
      yield* e.enums, yield* e.services, yield* e.extensions;
      break;
    case "message":
      for (const t of e.nestedMessages)
        yield t, yield* ky(t);
      yield* e.nestedEnums, yield* e.nestedExtensions;
      break;
  }
}
function K4(...e) {
  const t = TJ();
  if (!e.length)
    return t;
  if ("$typeName" in e[0] && e[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const n of e[0].file)
      j_(n, t);
    return t;
  }
  if ("$typeName" in e[0]) {
    let n = function(s) {
      const i = [];
      for (const u of s.dependency) {
        if (t.getFile(u) != null || o.has(u))
          continue;
        const l = a(u);
        if (!l)
          throw new Error(`Unable to resolve ${u}, imported by ${s.name}`);
        "kind" in l ? t.addFile(l, !1, !0) : (o.add(l.name), i.push(l));
      }
      return i.concat(...i.map(n));
    };
    const r = e[0], a = e[1], o = /* @__PURE__ */ new Set();
    for (const s of [r, ...n(r)].reverse())
      j_(s, t);
  } else
    for (const n of e)
      for (const r of n.files)
        t.addFile(r);
  return t;
}
function TJ() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    kind: "registry",
    types: e,
    extendees: t,
    [Symbol.iterator]() {
      return e.values();
    },
    get files() {
      return n.values();
    },
    addFile(r, a, o) {
      if (n.set(r.proto.name, r), !a)
        for (const s of ky(r))
          this.add(s);
      if (o)
        for (const s of r.dependencies)
          this.addFile(s, a, o);
    },
    add(r) {
      if (r.kind == "extension") {
        let a = t.get(r.extendee.typeName);
        a || t.set(
          r.extendee.typeName,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = /* @__PURE__ */ new Map()
        ), a.set(r.number, r);
      }
      e.set(r.typeName, r);
    },
    get(r) {
      return e.get(r);
    },
    getFile(r) {
      return n.get(r);
    },
    getMessage(r) {
      const a = e.get(r);
      return a?.kind == "message" ? a : void 0;
    },
    getEnum(r) {
      const a = e.get(r);
      return a?.kind == "enum" ? a : void 0;
    },
    getExtension(r) {
      const a = e.get(r);
      return a?.kind == "extension" ? a : void 0;
    },
    getExtensionFor(r, a) {
      var o;
      return (o = t.get(r.typeName)) === null || o === void 0 ? void 0 : o.get(a);
    },
    getService(r) {
      const a = e.get(r);
      return a?.kind == "service" ? a : void 0;
    }
  };
}
const IJ = 998, wJ = 999, _J = 9, yl = 10, Mu = 11, OJ = 12, P_ = 14, _0 = 3, SJ = 2, V_ = 1, DJ = 0, x_ = 1, Y_ = 2, kJ = 3, AJ = 1, LJ = 2, FJ = 1, X4 = {
  // EDITION_PROTO2
  998: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 2,
    // CLOSED,
    repeatedFieldEncoding: 2,
    // EXPANDED,
    utf8Validation: 3,
    // NONE,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 2,
    // LEGACY_BEST_EFFORT,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_PROTO3
  999: {
    fieldPresence: 2,
    // IMPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2023
  1e3: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2024
  1001: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 1,
    // STYLE2024,
    defaultSymbolVisibility: 2
    // EXPORT_TOP_LEVEL,
  }
};
function j_(e, t) {
  var n, r;
  const a = {
    kind: "file",
    proto: e,
    deprecated: (r = (n = e.options) === null || n === void 0 ? void 0 : n.deprecated) !== null && r !== void 0 ? r : !1,
    edition: PJ(e),
    name: e.name.replace(/\.proto$/, ""),
    dependencies: VJ(e, t),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${e.name}`;
    }
  }, o = /* @__PURE__ */ new Map(), s = {
    get(i) {
      return o.get(i);
    },
    add(i) {
      var u;
      ar(((u = i.proto.options) === null || u === void 0 ? void 0 : u.mapEntry) === !0), o.set(i.typeName, i);
    }
  };
  for (const i of e.enumType)
    W4(i, a, void 0, t);
  for (const i of e.messageType)
    J4(i, a, void 0, t, s);
  for (const i of e.service)
    UJ(i, a, t);
  Ay(a, t);
  for (const i of o.values())
    Ly(i, t, s);
  for (const i of a.messages)
    Ly(i, t, s), Ay(i, t);
  t.addFile(a, !0);
}
function Ay(e, t) {
  switch (e.kind) {
    case "file":
      for (const n of e.proto.extension) {
        const r = Fy(n, e, t);
        e.extensions.push(r), t.add(r);
      }
      break;
    case "message":
      for (const n of e.proto.extension) {
        const r = Fy(n, e, t);
        e.nestedExtensions.push(r), t.add(r);
      }
      for (const n of e.nestedMessages)
        Ay(n, t);
      break;
  }
}
function Ly(e, t, n) {
  const r = e.proto.oneofDecl.map((o) => $J(o, e)), a = /* @__PURE__ */ new Set();
  for (const o of e.proto.field) {
    const s = jJ(o, r), i = Fy(o, e, t, s, n);
    e.fields.push(i), e.field[i.localName] = i, s === void 0 ? e.members.push(i) : (s.fields.push(i), a.has(s) || (a.add(s), e.members.push(s)));
  }
  for (const o of r.filter((s) => a.has(s)))
    e.oneofs.push(o);
  for (const o of e.nestedMessages)
    Ly(o, t, n);
}
function W4(e, t, n, r) {
  var a, o, s, i, u;
  const l = xJ(e.name, e.value), c = {
    kind: "enum",
    proto: e,
    deprecated: (o = (a = e.options) === null || a === void 0 ? void 0 : a.deprecated) !== null && o !== void 0 ? o : !1,
    file: t,
    parent: n,
    open: !0,
    name: e.name,
    typeName: yb(e, n, t),
    value: {},
    values: [],
    sharedPrefix: l,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  c.open = CJ(c), r.add(c);
  for (const f of e.value) {
    const d = f.name;
    c.values.push(
      // biome-ignore lint/suspicious/noAssignInExpressions: no
      c.value[f.number] = {
        kind: "enum_value",
        proto: f,
        deprecated: (i = (s = f.options) === null || s === void 0 ? void 0 : s.deprecated) !== null && i !== void 0 ? i : !1,
        parent: c,
        name: d,
        localName: hl(l == null ? d : d.substring(l.length)),
        number: f.number,
        toString() {
          return `enum value ${c.typeName}.${d}`;
        }
      }
    );
  }
  ((u = n?.nestedEnums) !== null && u !== void 0 ? u : t.enums).push(c);
}
function J4(e, t, n, r, a) {
  var o, s, i, u;
  const l = {
    kind: "message",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    file: t,
    parent: n,
    name: e.name,
    typeName: yb(e, n, t),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  ((i = e.options) === null || i === void 0 ? void 0 : i.mapEntry) === !0 ? a.add(l) : (((u = n?.nestedMessages) !== null && u !== void 0 ? u : t.messages).push(l), r.add(l));
  for (const c of e.enumType)
    W4(c, t, l, r);
  for (const c of e.nestedType)
    J4(c, t, l, r, a);
}
function UJ(e, t, n) {
  var r, a;
  const o = {
    kind: "service",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    file: t,
    name: e.name,
    typeName: yb(e, void 0, t),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  t.services.push(o), n.add(o);
  for (const s of e.method) {
    const i = RJ(s, o, n);
    o.methods.push(i), o.method[i.localName] = i;
  }
}
function RJ(e, t, n) {
  var r, a, o, s;
  let i;
  e.clientStreaming && e.serverStreaming ? i = "bidi_streaming" : e.clientStreaming ? i = "client_streaming" : e.serverStreaming ? i = "server_streaming" : i = "unary";
  const u = n.getMessage(fa(e.inputType)), l = n.getMessage(fa(e.outputType));
  ar(u, `invalid MethodDescriptorProto: input_type ${e.inputType} not found`), ar(l, `invalid MethodDescriptorProto: output_type ${e.inputType} not found`);
  const c = e.name;
  return {
    kind: "rpc",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    parent: t,
    name: c,
    localName: hl(c.length ? hl(c[0].toLowerCase() + c.substring(1)) : c),
    methodKind: i,
    input: u,
    output: l,
    idempotency: (s = (o = e.options) === null || o === void 0 ? void 0 : o.idempotencyLevel) !== null && s !== void 0 ? s : DJ,
    toString() {
      return `rpc ${t.typeName}.${c}`;
    }
  };
}
function $J(e, t) {
  return {
    kind: "oneof",
    proto: e,
    deprecated: !1,
    parent: t,
    fields: [],
    name: e.name,
    localName: hl(gl(e.name)),
    toString() {
      return `oneof ${t.typeName}.${this.name}`;
    }
  };
}
function Fy(e, t, n, r, a) {
  var o, s, i;
  const u = a === void 0, l = {
    kind: "field",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    name: e.name,
    number: e.number,
    scalar: void 0,
    message: void 0,
    enum: void 0,
    presence: BJ(e, r, u, t),
    listKind: void 0,
    mapKind: void 0,
    mapKey: void 0,
    delimitedEncoding: void 0,
    packed: void 0,
    longAsString: !1,
    getDefaultValue: void 0
  };
  if (u) {
    const m = t.kind == "file" ? t : t.file, p = t.kind == "file" ? void 0 : t, b = yb(e, p, m);
    l.kind = "extension", l.file = m, l.parent = p, l.oneof = void 0, l.typeName = b, l.jsonName = `[${b}]`, l.toString = () => `extension ${b}`;
    const g = n.getMessage(fa(e.extendee));
    ar(g, `invalid FieldDescriptorProto: extendee ${e.extendee} not found`), l.extendee = g;
  } else {
    const m = t;
    ar(m.kind == "message"), l.parent = m, l.oneof = r, l.localName = r ? gl(e.name) : hl(gl(e.name)), l.jsonName = e.jsonName, l.toString = () => `field ${m.typeName}.${e.name}`;
  }
  const c = e.label, f = e.type, d = (i = e.options) === null || i === void 0 ? void 0 : i.jstype;
  if (c === _0) {
    const m = f == Mu ? a?.get(fa(e.typeName)) : void 0;
    if (m) {
      l.fieldKind = "map";
      const { key: p, value: b } = MJ(m);
      return l.mapKey = p.scalar, l.mapKind = b.fieldKind, l.message = b.message, l.delimitedEncoding = !1, l.enum = b.enum, l.scalar = b.scalar, l;
    }
    switch (l.fieldKind = "list", f) {
      case Mu:
      case yl:
        l.listKind = "message", l.message = n.getMessage(fa(e.typeName)), ar(l.message), l.delimitedEncoding = B_(e, t);
        break;
      case P_:
        l.listKind = "enum", l.enum = n.getEnum(fa(e.typeName)), ar(l.enum);
        break;
      default:
        l.listKind = "scalar", l.scalar = f, l.longAsString = d == V_;
        break;
    }
    return l.packed = GJ(e, t), l;
  }
  switch (f) {
    case Mu:
    case yl:
      l.fieldKind = "message", l.message = n.getMessage(fa(e.typeName)), ar(l.message, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.delimitedEncoding = B_(e, t), l.getDefaultValue = () => {
      };
      break;
    case P_: {
      const m = n.getEnum(fa(e.typeName));
      ar(m !== void 0, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.fieldKind = "enum", l.enum = n.getEnum(fa(e.typeName)), l.getDefaultValue = () => bl(e, "defaultValue") ? NJ(m, e.defaultValue) : void 0;
      break;
    }
    default: {
      l.fieldKind = "scalar", l.scalar = f, l.longAsString = d == V_, l.getDefaultValue = () => bl(e, "defaultValue") ? EJ(f, e.defaultValue) : void 0;
      break;
    }
  }
  return l;
}
function PJ(e) {
  switch (e.syntax) {
    case "":
    case "proto2":
      return IJ;
    case "proto3":
      return wJ;
    case "editions":
      if (e.edition in X4)
        return e.edition;
      throw new Error(`${e.name}: unsupported edition`);
    default:
      throw new Error(`${e.name}: unsupported syntax "${e.syntax}"`);
  }
}
function VJ(e, t) {
  return e.dependency.map((n) => {
    const r = t.getFile(n);
    if (!r)
      throw new Error(`Cannot find ${n}, imported by ${e.name}`);
    return r;
  });
}
function xJ(e, t) {
  const n = YJ(e) + "_";
  for (const r of t) {
    if (!r.name.toLowerCase().startsWith(n))
      return;
    const a = r.name.substring(n.length);
    if (a.length == 0 || /^\d/.test(a))
      return;
  }
  return n;
}
function YJ(e) {
  return (e.substring(0, 1) + e.substring(1).replace(/[A-Z]/g, (t) => "_" + t)).toLowerCase();
}
function yb(e, t, n) {
  let r;
  return t ? r = `${t.typeName}.${e.name}` : n.proto.package.length > 0 ? r = `${n.proto.package}.${e.name}` : r = `${e.name}`, r;
}
function fa(e) {
  return e.startsWith(".") ? e.substring(1) : e;
}
function jJ(e, t) {
  if (!bl(e, "oneofIndex") || e.proto3Optional)
    return;
  const n = t[e.oneofIndex];
  return ar(n, `invalid FieldDescriptorProto: oneof #${e.oneofIndex} for field #${e.number} not found`), n;
}
function BJ(e, t, n, r) {
  if (e.label == SJ)
    return kJ;
  if (e.label == _0)
    return Y_;
  if (t || e.proto3Optional || n)
    return x_;
  const a = Gi("fieldPresence", { proto: e, parent: r });
  return a == Y_ && (e.type == Mu || e.type == yl) ? x_ : a;
}
function GJ(e, t) {
  if (e.label != _0)
    return !1;
  switch (e.type) {
    case _J:
    case OJ:
    case yl:
    case Mu:
      return !1;
  }
  const n = e.options;
  return n && bl(n, "packed") ? n.packed : AJ == Gi("repeatedFieldEncoding", {
    proto: e,
    parent: t
  });
}
function MJ(e) {
  const t = e.fields.find((r) => r.number === 1), n = e.fields.find((r) => r.number === 2);
  return ar(t && t.fieldKind == "scalar" && t.scalar != N.BYTES && t.scalar != N.FLOAT && t.scalar != N.DOUBLE && n && n.fieldKind != "list" && n.fieldKind != "map"), { key: t, value: n };
}
function CJ(e) {
  var t;
  return FJ == Gi("enumType", {
    proto: e.proto,
    parent: (t = e.parent) !== null && t !== void 0 ? t : e.file
  });
}
function B_(e, t) {
  return e.type == yl ? !0 : LJ == Gi("messageEncoding", {
    proto: e,
    parent: t
  });
}
function Gi(e, t) {
  var n, r;
  const a = (n = t.proto.options) === null || n === void 0 ? void 0 : n.features;
  if (a) {
    const o = a[e];
    if (o != 0)
      return o;
  }
  if ("kind" in t) {
    if (t.kind == "message")
      return Gi(e, (r = t.parent) !== null && r !== void 0 ? r : t.file);
    const o = X4[t.edition];
    if (!o)
      throw new Error(`feature default for edition ${t.edition} not found`);
    return o[e];
  }
  return Gi(e, t.parent);
}
function ar(e, t) {
  if (!e)
    throw new Error(t);
}
function KJ(e) {
  const t = XJ(e);
  return t.messageType.forEach(w0), K4(t, () => {
  }).getFile(t.name);
}
function XJ(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    syntax: "",
    edition: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, e), { messageType: e.messageType.map(Z4), enumType: e.enumType.map(H4) }));
}
function Z4(e) {
  var t, n, r, a, o, s, i, u;
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.DescriptorProto",
    name: e.name,
    field: (n = (t = e.field) === null || t === void 0 ? void 0 : t.map(WJ)) !== null && n !== void 0 ? n : [],
    extension: [],
    nestedType: (a = (r = e.nestedType) === null || r === void 0 ? void 0 : r.map(Z4)) !== null && a !== void 0 ? a : [],
    enumType: (s = (o = e.enumType) === null || o === void 0 ? void 0 : o.map(H4)) !== null && s !== void 0 ? s : [],
    extensionRange: (u = (i = e.extensionRange) === null || i === void 0 ? void 0 : i.map((l) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, l))) !== null && u !== void 0 ? u : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function WJ(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: !1
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, e), { options: e.options ? JJ(e.options) : void 0 }));
}
function JJ(e) {
  var t, n, r;
  return Object.assign(/* @__PURE__ */ Object.create({
    ctype: 0,
    packed: !1,
    jstype: 0,
    lazy: !1,
    unverifiedLazy: !1,
    deprecated: !1,
    weak: !1,
    debugRedact: !1,
    retention: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, e), { targets: (t = e.targets) !== null && t !== void 0 ? t : [], editionDefaults: (r = (n = e.editionDefaults) === null || n === void 0 ? void 0 : n.map((a) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, a))) !== null && r !== void 0 ? r : [], uninterpretedOption: [] }));
}
function H4(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: e.name,
    reservedName: [],
    reservedRange: [],
    value: e.value.map((t) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, t))
  });
}
function Wc(e, t, ...n) {
  return n.reduce((r, a) => r.nestedMessages[a], e.messages[t]);
}
const ZJ = /* @__PURE__ */ KJ({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: !0 } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false", options: { deprecated: !0 } }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1e3 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1e3, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: !0 } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1e3 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_UNSTABLE", number: 9999 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] }), HJ = /* @__PURE__ */ Wc(ZJ, 1);
var G_;
(function(e) {
  e[e.DECLARATION = 0] = "DECLARATION", e[e.UNVERIFIED = 1] = "UNVERIFIED";
})(G_ || (G_ = {}));
var M_;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.GROUP = 10] = "GROUP", e[e.MESSAGE = 11] = "MESSAGE", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.ENUM = 14] = "ENUM", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(M_ || (M_ = {}));
var C_;
(function(e) {
  e[e.OPTIONAL = 1] = "OPTIONAL", e[e.REPEATED = 3] = "REPEATED", e[e.REQUIRED = 2] = "REQUIRED";
})(C_ || (C_ = {}));
var K_;
(function(e) {
  e[e.SPEED = 1] = "SPEED", e[e.CODE_SIZE = 2] = "CODE_SIZE", e[e.LITE_RUNTIME = 3] = "LITE_RUNTIME";
})(K_ || (K_ = {}));
var X_;
(function(e) {
  e[e.STRING = 0] = "STRING", e[e.CORD = 1] = "CORD", e[e.STRING_PIECE = 2] = "STRING_PIECE";
})(X_ || (X_ = {}));
var W_;
(function(e) {
  e[e.JS_NORMAL = 0] = "JS_NORMAL", e[e.JS_STRING = 1] = "JS_STRING", e[e.JS_NUMBER = 2] = "JS_NUMBER";
})(W_ || (W_ = {}));
var J_;
(function(e) {
  e[e.RETENTION_UNKNOWN = 0] = "RETENTION_UNKNOWN", e[e.RETENTION_RUNTIME = 1] = "RETENTION_RUNTIME", e[e.RETENTION_SOURCE = 2] = "RETENTION_SOURCE";
})(J_ || (J_ = {}));
var Z_;
(function(e) {
  e[e.TARGET_TYPE_UNKNOWN = 0] = "TARGET_TYPE_UNKNOWN", e[e.TARGET_TYPE_FILE = 1] = "TARGET_TYPE_FILE", e[e.TARGET_TYPE_EXTENSION_RANGE = 2] = "TARGET_TYPE_EXTENSION_RANGE", e[e.TARGET_TYPE_MESSAGE = 3] = "TARGET_TYPE_MESSAGE", e[e.TARGET_TYPE_FIELD = 4] = "TARGET_TYPE_FIELD", e[e.TARGET_TYPE_ONEOF = 5] = "TARGET_TYPE_ONEOF", e[e.TARGET_TYPE_ENUM = 6] = "TARGET_TYPE_ENUM", e[e.TARGET_TYPE_ENUM_ENTRY = 7] = "TARGET_TYPE_ENUM_ENTRY", e[e.TARGET_TYPE_SERVICE = 8] = "TARGET_TYPE_SERVICE", e[e.TARGET_TYPE_METHOD = 9] = "TARGET_TYPE_METHOD";
})(Z_ || (Z_ = {}));
var Uy;
(function(e) {
  e[e.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e[e.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e[e.IDEMPOTENT = 2] = "IDEMPOTENT";
})(Uy || (Uy = {}));
var H_;
(function(e) {
  e[e.DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", e[e.EXPORT_ALL = 1] = "EXPORT_ALL", e[e.EXPORT_TOP_LEVEL = 2] = "EXPORT_TOP_LEVEL", e[e.LOCAL_ALL = 3] = "LOCAL_ALL", e[e.STRICT = 4] = "STRICT";
})(H_ || (H_ = {}));
var z_;
(function(e) {
  e[e.FIELD_PRESENCE_UNKNOWN = 0] = "FIELD_PRESENCE_UNKNOWN", e[e.EXPLICIT = 1] = "EXPLICIT", e[e.IMPLICIT = 2] = "IMPLICIT", e[e.LEGACY_REQUIRED = 3] = "LEGACY_REQUIRED";
})(z_ || (z_ = {}));
var q_;
(function(e) {
  e[e.ENUM_TYPE_UNKNOWN = 0] = "ENUM_TYPE_UNKNOWN", e[e.OPEN = 1] = "OPEN", e[e.CLOSED = 2] = "CLOSED";
})(q_ || (q_ = {}));
var Q_;
(function(e) {
  e[e.REPEATED_FIELD_ENCODING_UNKNOWN = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN", e[e.PACKED = 1] = "PACKED", e[e.EXPANDED = 2] = "EXPANDED";
})(Q_ || (Q_ = {}));
var eO;
(function(e) {
  e[e.UTF8_VALIDATION_UNKNOWN = 0] = "UTF8_VALIDATION_UNKNOWN", e[e.VERIFY = 2] = "VERIFY", e[e.NONE = 3] = "NONE";
})(eO || (eO = {}));
var tO;
(function(e) {
  e[e.MESSAGE_ENCODING_UNKNOWN = 0] = "MESSAGE_ENCODING_UNKNOWN", e[e.LENGTH_PREFIXED = 1] = "LENGTH_PREFIXED", e[e.DELIMITED = 2] = "DELIMITED";
})(tO || (tO = {}));
var nO;
(function(e) {
  e[e.JSON_FORMAT_UNKNOWN = 0] = "JSON_FORMAT_UNKNOWN", e[e.ALLOW = 1] = "ALLOW", e[e.LEGACY_BEST_EFFORT = 2] = "LEGACY_BEST_EFFORT";
})(nO || (nO = {}));
var rO;
(function(e) {
  e[e.ENFORCE_NAMING_STYLE_UNKNOWN = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN", e[e.STYLE2024 = 1] = "STYLE2024", e[e.STYLE_LEGACY = 2] = "STYLE_LEGACY";
})(rO || (rO = {}));
var aO;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SET = 1] = "SET", e[e.ALIAS = 2] = "ALIAS";
})(aO || (aO = {}));
var oO;
(function(e) {
  e[e.EDITION_UNKNOWN = 0] = "EDITION_UNKNOWN", e[e.EDITION_LEGACY = 900] = "EDITION_LEGACY", e[e.EDITION_PROTO2 = 998] = "EDITION_PROTO2", e[e.EDITION_PROTO3 = 999] = "EDITION_PROTO3", e[e.EDITION_2023 = 1e3] = "EDITION_2023", e[e.EDITION_2024 = 1001] = "EDITION_2024", e[e.EDITION_UNSTABLE = 9999] = "EDITION_UNSTABLE", e[e.EDITION_1_TEST_ONLY = 1] = "EDITION_1_TEST_ONLY", e[e.EDITION_2_TEST_ONLY = 2] = "EDITION_2_TEST_ONLY", e[e.EDITION_99997_TEST_ONLY = 99997] = "EDITION_99997_TEST_ONLY", e[e.EDITION_99998_TEST_ONLY = 99998] = "EDITION_99998_TEST_ONLY", e[e.EDITION_99999_TEST_ONLY = 99999] = "EDITION_99999_TEST_ONLY", e[e.EDITION_MAX = 2147483647] = "EDITION_MAX";
})(oO || (oO = {}));
var sO;
(function(e) {
  e[e.VISIBILITY_UNSET = 0] = "VISIBILITY_UNSET", e[e.VISIBILITY_LOCAL = 1] = "VISIBILITY_LOCAL", e[e.VISIBILITY_EXPORT = 2] = "VISIBILITY_EXPORT";
})(sO || (sO = {}));
const iO = {
  readUnknownFields: !0
};
function zJ(e) {
  return e ? Object.assign(Object.assign({}, iO), e) : iO;
}
function Nb(e, t, n) {
  const r = Jn(e, void 0, !1);
  return z4(r, new h0(t), zJ(n), !1, t.byteLength), r.message;
}
function z4(e, t, n, r, a) {
  var o;
  const s = r ? t.len : t.pos + a;
  let i, u;
  const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
  for (; t.pos < s && ([i, u] = t.tag(), !(r && u == se.EndGroup)); ) {
    const c = e.findNumber(i);
    if (!c) {
      const f = t.skip(u, i);
      n.readUnknownFields && l.push({ no: i, wireType: u, data: f });
      continue;
    }
    q4(e, t, c, u, n);
  }
  if (r && (u != se.EndGroup || i !== a))
    throw new Error("invalid end group tag");
  l.length > 0 && e.setUnknown(l);
}
function q4(e, t, n, r, a) {
  var o;
  switch (n.fieldKind) {
    case "scalar":
      e.set(n, Mi(t, n.scalar));
      break;
    case "enum":
      const s = Mi(t, N.INT32);
      if (n.enum.open)
        e.set(n, s);
      else if (n.enum.values.some((i) => i.number === s))
        e.set(n, s);
      else if (a.readUnknownFields) {
        const i = [];
        Dy(s, i);
        const u = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
        u.push({
          no: n.number,
          wireType: r,
          data: new Uint8Array(i)
        }), e.setUnknown(u);
      }
      break;
    case "message":
      e.set(n, O0(t, a, n, e.get(n)));
      break;
    case "list":
      QJ(t, r, e.get(n), a);
      break;
    case "map":
      qJ(t, e.get(n), a);
      break;
  }
}
function qJ(e, t, n) {
  const r = t.field();
  let a, o;
  const s = e.uint32(), i = e.pos + s;
  for (; e.pos < i; ) {
    const [u] = e.tag();
    switch (u) {
      case 1:
        a = Mi(e, r.mapKey);
        break;
      case 2:
        switch (r.mapKind) {
          case "scalar":
            o = Mi(e, r.scalar);
            break;
          case "enum":
            o = e.int32();
            break;
          case "message":
            o = O0(e, n, r);
            break;
        }
        break;
    }
  }
  if (a === void 0 && (a = Vs(r.mapKey, !1)), o === void 0)
    switch (r.mapKind) {
      case "scalar":
        o = Vs(r.scalar, !1);
        break;
      case "enum":
        o = r.enum.values[0].number;
        break;
      case "message":
        o = Jn(r.message, void 0, !1);
        break;
    }
  t.set(a, o);
}
function QJ(e, t, n, r) {
  var a;
  const o = n.field();
  if (o.listKind === "message") {
    n.add(O0(e, r, o));
    return;
  }
  const s = (a = o.scalar) !== null && a !== void 0 ? a : N.INT32;
  if (!(t == se.LengthDelimited && s != N.STRING && s != N.BYTES)) {
    n.add(Mi(e, s));
    return;
  }
  const i = e.uint32() + e.pos;
  for (; e.pos < i; )
    n.add(Mi(e, s));
}
function O0(e, t, n, r) {
  const a = n.delimitedEncoding, o = r ?? Jn(n.message, void 0, !1);
  return z4(o, e, t, a, a ? n.number : e.uint32()), o;
}
function Mi(e, t) {
  switch (t) {
    case N.STRING:
      return e.string();
    case N.BOOL:
      return e.bool();
    case N.DOUBLE:
      return e.double();
    case N.FLOAT:
      return e.float();
    case N.INT32:
      return e.int32();
    case N.INT64:
      return e.int64();
    case N.UINT64:
      return e.uint64();
    case N.FIXED64:
      return e.fixed64();
    case N.BYTES:
      return e.bytes();
    case N.FIXED32:
      return e.fixed32();
    case N.SFIXED32:
      return e.sfixed32();
    case N.SFIXED64:
      return e.sfixed64();
    case N.SINT64:
      return e.sint64();
    case N.UINT32:
      return e.uint32();
    case N.SINT32:
      return e.sint32();
  }
}
function Q4(e, t) {
  var n;
  const r = Nb(HJ, I0(e));
  return r.messageType.forEach(w0), r.dependency = (n = void 0) !== null && n !== void 0 ? n : [], K4(r, (a) => {
  }).getFile(r.name);
}
const eZ = /* @__PURE__ */ Q4("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), tZ = /* @__PURE__ */ Wc(eZ, 0), nZ = 3, uO = {
  writeUnknownFields: !0
};
function rZ(e) {
  return e ? Object.assign(Object.assign({}, uO), e) : uO;
}
function eR(e, t, n) {
  return Yd(new U4(), rZ(n), Jn(e, t)).finish();
}
function Yd(e, t, n) {
  var r;
  for (const a of n.sortedFields) {
    if (!n.isSet(a)) {
      if (a.presence == nZ)
        throw new Error(`cannot encode ${a} to binary: required field not set`);
      continue;
    }
    tR(e, t, n, a);
  }
  if (t.writeUnknownFields)
    for (const { no: a, wireType: o, data: s } of (r = n.getUnknown()) !== null && r !== void 0 ? r : [])
      e.tag(a, o).raw(s);
  return e;
}
function tR(e, t, n, r) {
  var a;
  switch (r.fieldKind) {
    case "scalar":
    case "enum":
      jd(e, n.desc.typeName, r.name, (a = r.scalar) !== null && a !== void 0 ? a : N.INT32, r.number, n.get(r));
      break;
    case "list":
      aZ(e, t, r, n.get(r));
      break;
    case "message":
      nR(e, t, r, n.get(r));
      break;
    case "map":
      for (const [o, s] of n.get(r))
        oZ(e, t, r, o, s);
      break;
  }
}
function jd(e, t, n, r, a, o) {
  rR(e.tag(a, sZ(r)), t, n, r, o);
}
function nR(e, t, n, r) {
  n.delimitedEncoding ? Yd(e.tag(n.number, se.StartGroup), t, r).tag(n.number, se.EndGroup) : Yd(e.tag(n.number, se.LengthDelimited).fork(), t, r).join();
}
function aZ(e, t, n, r) {
  var a;
  if (n.listKind == "message") {
    for (const s of r)
      nR(e, t, n, s);
    return;
  }
  const o = (a = n.scalar) !== null && a !== void 0 ? a : N.INT32;
  if (n.packed) {
    if (!r.size)
      return;
    e.tag(n.number, se.LengthDelimited).fork();
    for (const s of r)
      rR(e, n.parent.typeName, n.name, o, s);
    e.join();
    return;
  }
  for (const s of r)
    jd(e, n.parent.typeName, n.name, o, n.number, s);
}
function oZ(e, t, n, r, a) {
  var o;
  switch (e.tag(n.number, se.LengthDelimited).fork(), jd(e, n.parent.typeName, n.name, n.mapKey, 1, r), n.mapKind) {
    case "scalar":
    case "enum":
      jd(e, n.parent.typeName, n.name, (o = n.scalar) !== null && o !== void 0 ? o : N.INT32, 2, a);
      break;
    case "message":
      Yd(e.tag(2, se.LengthDelimited).fork(), t, a).join();
      break;
  }
  e.join();
}
function rR(e, t, n, r, a) {
  try {
    switch (r) {
      case N.STRING:
        e.string(a);
        break;
      case N.BOOL:
        e.bool(a);
        break;
      case N.DOUBLE:
        e.double(a);
        break;
      case N.FLOAT:
        e.float(a);
        break;
      case N.INT32:
        e.int32(a);
        break;
      case N.INT64:
        e.int64(a);
        break;
      case N.UINT64:
        e.uint64(a);
        break;
      case N.FIXED64:
        e.fixed64(a);
        break;
      case N.BYTES:
        e.bytes(a);
        break;
      case N.FIXED32:
        e.fixed32(a);
        break;
      case N.SFIXED32:
        e.sfixed32(a);
        break;
      case N.SFIXED64:
        e.sfixed64(a);
        break;
      case N.SINT64:
        e.sint64(a);
        break;
      case N.UINT32:
        e.uint32(a);
        break;
      case N.SINT32:
        e.sint32(a);
        break;
    }
  } catch (o) {
    throw o instanceof Error ? new Error(`cannot encode field ${t}.${n} to binary: ${o.message}`) : o;
  }
}
function sZ(e) {
  switch (e) {
    case N.BYTES:
    case N.STRING:
      return se.LengthDelimited;
    case N.DOUBLE:
    case N.FIXED64:
    case N.SFIXED64:
      return se.Bit64;
    case N.FIXED32:
    case N.SFIXED32:
    case N.FLOAT:
      return se.Bit32;
    default:
      return se.Varint;
  }
}
function iZ(e, t, n) {
  let r = !1;
  return n || (n = gr(tZ), r = !0), n.value = eR(e, t), n.typeUrl = cZ(t.$typeName), r ? n : void 0;
}
function uZ(e, t) {
  if (e.typeUrl === "")
    return !1;
  const n = typeof t == "string" ? t : t.typeName, r = aR(e.typeUrl);
  return n === r;
}
function lZ(e, t) {
  if (e.typeUrl === "")
    return;
  const n = t.kind == "message" ? t : t.getMessage(aR(e.typeUrl));
  if (!(!n || !uZ(e, n)))
    return Nb(n, e.value);
}
function cZ(e) {
  return `type.googleapis.com/${e}`;
}
function aR(e) {
  const t = e.lastIndexOf("/"), n = t >= 0 ? e.substring(t + 1) : e;
  if (!n.length)
    throw new Error(`invalid type url: ${e}`);
  return n;
}
const S0 = /* @__PURE__ */ Q4("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), fZ = /* @__PURE__ */ Wc(S0, 0), oR = /* @__PURE__ */ Wc(S0, 1), mZ = /* @__PURE__ */ Wc(S0, 2);
var Ry;
(function(e) {
  e[e.NULL_VALUE = 0] = "NULL_VALUE";
})(Ry || (Ry = {}));
function dZ(e, t) {
  sR(t, e);
  const n = bZ(e.$unknown, t), [r, a, o] = Eb(t);
  for (const s of n)
    q4(r, new h0(s.data), a, s.wireType, {
      readUnknownFields: !0
    });
  return o();
}
function pZ(e, t, n) {
  var r;
  sR(t, e);
  const a = ((r = e.$unknown) !== null && r !== void 0 ? r : []).filter((l) => l.no !== t.number), [o, s] = Eb(t, n), i = new U4();
  tR(i, { writeUnknownFields: !0 }, o, s);
  const u = new h0(i.finish());
  for (; u.pos < u.len; ) {
    const [l, c] = u.tag(), f = u.skip(c, l);
    a.push({ no: l, wireType: c, data: f });
  }
  e.$unknown = a;
}
function bZ(e, t) {
  if (e === void 0)
    return [];
  if (t.fieldKind === "enum" || t.fieldKind === "scalar") {
    for (let n = e.length - 1; n >= 0; --n)
      if (e[n].no == t.number)
        return [e[n]];
    return [];
  }
  return e.filter((n) => n.no === t.number);
}
function Eb(e, t) {
  const n = e.typeName, r = Object.assign(Object.assign({}, e), { kind: "field", parent: e.extendee, localName: n }), a = Object.assign(Object.assign({}, e.extendee), { fields: [r], members: [r], oneofs: [] }), o = gr(a, t !== void 0 ? { [n]: t } : void 0);
  return [
    Jn(a, o),
    r,
    () => {
      const s = o[n];
      if (s === void 0) {
        const i = e.message;
        return Xc(i) ? Vs(i.fields[0].scalar, i.fields[0].longAsString) : gr(i);
      }
      return s;
    }
  ];
}
function sR(e, t) {
  if (e.extendee.typeName != t.$typeName)
    throw new Error(`extension ${e.typeName} can only be applied to message ${e.extendee.typeName}`);
}
const gZ = 3, hZ = 2, lO = {
  alwaysEmitImplicit: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1
};
function yZ(e) {
  return e ? Object.assign(Object.assign({}, lO), e) : lO;
}
function NZ(e, t, n) {
  return Jc(Jn(e, t), yZ(n));
}
function EZ(e, t, n) {
  var r;
  const a = NZ(e, t, n);
  return JSON.stringify(a, null, (r = n?.prettySpaces) !== null && r !== void 0 ? r : 0);
}
function Jc(e, t) {
  var n;
  const r = wZ(e, t);
  if (r !== void 0)
    return r;
  const a = {};
  for (const o of e.sortedFields) {
    if (!e.isSet(o)) {
      if (o.presence == gZ)
        throw new Error(`cannot encode ${o} to JSON: required field not set`);
      if (!t.alwaysEmitImplicit || o.presence !== hZ)
        continue;
    }
    const s = cO(o, e.get(o), t);
    s !== void 0 && (a[IZ(o, t)] = s);
  }
  if (t.registry) {
    const o = /* @__PURE__ */ new Set();
    for (const { no: s } of (n = e.getUnknown()) !== null && n !== void 0 ? n : [])
      if (!o.has(s)) {
        o.add(s);
        const i = t.registry.getExtensionFor(e.desc, s);
        if (!i)
          continue;
        const u = dZ(e.message, i), [l, c] = Eb(i, u), f = cO(c, l.get(c), t);
        f !== void 0 && (a[i.jsonName] = f);
      }
  }
  return a;
}
function cO(e, t, n) {
  switch (e.fieldKind) {
    case "scalar":
      return vb(e, t);
    case "message":
      return Jc(t, n);
    case "enum":
      return D0(e.enum, t, n.enumAsInteger);
    case "list":
      return TZ(t, n);
    case "map":
      return vZ(t, n);
  }
}
function vZ(e, t) {
  const n = e.field(), r = {};
  switch (n.mapKind) {
    case "scalar":
      for (const [a, o] of e)
        r[a] = vb(n, o);
      break;
    case "message":
      for (const [a, o] of e)
        r[a] = Jc(o, t);
      break;
    case "enum":
      for (const [a, o] of e)
        r[a] = D0(n.enum, o, t.enumAsInteger);
      break;
  }
  return t.alwaysEmitImplicit || e.size > 0 ? r : void 0;
}
function TZ(e, t) {
  const n = e.field(), r = [];
  switch (n.listKind) {
    case "scalar":
      for (const a of e)
        r.push(vb(n, a));
      break;
    case "enum":
      for (const a of e)
        r.push(D0(n.enum, a, t.enumAsInteger));
      break;
    case "message":
      for (const a of e)
        r.push(Jc(a, t));
      break;
  }
  return t.alwaysEmitImplicit || r.length > 0 ? r : void 0;
}
function D0(e, t, n) {
  var r;
  if (typeof t != "number")
    throw new Error(`cannot encode ${e} to JSON: expected number, got ${Pe(t)}`);
  return e.typeName == "google.protobuf.NullValue" ? null : n ? t : (r = e.value[t]?.name) !== null && r !== void 0 ? r : t;
}
function vb(e, t) {
  var n, r, a, o, s, i;
  switch (e.scalar) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case N.INT32:
    case N.SFIXED32:
    case N.SINT32:
    case N.FIXED32:
    case N.UINT32:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(n = Fo(e, t)) === null || n === void 0 ? void 0 : n.message}`);
      return t;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case N.FLOAT:
    case N.DOUBLE:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(r = Fo(e, t)) === null || r === void 0 ? void 0 : r.message}`);
      return Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    // string:
    case N.STRING:
      if (typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(a = Fo(e, t)) === null || a === void 0 ? void 0 : a.message}`);
      return t;
    // bool:
    case N.BOOL:
      if (typeof t != "boolean")
        throw new Error(`cannot encode ${e} to JSON: ${(o = Fo(e, t)) === null || o === void 0 ? void 0 : o.message}`);
      return t;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case N.UINT64:
    case N.FIXED64:
    case N.INT64:
    case N.SFIXED64:
    case N.SINT64:
      if (typeof t != "bigint" && typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(s = Fo(e, t)) === null || s === void 0 ? void 0 : s.message}`);
      return t.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case N.BYTES:
      if (t instanceof Uint8Array)
        return M4(t);
      throw new Error(`cannot encode ${e} to JSON: ${(i = Fo(e, t)) === null || i === void 0 ? void 0 : i.message}`);
  }
}
function IZ(e, t) {
  return t.useProtoFieldName ? e.name : e.jsonName;
}
function wZ(e, t) {
  if (e.desc.typeName.startsWith("google.protobuf."))
    switch (e.desc.typeName) {
      case "google.protobuf.Any":
        return _Z(e.message, t);
      case "google.protobuf.Timestamp":
        return DZ(e.message);
      case "google.protobuf.Duration":
        return OZ(e.message);
      case "google.protobuf.FieldMask":
        return SZ(e.message);
      case "google.protobuf.Struct":
        return iR(e.message);
      case "google.protobuf.Value":
        return k0(e.message);
      case "google.protobuf.ListValue":
        return uR(e.message);
      default:
        if (Xc(e.desc)) {
          const n = e.desc.fields[0];
          return vb(n, e.get(n));
        }
        return;
    }
}
function _Z(e, t) {
  if (e.typeUrl === "")
    return {};
  const { registry: n } = t;
  let r, a;
  if (n && (r = lZ(e, n), r && (a = n.getMessage(r.$typeName))), !a || !r)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: "${e.typeUrl}" is not in the type registry`);
  let o = Jc(Jn(a, r), t);
  return (a.typeName.startsWith("google.protobuf.") || o === null || Array.isArray(o) || typeof o != "object") && (o = { value: o }), o["@type"] = e.typeUrl, o;
}
function OZ(e) {
  const t = Number(e.seconds), n = e.nanos;
  if (t > 315576e6 || t < -315576e6)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: value out of range`);
  if (t > 0 && n < 0 || t < 0 && n > 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos sign must match seconds sign`);
  let r = e.seconds.toString();
  if (n !== 0) {
    let a = Math.abs(n).toString();
    a = "0".repeat(9 - a.length) + a, a.substring(3) === "000000" ? a = a.substring(0, 3) : a.substring(6) === "000" && (a = a.substring(0, 6)), r += "." + a, n < 0 && t == 0 && (r = "-" + r);
  }
  return r + "s";
}
function SZ(e) {
  return e.paths.map((t) => {
    if (t.match(/_[0-9]?_/g) || t.match(/[A-Z]/g))
      throw new Error(`cannot encode message ${e.$typeName} to JSON: lowerCamelCase of path name "` + t + '" is irreversible');
    return gl(t);
  }).join(",");
}
function iR(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = k0(r);
  return t;
}
function k0(e) {
  switch (e.kind.case) {
    case "nullValue":
      return null;
    case "numberValue":
      if (!Number.isFinite(e.kind.value))
        throw new Error(`${e.$typeName} cannot be NaN or Infinity`);
      return e.kind.value;
    case "boolValue":
      return e.kind.value;
    case "stringValue":
      return e.kind.value;
    case "structValue":
      return iR(e.kind.value);
    case "listValue":
      return uR(e.kind.value);
    default:
      throw new Error(`${e.$typeName} must have a value`);
  }
}
function uR(e) {
  return e.values.map(k0);
}
function DZ(e) {
  const t = Number(e.seconds) * 1e3;
  if (t < Date.parse("0001-01-01T00:00:00Z") || t > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot encode message ${e.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  if (e.nanos < 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be negative`);
  if (e.nanos > 999999999)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be greater than 99999999`);
  let n = "Z";
  if (e.nanos > 0) {
    const r = (e.nanos + 1e9).toString().substring(1);
    r.substring(3) === "000000" ? n = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? n = "." + r.substring(0, 6) + "Z" : n = "." + r + "Z";
  }
  return new Date(t).toISOString().replace(".000Z", n);
}
const fO = {
  ignoreUnknownFields: !1
};
function kZ(e) {
  return e ? Object.assign(Object.assign({}, fO), e) : fO;
}
function AZ(e, t, n) {
  return lR(e, VZ(t, e.typeName), n);
}
function lR(e, t, n) {
  const r = Jn(e);
  try {
    Ci(r, t, kZ(n));
  } catch (a) {
    throw cJ(a) ? new Error(`cannot decode ${a.field()} from JSON: ${a.message}`, {
      cause: a
    }) : a;
  }
  return r.message;
}
function Ci(e, t, n) {
  var r;
  if (xZ(e, t, n))
    return;
  if (t == null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode ${e.desc} from JSON: ${Pe(t)}`);
  const a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const s of e.desc.fields)
    o.set(s.name, s).set(s.jsonName, s);
  for (const [s, i] of Object.entries(t)) {
    const u = o.get(s);
    if (u) {
      if (u.oneof) {
        if (i === null && u.fieldKind == "scalar")
          continue;
        const l = a.get(u.oneof);
        if (l !== void 0)
          throw new $t(u.oneof, `oneof set multiple times by ${l.name} and ${u.name}`);
        a.set(u.oneof, u);
      }
      mO(e, u, i, n);
    } else {
      let l;
      if (s.startsWith("[") && s.endsWith("]") && // biome-ignore lint/suspicious/noAssignInExpressions: no
      (l = (r = n.registry) === null || r === void 0 ? void 0 : r.getExtension(s.substring(1, s.length - 1))) && l.extendee.typeName === e.desc.typeName) {
        const [c, f, d] = Eb(l);
        mO(c, f, i, n), pZ(e.message, l, d());
      }
      if (!l && !n.ignoreUnknownFields)
        throw new Error(`cannot decode ${e.desc} from JSON: key "${s}" is unknown`);
    }
  }
}
function mO(e, t, n, r) {
  switch (t.fieldKind) {
    case "scalar":
      $Z(e, t, n);
      break;
    case "enum":
      RZ(e, t, n, r);
      break;
    case "message":
      UZ(e, t, n, r);
      break;
    case "list":
      FZ(e.get(t), n, r);
      break;
    case "map":
      LZ(e.get(t), n, r);
      break;
  }
}
function LZ(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (typeof t != "object" || Array.isArray(t))
    throw new $t(r, "expected object, got " + Pe(t));
  for (const [a, o] of Object.entries(t)) {
    if (o === null && !cR(r))
      throw new $t(r, "map value must not be null");
    let s;
    switch (r.mapKind) {
      case "message":
        const u = Jn(r.message);
        Ci(u, o, n), s = u;
        break;
      case "enum":
        if (s = A0(r.enum, o, n.ignoreUnknownFields, !0), s === Tb)
          return;
        break;
      case "scalar":
        s = wb(r, o, !0);
        break;
    }
    const i = PZ(r.mapKey, a);
    e.set(i, s);
  }
}
function FZ(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (!Array.isArray(t))
    throw new $t(r, "expected Array, got " + Pe(t));
  for (const a of t) {
    if (a === null && !cR(r))
      throw new $t(r, "list item must not be null");
    switch (r.listKind) {
      case "message":
        const o = Jn(r.message);
        Ci(o, a, n), e.add(o);
        break;
      case "enum":
        const s = A0(r.enum, a, n.ignoreUnknownFields, !0);
        s !== Tb && e.add(s);
        break;
      case "scalar":
        e.add(wb(r, a, !0));
        break;
    }
  }
}
function cR(e) {
  var t, n;
  return ((t = e.message) === null || t === void 0 ? void 0 : t.typeName) == "google.protobuf.Value" || ((n = e.enum) === null || n === void 0 ? void 0 : n.typeName) == "google.protobuf.NullValue";
}
function UZ(e, t, n, r) {
  if (n === null && t.message.typeName != "google.protobuf.Value") {
    e.clear(t);
    return;
  }
  const a = e.isSet(t) ? e.get(t) : Jn(t.message);
  Ci(a, n, r), e.set(t, a);
}
function RZ(e, t, n, r) {
  const a = A0(t.enum, n, r.ignoreUnknownFields, !1);
  a === Ib ? e.clear(t) : a !== Tb && e.set(t, a);
}
function $Z(e, t, n) {
  const r = wb(t, n, !1);
  r === Ib ? e.clear(t) : e.set(t, r);
}
const Tb = /* @__PURE__ */ Symbol();
function A0(e, t, n, r) {
  if (t === null)
    return e.typeName == "google.protobuf.NullValue" ? 0 : r ? e.values[0].number : Ib;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const a = e.values.find((o) => o.name === t);
      if (a !== void 0)
        return a.number;
      if (n)
        return Tb;
      break;
  }
  throw new Error(`cannot decode ${e} from JSON: ${Pe(t)}`);
}
const Ib = /* @__PURE__ */ Symbol();
function wb(e, t, n) {
  if (t === null)
    return n ? Vs(e.scalar, !1) : Ib;
  switch (e.scalar) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case N.DOUBLE:
    case N.FLOAT:
      if (t === "NaN")
        return NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (typeof t == "number") {
        if (Number.isNaN(t))
          throw new $t(e, "unexpected NaN number");
        if (!Number.isFinite(t))
          throw new $t(e, "unexpected infinite number");
        break;
      }
      if (typeof t == "string") {
        if (t === "" || t.trim().length !== t.length)
          break;
        const r = Number(t);
        if (!Number.isFinite(r))
          break;
        return r;
      }
      break;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case N.INT32:
    case N.FIXED32:
    case N.SFIXED32:
    case N.SINT32:
    case N.UINT32:
      return fR(t);
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case N.BYTES:
      if (typeof t == "string") {
        if (t === "")
          return new Uint8Array(0);
        try {
          return I0(t);
        } catch (r) {
          const a = r instanceof Error ? r.message : String(r);
          throw new $t(e, a);
        }
      }
      break;
  }
  return t;
}
function PZ(e, t) {
  switch (e) {
    case N.BOOL:
      switch (t) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      return t;
    case N.INT32:
    case N.FIXED32:
    case N.UINT32:
    case N.SFIXED32:
    case N.SINT32:
      return fR(t);
    default:
      return t;
  }
}
function fR(e) {
  if (typeof e == "string") {
    if (e === "" || e.trim().length !== e.length)
      return e;
    const t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
function VZ(e, t) {
  try {
    return JSON.parse(e);
  } catch (n) {
    const r = n instanceof Error ? n.message : String(n);
    throw new Error(
      `cannot decode message ${t} from JSON: ${r}`,
      // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
      { cause: n }
    );
  }
}
function xZ(e, t, n) {
  if (!e.desc.typeName.startsWith("google.protobuf."))
    return !1;
  switch (e.desc.typeName) {
    case "google.protobuf.Any":
      return YZ(e.message, t, n), !0;
    case "google.protobuf.Timestamp":
      return jZ(e.message, t), !0;
    case "google.protobuf.Duration":
      return BZ(e.message, t), !0;
    case "google.protobuf.FieldMask":
      return GZ(e.message, t), !0;
    case "google.protobuf.Struct":
      return mR(e.message, t), !0;
    case "google.protobuf.Value":
      return L0(e.message, t), !0;
    case "google.protobuf.ListValue":
      return dR(e.message, t), !0;
    default:
      if (Xc(e.desc)) {
        const r = e.desc.fields[0];
        return t === null ? e.clear(r) : e.set(r, wb(r, t, !0)), !0;
      }
      return !1;
  }
}
function YZ(e, t, n) {
  var r;
  if (t === null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: expected object but got ${Pe(t)}`);
  if (Object.keys(t).length == 0)
    return;
  const a = t["@type"];
  if (typeof a != "string" || a == "")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is empty`);
  const o = a.includes("/") ? a.substring(a.lastIndexOf("/") + 1) : a;
  if (!o.length)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is invalid`);
  const s = (r = n.registry) === null || r === void 0 ? void 0 : r.getMessage(o);
  if (!s)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${a} is not in the type registry`);
  const i = Jn(s);
  if (o.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(t, "value")) {
    const u = t.value;
    Ci(i, u, n);
  } else {
    const u = Object.assign({}, t);
    delete u["@type"], Ci(i, u, n);
  }
  iZ(i.desc, i.message, e);
}
function jZ(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Pe(t)}`);
  const n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
  if (!n)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  const r = Date.parse(
    // biome-ignore format: want this to read well
    n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z")
  );
  if (Number.isNaN(r))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  e.seconds = J.parse(r / 1e3), e.nanos = 0, n[7] && (e.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9);
}
function BZ(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Pe(t)}`);
  const n = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
  if (n === null)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Pe(t)}`);
  const r = Number(n[1]);
  if (r > 315576e6 || r < -315576e6)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Pe(t)}`);
  if (e.seconds = J.parse(r), typeof n[2] != "string")
    return;
  const a = n[2] + "0".repeat(9 - n[2].length);
  e.nanos = parseInt(a), (r < 0 || Object.is(r, -0)) && (e.nanos = -e.nanos);
}
function GZ(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Pe(t)}`);
  if (t === "")
    return;
  function n(r) {
    if (r.includes("_"))
      throw new Error(`cannot decode message ${e.$typeName} from JSON: path names must be lowerCamelCase`);
    const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase());
    return a[0] === "_" ? a.substring(1) : a;
  }
  e.paths = t.split(",").map(n);
}
function mR(e, t) {
  if (typeof t != "object" || t == null || Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Pe(t)}`);
  for (const [n, r] of Object.entries(t)) {
    const a = gr(oR);
    L0(a, r), e.fields[n] = a;
  }
}
function L0(e, t) {
  switch (typeof t) {
    case "number":
      e.kind = { case: "numberValue", value: t };
      break;
    case "string":
      e.kind = { case: "stringValue", value: t };
      break;
    case "boolean":
      e.kind = { case: "boolValue", value: t };
      break;
    case "object":
      if (t === null)
        e.kind = { case: "nullValue", value: Ry.NULL_VALUE };
      else if (Array.isArray(t)) {
        const n = gr(mZ);
        dR(n, t), e.kind = { case: "listValue", value: n };
      } else {
        const n = gr(fZ);
        mR(n, t), e.kind = { case: "structValue", value: n };
      }
      break;
    default:
      throw new Error(`cannot decode message ${e.$typeName} from JSON ${Pe(t)}`);
  }
  return e;
}
function dR(e, t) {
  if (!Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Pe(t)}`);
  for (const n of t) {
    const r = gr(oR);
    L0(r, n), e.values.push(r);
  }
}
function $y(e) {
  const t = x[e];
  return typeof t != "string" ? e.toString() : t[0].toLowerCase() + t.substring(1).replace(/[A-Z]/g, (n) => "_" + n.toLowerCase());
}
let sm;
function MZ(e) {
  if (!sm) {
    sm = {};
    for (const t of Object.values(x))
      typeof t != "string" && (sm[$y(t)] = t);
  }
  return sm[e];
}
class Oe extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(t, n = x.Unknown, r, a, o) {
    super(CZ(t, n)), this.name = "ConnectError", Object.setPrototypeOf(this, new.target.prototype), this.rawMessage = t, this.code = n, this.metadata = new Headers(r ?? {}), this.details = a ?? [], this.cause = o;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(t, n = x.Unknown) {
    return t instanceof Oe ? t : t instanceof Error ? t.name == "AbortError" || t.name == "TimeoutError" ? new Oe(t.message, x.Canceled) : new Oe(t.message, n, void 0, void 0, t) : new Oe(String(t), n, void 0, void 0, t);
  }
  static [Symbol.hasInstance](t) {
    return t instanceof Error ? Object.getPrototypeOf(t) === Oe.prototype ? !0 : t.name === "ConnectError" && "code" in t && typeof t.code == "number" && "metadata" in t && "details" in t && Array.isArray(t.details) && "rawMessage" in t && typeof t.rawMessage == "string" && "cause" in t : !1;
  }
  findDetails(t) {
    const n = t.kind === "message" ? {
      getMessage: (a) => a === t.typeName ? t : void 0
    } : t, r = [];
    for (const a of this.details) {
      if ("desc" in a) {
        n.getMessage(a.desc.typeName) && r.push(gr(a.desc, a.value));
        continue;
      }
      const o = n.getMessage(a.type);
      if (o)
        try {
          r.push(Nb(o, a.value));
        } catch {
        }
    }
    return r;
  }
}
function CZ(e, t) {
  return e.length ? `[${$y(t)}] ${e}` : `[${$y(t)}]`;
}
function KZ(...e) {
  const t = new Headers();
  for (const n of e)
    n.forEach((r, a) => {
      t.append(a, r);
    });
  return t;
}
const dO = 1;
function XZ(e, t, n = !1) {
  if (t > e) {
    let r = `message size is larger than configured readMaxBytes ${e}`;
    throw n && (r = `message size ${t} is larger than configured readMaxBytes ${e}`), new Oe(r, x.ResourceExhausted);
  }
}
function WZ(e) {
  return new JZ(e);
}
class JZ {
  constructor(t) {
    this.readMaxBytes = t, this.header = new Uint8Array(5), this.headerView = new DataView(this.header.buffer), this.buf = [];
  }
  get byteLength() {
    return this.buf.reduce((t, n) => t + n.byteLength, 0);
  }
  decode(t) {
    this.buf.push(t);
    const n = [];
    for (; ; ) {
      let r = this.pop();
      if (!r)
        break;
      n.push(r);
    }
    return n;
  }
  // consume an enveloped message
  pop() {
    if (!(!this.env && (this.env = this.head(), !this.env)) && this.cons(this.env.data)) {
      const t = this.env;
      return this.env = void 0, t;
    }
  }
  // consume header
  head() {
    if (!this.cons(this.header))
      return;
    const t = this.headerView.getUint8(0), n = this.headerView.getUint32(1);
    return XZ(this.readMaxBytes, n, !0), {
      flags: t,
      data: new Uint8Array(n)
    };
  }
  // consume from buffer, fill target
  cons(t) {
    const n = t.byteLength;
    if (this.byteLength < n)
      return !1;
    let r = 0;
    for (; r < n; ) {
      const a = this.buf.shift();
      a.byteLength > n - r ? (t.set(a.subarray(0, n - r), r), this.buf.unshift(a.subarray(n - r)), r += n - r) : (t.set(a, r), r += a.byteLength);
    }
    return !0;
  }
}
function ZZ(e) {
  let t;
  const n = WZ(4294967295);
  return new ReadableStream({
    start() {
      t = e.getReader();
    },
    async pull(r) {
      let a = !1;
      for (; !a; ) {
        const o = await t.read();
        if (o.done)
          n.byteLength > 0 && r.error(new Oe("protocol error: incomplete envelope", x.InvalidArgument)), r.close();
        else
          for (const s of n.decode(o.value))
            r.enqueue(s), a = !0;
      }
    }
  });
}
function HZ(e, t) {
  const n = new Uint8Array(t.length + 5);
  n.set(t, 5);
  const r = new DataView(n.buffer, n.byteOffset, n.byteLength);
  return r.setUint8(0, e), r.setUint32(1, t.length), n;
}
function zZ(...e) {
  const t = new AbortController(), n = e.filter((a) => a !== void 0).concat(t.signal);
  for (const a of n) {
    if (a.aborted) {
      r.apply(a);
      break;
    }
    a.addEventListener("abort", r);
  }
  function r() {
    t.signal.aborted || t.abort(pR(this));
    for (const a of n)
      a.removeEventListener("abort", r);
  }
  return t;
}
function qZ(e) {
  const t = new AbortController(), n = () => {
    t.abort(new Oe("the operation timed out", x.DeadlineExceeded));
  };
  let r;
  return e !== void 0 && (e <= 0 ? n() : r = setTimeout(n, e)), {
    signal: t.signal,
    cleanup: () => clearTimeout(r)
  };
}
function pR(e) {
  if (!e.aborted)
    return;
  if (e.reason !== void 0)
    return e.reason;
  const t = new Error("This operation was aborted");
  return t.name = "AbortError", t;
}
function pO() {
  return {
    get(e) {
      return e.id in this ? this[e.id] : e.defaultValue;
    },
    set(e, t) {
      return this[e.id] = t, this;
    },
    delete(e) {
      return delete this[e.id], this;
    }
  };
}
function bO(e, t) {
  return e.toString().replace(/\/?$/, `/${t.parent.typeName}/${t.name}`);
}
function bR(e, t) {
  return gr(e, t);
}
function QZ(e, t) {
  function n(r) {
    return r.done === !0 ? r : {
      done: r.done,
      value: bR(e, r.value)
    };
  }
  return {
    [Symbol.asyncIterator]() {
      const r = t[Symbol.asyncIterator](), a = {
        next: () => r.next().then(n)
      };
      return r.throw !== void 0 && (a.throw = (o) => r.throw(o).then(n)), r.return !== void 0 && (a.return = (o) => r.return(o).then(n)), a;
    }
  };
}
function gR(e, t) {
  if (!t)
    return e;
  for (const n of t.concat().reverse())
    e = n(e);
  return e;
}
function hR(e) {
  var t;
  const n = Object.assign({}, e);
  return (t = n.ignoreUnknownFields) !== null && t !== void 0 || (n.ignoreUnknownFields = !0), n;
}
function gO(e, t, n, r) {
  const a = t ? hO(e.input, r) : yO(e.input, n);
  return { parse: (t ? hO(e.output, r) : yO(e.output, n)).parse, serialize: a.serialize };
}
function hO(e, t) {
  return {
    parse(n) {
      try {
        return Nb(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Oe(`parse binary: ${a}`, x.Internal);
      }
    },
    serialize(n) {
      try {
        return eR(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Oe(`serialize binary: ${a}`, x.Internal);
      }
    }
  };
}
function yO(e, t) {
  var n, r;
  const a = (n = t?.textEncoder) !== null && n !== void 0 ? n : new TextEncoder(), o = (r = t?.textDecoder) !== null && r !== void 0 ? r : new TextDecoder(), s = hR(t);
  return {
    parse(i) {
      try {
        const u = o.decode(i);
        return AZ(e, u, s);
      } catch (u) {
        throw Oe.from(u, x.InvalidArgument);
      }
    },
    serialize(i) {
      try {
        const u = EZ(e, i, s);
        return a.encode(u);
      } catch (u) {
        throw Oe.from(u, x.Internal);
      }
    }
  };
}
const eH = /^application\/(connect\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i, tH = "application/proto", nH = "application/json", rH = "application/connect+proto", aH = "application/connect+json";
function oH(e) {
  const t = e?.match(eH);
  if (!t)
    return;
  const n = !!t[1], r = !!t[3];
  return { stream: n, binary: r };
}
function yR(e, t, n) {
  var r;
  if (t && new Headers(t).forEach((i, u) => n.metadata.append(u, i)), typeof e != "object" || e == null || Array.isArray(e))
    throw n;
  let a = n.code;
  "code" in e && typeof e.code == "string" && (a = (r = MZ(e.code)) !== null && r !== void 0 ? r : a);
  const o = e.message;
  if (o != null && typeof o != "string")
    throw n;
  const s = new Oe(o ?? "", a, t);
  if ("details" in e && Array.isArray(e.details))
    for (const i of e.details) {
      if (i === null || typeof i != "object" || Array.isArray(i) || typeof i.type != "string" || typeof i.value != "string")
        throw n;
      try {
        s.details.push({
          type: i.type,
          value: I0(i.value),
          debug: i.debug
        });
      } catch {
        throw n;
      }
    }
  return s;
}
const NO = 2;
function sH(e) {
  const t = new Oe("invalid end stream", x.Unknown);
  let n;
  try {
    n = JSON.parse(typeof e == "string" ? e : new TextDecoder().decode(e));
  } catch {
    throw t;
  }
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw t;
  const r = new Headers();
  if ("metadata" in n) {
    if (typeof n.metadata != "object" || n.metadata == null || Array.isArray(n.metadata))
      throw t;
    for (const [o, s] of Object.entries(n.metadata)) {
      if (!Array.isArray(s) || s.some((i) => typeof i != "string"))
        throw t;
      for (const i of s)
        r.append(o, i);
    }
  }
  const a = "error" in n && n.error != null ? yR(n.error, r, t) : void 0;
  return { metadata: r, error: a };
}
const Bd = "Content-Type", iH = "Content-Length", EO = "Content-Encoding", uH = "Accept-Encoding", lH = "Connect-Timeout-Ms", NR = "Connect-Protocol-Version", cH = "User-Agent";
function fH(e) {
  switch (e) {
    case 400:
      return x.Internal;
    case 401:
      return x.Unauthenticated;
    case 403:
      return x.PermissionDenied;
    case 404:
      return x.Unimplemented;
    case 429:
      return x.Unavailable;
    case 502:
      return x.Unavailable;
    case 503:
      return x.Unavailable;
    case 504:
      return x.Unavailable;
    default:
      return x.Unknown;
  }
}
function vO(e) {
  const t = new Headers(), n = new Headers();
  return e.forEach((r, a) => {
    a.toLowerCase().startsWith("trailer-") ? n.append(a.substring(8), r) : t.append(a, r);
  }), [t, n];
}
const ER = "1";
function TO(e, t, n, r, a) {
  const o = new Headers(r ?? {});
  return n !== void 0 && o.set(lH, `${n}`), o.set(Bd, e == "unary" ? t ? tH : nH : t ? rH : aH), o.set(NR, ER), o.has(cH), o;
}
function IO(e, t, n, r) {
  const a = r.get(Bd), o = oH(a);
  if (n !== 200) {
    const i = new Oe(`HTTP ${n}`, fH(n), r);
    if (e == "unary" && o && !o.binary)
      return { isUnaryError: !0, unaryError: i };
    throw i;
  }
  const s = {
    binary: t,
    stream: e !== "unary"
  };
  if (o?.binary !== s.binary || o.stream !== s.stream)
    throw new Oe(`unsupported content type ${a}`, o === void 0 ? x.Unknown : x.Internal, r);
  return { isUnaryError: !1 };
}
const wO = "application/";
function mH(e, t) {
  return t ? M4(e, "url") : encodeURIComponent(new TextDecoder().decode(e));
}
function dH(e, t, n) {
  let r = `?connect=v${ER}`;
  const a = e.header.get(Bd);
  a?.indexOf(wO) === 0 && (r += "&encoding=" + encodeURIComponent(a.slice(wO.length)));
  const o = e.header.get(EO);
  o !== null && o !== "identity" && (r += "&compression=" + encodeURIComponent(o), n = !0), n && (r += "&base64=1"), r += "&message=" + mH(t, n);
  const s = e.url + r, i = new Headers(e.header);
  for (const u of [
    NR,
    Bd,
    iH,
    EO,
    uH
  ])
    i.delete(u);
  return Object.assign(Object.assign({}, e), {
    requestMethod: "GET",
    url: s,
    header: i
  });
}
function pH(e) {
  const t = gR(e.next, e.interceptors), [n, r, a] = vR(e), o = Object.assign(Object.assign({}, e.req), { message: bR(e.req.method.input, e.req.message), signal: n });
  return t(o).then((s) => (a(), s), r);
}
function bH(e) {
  const t = gR(e.next, e.interceptors), [n, r, a] = vR(e), o = Object.assign(Object.assign({}, e.req), { message: QZ(e.req.method.input, e.req.message), signal: n });
  let s = !1;
  return n.addEventListener("abort", function() {
    var i, u;
    const l = e.req.message[Symbol.asyncIterator]();
    s || (i = l.throw) === null || i === void 0 || i.call(l, this.reason).catch(() => {
    }), (u = l.return) === null || u === void 0 || u.call(l).catch(() => {
    });
  }), t(o).then((i) => Object.assign(Object.assign({}, i), { message: {
    [Symbol.asyncIterator]() {
      const u = i.message[Symbol.asyncIterator]();
      return {
        next() {
          return u.next().then((l) => (l.done == !0 && (s = !0, a()), l), r);
        }
        // We deliberately omit throw/return.
      };
    }
  } }), r);
}
function vR(e) {
  const { signal: t, cleanup: n } = qZ(e.timeoutMs), r = zZ(e.signal, t);
  return [
    r.signal,
    function(a) {
      const o = Oe.from(t.aborted ? pR(t) : a);
      return r.abort(o), n(), Promise.reject(o);
    },
    function() {
      n(), r.abort();
    }
  ];
}
function gH() {
  try {
    new Headers();
  } catch {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}
var Nl = function(e) {
  return this instanceof Nl ? (this.v = e, this) : new Nl(e);
}, hH = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof Nl ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
const _O = {
  redirect: "error"
};
function yH(e) {
  var t;
  gH();
  const n = (t = e.useBinaryFormat) !== null && t !== void 0 ? t : !1;
  return {
    async unary(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = gO(r, n, e.jsonOptions, e.binaryOptions);
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await pH({
        interceptors: e.interceptors,
        signal: a,
        timeoutMs: o,
        req: {
          stream: !1,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: bO(e.baseUrl, r),
          header: TO(r.methodKind, n, o, s),
          contextValues: u ?? pO(),
          message: i
        },
        next: async (f) => {
          var d;
          const m = e.useHttpGet === !0 && r.idempotency === Uy.NO_SIDE_EFFECTS;
          let p = null;
          m ? f = dH(f, l(f.message), n) : p = l(f.message);
          const b = await ((d = e.fetch) !== null && d !== void 0 ? d : globalThis.fetch)(f.url, Object.assign(Object.assign({}, _O), { method: f.requestMethod, headers: f.header, signal: f.signal, body: p })), { isUnaryError: g, unaryError: S } = IO(r.methodKind, n, b.status, b.headers);
          if (g)
            throw yR(await b.json(), KZ(...vO(b.headers)), S);
          const [D, k] = vO(b.headers);
          return {
            stream: !1,
            service: r.parent,
            method: r,
            header: D,
            message: n ? c(new Uint8Array(await b.arrayBuffer())) : lR(r.output, await b.json(), hR(e.jsonOptions)),
            trailer: k
          };
        }
      });
    },
    async stream(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = gO(r, n, e.jsonOptions, e.binaryOptions);
      function f(m, p, b, g) {
        return hH(this, arguments, function* () {
          const S = ZZ(m).getReader();
          let D = !1;
          for (; ; ) {
            const k = yield Nl(S.read());
            if (k.done)
              break;
            const { flags: U, data: R } = k.value;
            if ((U & dO) === dO)
              throw new Oe("protocol error: received unsupported compressed output", x.Internal);
            if ((U & NO) === NO) {
              D = !0;
              const F = sH(R);
              if (F.error) {
                const A = F.error;
                throw b.forEach((L, re) => {
                  A.metadata.append(re, L);
                }), A;
              }
              F.metadata.forEach((A, L) => p.set(L, A));
              continue;
            }
            yield yield Nl(c(R));
          }
          if ("throwIfAborted" in g && g.throwIfAborted(), !D)
            throw "missing EndStreamResponse";
        });
      }
      async function d(m) {
        if (r.methodKind != "server_streaming")
          throw "The fetch API does not support streaming request bodies";
        const p = await m[Symbol.asyncIterator]().next();
        if (p.done == !0)
          throw "missing request message";
        return HZ(0, l(p.value));
      }
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await bH({
        interceptors: e.interceptors,
        timeoutMs: o,
        signal: a,
        req: {
          stream: !0,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: bO(e.baseUrl, r),
          header: TO(r.methodKind, n, o, s),
          contextValues: u ?? pO(),
          message: i
        },
        next: async (m) => {
          var p;
          const b = await ((p = e.fetch) !== null && p !== void 0 ? p : globalThis.fetch)(m.url, Object.assign(Object.assign({}, _O), { method: m.requestMethod, headers: m.header, signal: m.signal, body: await d(m.message) }));
          if (IO(r.methodKind, n, b.status, b.headers), b.body === null)
            throw "missing response body";
          const g = new Headers();
          return Object.assign(Object.assign({}, m), { header: b.headers, trailer: g, message: f(b.body, g, b.headers, m.signal) });
        }
      });
    }
  };
}
yH({
  baseUrl: "/api",
  useBinaryFormat: !0,
  fetch: (e, t) => {
    const n = t?.headers ?? {};
    return fetch(e, {
      ...t,
      headers: {
        ...n,
        "qt-widget-id": window.qtWidgetId
      }
    });
  }
});
const pt = /* @__PURE__ */ Symbol(), NH = !1;
var EH = Array.isArray, vH = Array.prototype.indexOf, Xg = Object.getOwnPropertyDescriptor, TH = Object.prototype, IH = Array.prototype, wH = Object.getPrototypeOf;
function _H(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function OH() {
  var e, t, n = new Promise((r, a) => {
    e = r, t = a;
  });
  return { promise: n, resolve: e, reject: t };
}
const sn = 2, SH = 4, DH = 1 << 24, Tu = 16, Zc = 32, Hc = 64, F0 = 128, Kr = 512, It = 1024, hr = 2048, Xr = 4096, zm = 8192, ls = 16384, kH = 32768, OO = 1 << 17, TR = 1 << 18, xs = 32768, Py = 1 << 21, IR = 1 << 22, El = 1 << 23, Wg = /* @__PURE__ */ Symbol("$state"), wR = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function AH() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function LH() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function FH() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function UH() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function RH(e) {
  return e === this.v;
}
let $H = !1;
function _R() {
  return !0;
}
let bi = [];
function PH() {
  var e = bi;
  bi = [], _H(e);
}
function VH(e) {
  if (bi.length === 0) {
    var t = bi;
    queueMicrotask(() => {
      t === bi && PH();
    });
  }
  bi.push(e);
}
function xH(e) {
  var t = Pt;
  if (t === null)
    return he.f |= El, e;
  if ((t.f & kH) === 0) {
    if ((t.f & F0) === 0)
      throw e;
    t.b.error(e);
  } else
    OR(e, t);
}
function OR(e, t) {
  for (; t !== null; ) {
    if ((t.f & F0) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e;
}
const im = /* @__PURE__ */ new Set();
let We = null, xn = null, Rr = [], U0 = null, Vy = !1;
class vl {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #e = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #i = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    Rr = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const r of t)
      this.#u(r, n);
    this.is_fork || this.#c(), this.is_deferred() ? (this.#n(n.effects), this.#n(n.render_effects)) : (We = null, SO(n.render_effects), SO(n.effects), this.#i?.resolve()), xn = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #u(t, n) {
    t.f ^= It;
    for (var r = t.first; r !== null; ) {
      var a = r.f, o = (a & (Zc | Hc)) !== 0, s = o && (a & It) !== 0, i = s || (a & zm) !== 0 || this.skipped_effects.has(r);
      if ((r.f & F0) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: []
      }), !i && r.fn !== null) {
        o ? r.f ^= It : (a & SH) !== 0 ? n.effects.push(r) : qc(r) && ((r.f & Tu) !== 0 && this.#o.add(r), Xd(r));
        var u = r.first;
        if (u !== null) {
          r = u;
          continue;
        }
      }
      var l = r.parent;
      for (r = r.next; r === null && l !== null; )
        l === n.effect && (this.#n(n.effects), this.#n(n.render_effects), n = /** @type {EffectTarget} */
        n.parent), r = l.next, l = l.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #n(t) {
    for (const n of t)
      (n.f & hr) !== 0 ? this.#o.add(n) : (n.f & Xr) !== 0 && this.#s.add(n), this.#l(n.deps), Vt(n, It);
  }
  /**
   * @param {Value[] | null} deps
   */
  #l(t) {
    if (t !== null)
      for (const n of t)
        (n.f & sn) === 0 || (n.f & xs) === 0 || (n.f ^= xs, this.#l(
          /** @type {Derived} */
          n.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.previous.has(t) || this.previous.set(t, n), (t.f & El) === 0 && (this.current.set(t, t.v), xn?.set(t, t.v));
  }
  activate() {
    We = this, this.apply();
  }
  deactivate() {
    We === this && (We = null, xn = null);
  }
  flush() {
    if (this.activate(), Rr.length > 0) {
      if (YH(), We !== null && We !== this)
        return;
    } else this.#e === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const t of this.#a) t(this);
    this.#a.clear();
  }
  #c() {
    if (this.#t === 0) {
      for (const t of this.#r) t();
      this.#r.clear();
    }
    this.#e === 0 && this.#f();
  }
  #f() {
    if (im.size > 1) {
      this.previous.clear();
      var t = xn, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const o of im) {
        if (o === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [u, l] of this.current) {
          if (o.current.has(u))
            if (n && l !== o.current.get(u))
              o.current.set(u, l);
            else
              continue;
          s.push(u);
        }
        if (s.length === 0)
          continue;
        const i = [...o.current.keys()].filter((u) => !this.current.has(u));
        if (i.length > 0) {
          var a = Rr;
          Rr = [];
          const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            SR(c, i, u, l);
          if (Rr.length > 0) {
            We = o, o.apply();
            for (const c of Rr)
              o.#u(c, r);
            o.deactivate();
          }
          Rr = a;
        }
      }
      We = null, xn = t;
    }
    this.committed = !0, im.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(t) {
    this.#e += 1, t && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(t) {
    this.#e -= 1, t && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const t of this.#o)
      this.#s.delete(t), Vt(t, hr), Tl(t);
    for (const t of this.#s)
      Vt(t, Xr), Tl(t);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(t) {
    this.#r.add(t);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(t) {
    this.#a.add(t);
  }
  settled() {
    return (this.#i ??= OH()).promise;
  }
  static ensure() {
    if (We === null) {
      const t = We = new vl();
      im.add(We), vl.enqueue(() => {
        We === t && t.flush();
      });
    }
    return We;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    VH(t);
  }
  apply() {
  }
}
function YH() {
  var e = cs;
  Vy = !0;
  try {
    var t = 0;
    for (Md(!0); Rr.length > 0; ) {
      var n = vl.ensure();
      if (t++ > 1e3) {
        var r, a;
        jH();
      }
      n.process(Rr), uo.clear();
    }
  } finally {
    Vy = !1, Md(e), U0 = null;
  }
}
function jH() {
  try {
    AH();
  } catch (e) {
    OR(e, U0);
  }
}
let ma = null;
function SO(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (ls | zm)) === 0 && qc(r) && (ma = /* @__PURE__ */ new Set(), Xd(r), r.deps === null && r.first === null && r.nodes === null && (r.teardown === null && r.ac === null ? PR(r) : r.fn = null), ma?.size > 0)) {
        uo.clear();
        for (const a of ma) {
          if ((a.f & (ls | zm)) !== 0) continue;
          const o = [a];
          let s = a.parent;
          for (; s !== null; )
            ma.has(s) && (ma.delete(s), o.push(s)), s = s.parent;
          for (let i = o.length - 1; i >= 0; i--) {
            const u = o[i];
            (u.f & (ls | zm)) === 0 && Xd(u);
          }
        }
        ma.clear();
      }
    }
    ma = null;
  }
}
function SR(e, t, n, r) {
  if (!n.has(e) && (n.add(e), e.reactions !== null))
    for (const a of e.reactions) {
      const o = a.f;
      (o & sn) !== 0 ? SR(
        /** @type {Derived} */
        a,
        t,
        n,
        r
      ) : (o & (IR | Tu)) !== 0 && (o & hr) === 0 && DR(a, t, r) && (Vt(a, hr), Tl(
        /** @type {Effect} */
        a
      ));
    }
}
function DR(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (e.deps !== null)
    for (const a of e.deps) {
      if (t.includes(a))
        return !0;
      if ((a.f & sn) !== 0 && DR(
        /** @type {Derived} */
        a,
        t,
        n
      ))
        return n.set(
          /** @type {Derived} */
          a,
          !0
        ), !0;
    }
  return n.set(e, !1), !1;
}
function Tl(e) {
  for (var t = U0 = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (Vy && t === Pt && (n & Tu) !== 0 && (n & TR) === 0)
      return;
    if ((n & (Hc | Zc)) !== 0) {
      if ((n & It) === 0) return;
      t.f ^= It;
    }
  }
  Rr.push(t);
}
function kR(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      $0(
        /** @type {Effect} */
        t[n]
      );
  }
}
function BH(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & sn) === 0)
      return (t.f & ls) === 0 ? (
        /** @type {Effect} */
        t
      ) : null;
    t = t.parent;
  }
  return null;
}
function R0(e) {
  var t, n = Pt;
  Cd(BH(e));
  try {
    e.f &= ~xs, kR(e), t = jR(e);
  } finally {
    Cd(n);
  }
  return t;
}
function AR(e) {
  var t = R0(e);
  if (e.equals(t) || (We?.is_fork || (e.v = t), e.wv = xR()), !zc)
    if (xn !== null)
      (Gd() || We?.is_fork) && xn.set(e, t);
    else {
      var n = (e.f & Kr) === 0 ? Xr : It;
      Vt(e, n);
    }
}
let xy = /* @__PURE__ */ new Set();
const uo = /* @__PURE__ */ new Map();
let LR = !1;
function GH(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: RH,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function Ha(e, t) {
  const n = GH(e);
  return ZH(n), n;
}
function Uo(e, t, n = !1) {
  he !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Ho || (he.f & OO) !== 0) && _R() && (he.f & (sn | Tu | IR | OO)) !== 0 && !Ya?.includes(e) && UH();
  let r = n ? gi(t) : t;
  return MH(e, r);
}
function MH(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    zc ? uo.set(e, t) : uo.set(e, n), e.v = t;
    var r = vl.ensure();
    r.capture(e, n), (e.f & sn) !== 0 && ((e.f & hr) !== 0 && R0(
      /** @type {Derived} */
      e
    ), Vt(e, (e.f & Kr) !== 0 ? It : Xr)), e.wv = xR(), FR(e, hr), Pt !== null && (Pt.f & It) !== 0 && (Pt.f & (Zc | Hc)) === 0 && (Dn === null ? HH([e]) : Dn.push(e)), !r.is_fork && xy.size > 0 && !LR && CH();
  }
  return t;
}
function CH() {
  LR = !1;
  var e = cs;
  Md(!0);
  const t = Array.from(xy);
  try {
    for (const n of t)
      (n.f & It) !== 0 && Vt(n, Xr), qc(n) && Xd(n);
  } finally {
    Md(e);
  }
  xy.clear();
}
function Jg(e) {
  Uo(e, e.v + 1);
}
function FR(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, a = 0; a < r; a++) {
      var o = n[a], s = o.f, i = (s & hr) === 0;
      if (i && Vt(o, t), (s & sn) !== 0) {
        var u = (
          /** @type {Derived} */
          o
        );
        xn?.delete(u), (s & xs) === 0 && (s & Kr && (o.f |= xs), FR(u, Xr));
      } else i && ((s & Tu) !== 0 && ma !== null && ma.add(
        /** @type {Effect} */
        o
      ), Tl(
        /** @type {Effect} */
        o
      ));
    }
}
function gi(e) {
  if (typeof e != "object" || e === null || Wg in e)
    return e;
  const t = wH(e);
  if (t !== TH && t !== IH)
    return e;
  var n = /* @__PURE__ */ new Map(), r = EH(e), a = /* @__PURE__ */ Ha(0), o = fs, s = (i) => {
    if (fs === o)
      return i();
    var u = he, l = fs;
    Ki(null), kO(o);
    var c = i();
    return Ki(u), kO(l), c;
  };
  return r && n.set("length", /* @__PURE__ */ Ha(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(i, u, l) {
        (!("value" in l) || l.configurable === !1 || l.enumerable === !1 || l.writable === !1) && LH();
        var c = n.get(u);
        return c === void 0 ? c = s(() => {
          var f = /* @__PURE__ */ Ha(l.value);
          return n.set(u, f), f;
        }) : Uo(c, l.value, !0), !0;
      },
      deleteProperty(i, u) {
        var l = n.get(u);
        if (l === void 0) {
          if (u in i) {
            const c = s(() => /* @__PURE__ */ Ha(pt));
            n.set(u, c), Jg(a);
          }
        } else
          Uo(l, pt), Jg(a);
        return !0;
      },
      get(i, u, l) {
        if (u === Wg)
          return e;
        var c = n.get(u), f = u in i;
        if (c === void 0 && (!f || Xg(i, u)?.writable) && (c = s(() => {
          var m = gi(f ? i[u] : pt), p = /* @__PURE__ */ Ha(m);
          return p;
        }), n.set(u, c)), c !== void 0) {
          var d = um(c);
          return d === pt ? void 0 : d;
        }
        return Reflect.get(i, u, l);
      },
      getOwnPropertyDescriptor(i, u) {
        var l = Reflect.getOwnPropertyDescriptor(i, u);
        if (l && "value" in l) {
          var c = n.get(u);
          c && (l.value = um(c));
        } else if (l === void 0) {
          var f = n.get(u), d = f?.v;
          if (f !== void 0 && d !== pt)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return l;
      },
      has(i, u) {
        if (u === Wg)
          return !0;
        var l = n.get(u), c = l !== void 0 && l.v !== pt || Reflect.has(i, u);
        if (l !== void 0 || Pt !== null && (!c || Xg(i, u)?.writable)) {
          l === void 0 && (l = s(() => {
            var d = c ? gi(i[u]) : pt, m = /* @__PURE__ */ Ha(d);
            return m;
          }), n.set(u, l));
          var f = um(l);
          if (f === pt)
            return !1;
        }
        return c;
      },
      set(i, u, l, c) {
        var f = n.get(u), d = u in i;
        if (r && u === "length")
          for (var m = l; m < /** @type {Source<number>} */
          f.v; m += 1) {
            var p = n.get(m + "");
            p !== void 0 ? Uo(p, pt) : m in i && (p = s(() => /* @__PURE__ */ Ha(pt)), n.set(m + "", p));
          }
        if (f === void 0)
          (!d || Xg(i, u)?.writable) && (f = s(() => /* @__PURE__ */ Ha(void 0)), Uo(f, gi(l)), n.set(u, f));
        else {
          d = f.v !== pt;
          var b = s(() => gi(l));
          Uo(f, b);
        }
        var g = Reflect.getOwnPropertyDescriptor(i, u);
        if (g?.set && g.set.call(c, l), !d) {
          if (r && typeof u == "string") {
            var S = (
              /** @type {Source<number>} */
              n.get("length")
            ), D = Number(u);
            Number.isInteger(D) && D >= S.v && Uo(S, D + 1);
          }
          Jg(a);
        }
        return !0;
      },
      ownKeys(i) {
        um(a);
        var u = Reflect.ownKeys(i).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== pt;
        });
        for (var [l, c] of n)
          c.v !== pt && !(l in i) && u.push(l);
        return u;
      },
      setPrototypeOf() {
        FH();
      }
    }
  );
}
var KH;
// @__NO_SIDE_EFFECTS__
function XH(e) {
  return (
    /** @type {TemplateNode | null} */
    KH.call(e)
  );
}
function UR(e) {
  var t = he, n = Pt;
  Ki(null), Cd(null);
  try {
    return e();
  } finally {
    Ki(t), Cd(n);
  }
}
function Gd() {
  return he !== null && !Ho;
}
function RR(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = zc, r = he;
    DO(!0), Ki(null);
    try {
      t.call(null);
    } finally {
      DO(n), Ki(r);
    }
  }
}
function $R(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const a = n.ac;
    a !== null && UR(() => {
      a.abort(wR);
    });
    var r = n.next;
    (n.f & Hc) !== 0 ? n.parent = null : $0(n, t), n = r;
  }
}
function WH(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & Zc) === 0 && $0(t), t = n;
  }
}
function $0(e, t = !0) {
  var n = !1;
  (t || (e.f & TR) !== 0) && e.nodes !== null && e.nodes.end !== null && (JH(
    e.nodes.start,
    /** @type {TemplateNode} */
    e.nodes.end
  ), n = !0), $R(e, t && !n), Kd(e, 0), Vt(e, ls);
  var r = e.nodes && e.nodes.t;
  if (r !== null)
    for (const o of r)
      o.stop();
  RR(e);
  var a = e.parent;
  a !== null && a.first !== null && PR(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes = e.ac = null;
}
function JH(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : /* @__PURE__ */ XH(e);
    e.remove(), e = n;
  }
}
function PR(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
let cs = !1;
function Md(e) {
  cs = e;
}
let zc = !1;
function DO(e) {
  zc = e;
}
let he = null, Ho = !1;
function Ki(e) {
  he = e;
}
let Pt = null;
function Cd(e) {
  Pt = e;
}
let Ya = null;
function ZH(e) {
  he !== null && (Ya === null ? Ya = [e] : Ya.push(e));
}
let rt = null, hn = 0, Dn = null;
function HH(e) {
  Dn = e;
}
let VR = 1, Il = 0, fs = Il;
function kO(e) {
  fs = e;
}
function xR() {
  return ++VR;
}
function qc(e) {
  var t = e.f;
  if ((t & hr) !== 0)
    return !0;
  if (t & sn && (e.f &= ~xs), (t & Xr) !== 0) {
    var n = e.deps;
    if (n !== null)
      for (var r = n.length, a = 0; a < r; a++) {
        var o = n[a];
        if (qc(
          /** @type {Derived} */
          o
        ) && AR(
          /** @type {Derived} */
          o
        ), o.wv > e.wv)
          return !0;
      }
    (t & Kr) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    xn === null && Vt(e, It);
  }
  return !1;
}
function YR(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !Ya?.includes(e))
    for (var a = 0; a < r.length; a++) {
      var o = r[a];
      (o.f & sn) !== 0 ? YR(
        /** @type {Derived} */
        o,
        t,
        !1
      ) : t === o && (n ? Vt(o, hr) : (o.f & It) !== 0 && Vt(o, Xr), Tl(
        /** @type {Effect} */
        o
      ));
    }
}
function jR(e) {
  var t = rt, n = hn, r = Dn, a = he, o = Ya, s = Ho, i = fs, u = e.f;
  rt = /** @type {null | Value[]} */
  null, hn = 0, Dn = null, he = (u & (Zc | Hc)) === 0 ? e : null, Ya = null, e.ctx, Ho = !1, fs = ++Il, e.ac !== null && (UR(() => {
    e.ac.abort(wR);
  }), e.ac = null);
  try {
    e.f |= Py;
    var l = (
      /** @type {Function} */
      e.fn
    ), c = l(), f = e.deps;
    if (rt !== null) {
      var d;
      if (Kd(e, hn), f !== null && hn > 0)
        for (f.length = hn + rt.length, d = 0; d < rt.length; d++)
          f[hn + d] = rt[d];
      else
        e.deps = f = rt;
      if (Gd() && (e.f & Kr) !== 0)
        for (d = hn; d < f.length; d++)
          (f[d].reactions ??= []).push(e);
    } else f !== null && hn < f.length && (Kd(e, hn), f.length = hn);
    if (_R() && Dn !== null && !Ho && f !== null && (e.f & (sn | Xr | hr)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      Dn.length; d++)
        YR(
          Dn[d],
          /** @type {Effect} */
          e
        );
    return a !== null && a !== e && (Il++, Dn !== null && (r === null ? r = Dn : r.push(.../** @type {Source[]} */
    Dn))), (e.f & El) !== 0 && (e.f ^= El), c;
  } catch (m) {
    return xH(m);
  } finally {
    e.f ^= Py, rt = t, hn = n, Dn = r, he = a, Ya = o, Ho = s, fs = i;
  }
}
function zH(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = vH.call(n, e);
    if (r !== -1) {
      var a = n.length - 1;
      a === 0 ? n = t.reactions = null : (n[r] = n[a], n.pop());
    }
  }
  n === null && (t.f & sn) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (rt === null || !rt.includes(t)) && (Vt(t, Xr), (t.f & Kr) !== 0 && (t.f ^= Kr, t.f &= ~xs), kR(
    /** @type {Derived} **/
    t
  ), Kd(
    /** @type {Derived} **/
    t,
    0
  ));
}
function Kd(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      zH(e, n[r]);
}
function Xd(e) {
  var t = e.f;
  if ((t & ls) === 0) {
    Vt(e, It);
    var n = Pt, r = cs;
    Pt = e, cs = !0;
    try {
      (t & (Tu | DH)) !== 0 ? WH(e) : $R(e), RR(e);
      var a = jR(e);
      e.teardown = typeof a == "function" ? a : null, e.wv = VR;
      var o;
      NH && $H && (e.f & hr) !== 0 && e.deps;
    } finally {
      cs = r, Pt = n;
    }
  }
}
function um(e) {
  var t = e.f, n = (t & sn) !== 0;
  if (he !== null && !Ho) {
    var r = Pt !== null && (Pt.f & ls) !== 0;
    if (!r && !Ya?.includes(e)) {
      var a = he.deps;
      if ((he.f & Py) !== 0)
        e.rv < Il && (e.rv = Il, rt === null && a !== null && a[hn] === e ? hn++ : rt === null ? rt = [e] : rt.includes(e) || rt.push(e));
      else {
        (he.deps ??= []).push(e);
        var o = e.reactions;
        o === null ? e.reactions = [he] : o.includes(he) || o.push(he);
      }
    }
  }
  if (zc) {
    if (uo.has(e))
      return uo.get(e);
    if (n) {
      var s = (
        /** @type {Derived} */
        e
      ), i = s.v;
      return ((s.f & It) === 0 && s.reactions !== null || GR(s)) && (i = R0(s)), uo.set(s, i), i;
    }
  } else n && (!xn?.has(e) || We?.is_fork && !Gd()) && (s = /** @type {Derived} */
  e, qc(s) && AR(s), cs && Gd() && (s.f & Kr) === 0 && BR(s));
  if (xn?.has(e))
    return xn.get(e);
  if ((e.f & El) !== 0)
    throw e.v;
  return e.v;
}
function BR(e) {
  if (e.deps !== null) {
    e.f ^= Kr;
    for (const t of e.deps)
      (t.reactions ??= []).push(e), (t.f & sn) !== 0 && (t.f & Kr) === 0 && BR(
        /** @type {Derived} */
        t
      );
  }
}
function GR(e) {
  if (e.v === pt) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (uo.has(t) || (t.f & sn) !== 0 && GR(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
const qH = -7169;
function Vt(e, t) {
  e.f = e.f & qH | t;
}
function MR() {
  return {
    isDark: document.documentElement.classList.contains("night-mode")
  };
}
const QH = gi(MR()), ez = new MutationObserver((e, t) => {
  QH.isDark = MR().isDark;
});
ez.observe(document.documentElement, { attributeFilter: ["class"] });
const tz = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(tz);
var Y;
(function(e) {
  e[e.Canceled = 1] = "Canceled", e[e.Unknown = 2] = "Unknown", e[e.InvalidArgument = 3] = "InvalidArgument", e[e.DeadlineExceeded = 4] = "DeadlineExceeded", e[e.NotFound = 5] = "NotFound", e[e.AlreadyExists = 6] = "AlreadyExists", e[e.PermissionDenied = 7] = "PermissionDenied", e[e.ResourceExhausted = 8] = "ResourceExhausted", e[e.FailedPrecondition = 9] = "FailedPrecondition", e[e.Aborted = 10] = "Aborted", e[e.OutOfRange = 11] = "OutOfRange", e[e.Unimplemented = 12] = "Unimplemented", e[e.Internal = 13] = "Internal", e[e.Unavailable = 14] = "Unavailable", e[e.DataLoss = 15] = "DataLoss", e[e.Unauthenticated = 16] = "Unauthenticated";
})(Y || (Y = {}));
function P0(e, t) {
  return e !== null && typeof e == "object" && "$typeName" in e && typeof e.$typeName == "string" ? t === void 0 ? !0 : t.typeName === e.$typeName : !1;
}
var E;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(E || (E = {}));
function nz() {
  let e = 0, t = 0;
  for (let r = 0; r < 28; r += 7) {
    let a = this.buf[this.pos++];
    if (e |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  let n = this.buf[this.pos++];
  if (e |= (n & 15) << 28, t = (n & 112) >> 4, (n & 128) == 0)
    return this.assertBounds(), [e, t];
  for (let r = 3; r <= 31; r += 7) {
    let a = this.buf[this.pos++];
    if (t |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  throw new Error("invalid varint");
}
function Zg(e, t, n) {
  for (let o = 0; o < 28; o = o + 7) {
    const s = e >>> o, i = !(!(s >>> 7) && t == 0), u = (i ? s | 128 : s) & 255;
    if (n.push(u), !i)
      return;
  }
  const r = e >>> 28 & 15 | (t & 7) << 4, a = t >> 3 != 0;
  if (n.push((a ? r | 128 : r) & 255), !!a) {
    for (let o = 3; o < 31; o = o + 7) {
      const s = t >>> o, i = !!(s >>> 7), u = (i ? s | 128 : s) & 255;
      if (n.push(u), !i)
        return;
    }
    n.push(t >>> 31 & 1);
  }
}
const qm = 4294967296;
function AO(e) {
  const t = e[0] === "-";
  t && (e = e.slice(1));
  const n = 1e6;
  let r = 0, a = 0;
  function o(s, i) {
    const u = Number(e.slice(s, i));
    a *= n, r = r * n + u, r >= qm && (a = a + (r / qm | 0), r = r % qm);
  }
  return o(-24, -18), o(-18, -12), o(-12, -6), o(-6), t ? KR(r, a) : V0(r, a);
}
function rz(e, t) {
  let n = V0(e, t);
  const r = n.hi & 2147483648;
  r && (n = KR(n.lo, n.hi));
  const a = CR(n.lo, n.hi);
  return r ? "-" + a : a;
}
function CR(e, t) {
  if ({ lo: e, hi: t } = az(e, t), t <= 2097151)
    return String(qm * t + e);
  const n = e & 16777215, r = (e >>> 24 | t << 8) & 16777215, a = t >> 16 & 65535;
  let o = n + r * 6777216 + a * 6710656, s = r + a * 8147497, i = a * 2;
  const u = 1e7;
  return o >= u && (s += Math.floor(o / u), o %= u), s >= u && (i += Math.floor(s / u), s %= u), i.toString() + LO(s) + LO(o);
}
function az(e, t) {
  return { lo: e >>> 0, hi: t >>> 0 };
}
function V0(e, t) {
  return { lo: e | 0, hi: t | 0 };
}
function KR(e, t) {
  return t = ~t, e ? e = ~e + 1 : t += 1, V0(e, t);
}
const LO = (e) => {
  const t = String(e);
  return "0000000".slice(t.length) + t;
};
function Yy(e, t) {
  if (e >= 0) {
    for (; e > 127; )
      t.push(e & 127 | 128), e = e >>> 7;
    t.push(e);
  } else {
    for (let n = 0; n < 9; n++)
      t.push(e & 127 | 128), e = e >> 7;
    t.push(1);
  }
}
function oz() {
  let e = this.buf[this.pos++], t = e & 127;
  if ((e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 7, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 14, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 21, (e & 128) == 0)
    return this.assertBounds(), t;
  e = this.buf[this.pos++], t |= (e & 15) << 28;
  for (let n = 5; (e & 128) !== 0 && n < 10; n++)
    e = this.buf[this.pos++];
  if ((e & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
const Z = /* @__PURE__ */ sz();
function sz() {
  const e = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof e.getBigInt64 == "function" && typeof e.getBigUint64 == "function" && typeof e.setBigInt64 == "function" && typeof e.setBigUint64 == "function" && (globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const t = BigInt("-9223372036854775808"), n = BigInt("9223372036854775807"), r = BigInt("0"), a = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > n || s < t)
          throw new Error(`invalid int64: ${o}`);
        return s;
      },
      uParse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > a || s < r)
          throw new Error(`invalid uint64: ${o}`);
        return s;
      },
      enc(o) {
        return e.setBigInt64(0, this.parse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      uEnc(o) {
        return e.setBigInt64(0, this.uParse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      dec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigInt64(0, !0);
      },
      uDec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigUint64(0, !0);
      }
    };
  }
  return {
    zero: "0",
    supported: !1,
    parse(t) {
      return typeof t != "string" && (t = t.toString()), FO(t), t;
    },
    uParse(t) {
      return typeof t != "string" && (t = t.toString()), UO(t), t;
    },
    enc(t) {
      return typeof t != "string" && (t = t.toString()), FO(t), AO(t);
    },
    uEnc(t) {
      return typeof t != "string" && (t = t.toString()), UO(t), AO(t);
    },
    dec(t, n) {
      return rz(t, n);
    },
    uDec(t, n) {
      return CR(t, n);
    }
  };
}
function FO(e) {
  if (!/^-?[0-9]+$/.test(e))
    throw new Error("invalid int64: " + e);
}
function UO(e) {
  if (!/^[0-9]+$/.test(e))
    throw new Error("invalid uint64: " + e);
}
function Ys(e, t) {
  switch (e) {
    case E.STRING:
      return "";
    case E.BOOL:
      return !1;
    case E.DOUBLE:
    case E.FLOAT:
      return 0;
    case E.INT64:
    case E.UINT64:
    case E.SFIXED64:
    case E.FIXED64:
    case E.SINT64:
      return t ? "0" : Z.zero;
    case E.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function iz(e, t) {
  switch (e) {
    case E.BOOL:
      return t === !1;
    case E.STRING:
      return t === "";
    case E.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
const XR = 2, Aa = /* @__PURE__ */ Symbol.for("reflect unsafe local");
function WR(e, t) {
  const n = e[t.localName].case;
  return n === void 0 ? n : t.fields.find((r) => r.localName === n);
}
function uz(e, t) {
  const n = t.localName;
  if (t.oneof)
    return e[t.oneof.localName].case === n;
  if (t.presence != XR)
    return e[n] !== void 0 && Object.prototype.hasOwnProperty.call(e, n);
  switch (t.fieldKind) {
    case "list":
      return e[n].length > 0;
    case "map":
      return Object.keys(e[n]).length > 0;
    case "scalar":
      return !iz(t.scalar, e[n]);
    case "enum":
      return e[n] !== t.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function wl(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) && e[t] !== void 0;
}
function JR(e, t) {
  if (t.oneof) {
    const n = e[t.oneof.localName];
    return n.case === t.localName ? n.value : void 0;
  }
  return e[t.localName];
}
function ZR(e, t, n) {
  t.oneof ? e[t.oneof.localName] = {
    case: t.localName,
    value: n
  } : e[t.localName] = n;
}
function lz(e, t) {
  const n = t.localName;
  if (t.oneof) {
    const r = t.oneof.localName;
    e[r].case === n && (e[r] = { case: void 0 });
  } else if (t.presence != XR)
    delete e[n];
  else
    switch (t.fieldKind) {
      case "map":
        e[n] = {};
        break;
      case "list":
        e[n] = [];
        break;
      case "enum":
        e[n] = t.enum.values[0].number;
        break;
      case "scalar":
        e[n] = Ys(t.scalar, t.longAsString);
        break;
    }
}
function vo(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function x0(e, t) {
  var n, r, a, o;
  if (vo(e) && Aa in e && "add" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.listKind == i.listKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function Y0(e, t) {
  var n, r, a, o;
  if (vo(e) && Aa in e && "has" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.mapKey === i.mapKey && s.mapKind == i.mapKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function j0(e, t) {
  return vo(e) && Aa in e && "desc" in e && vo(e.desc) && e.desc.kind === "message" && (t === void 0 || e.desc.typeName == t.typeName);
}
function cz(e) {
  return HR(e.$typeName);
}
function Qc(e) {
  const t = e.fields[0];
  return HR(e.typeName) && t !== void 0 && t.fieldKind == "scalar" && t.name == "value" && t.number == 1;
}
function HR(e) {
  return e.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(e.substring(16));
}
const fz = 999, mz = 998, Qm = 2;
function yr(e, t) {
  if (P0(t, e))
    return t;
  const n = hz(e);
  return t !== void 0 && dz(e, n, t), n;
}
function dz(e, t, n) {
  for (const r of e.members) {
    let a = n[r.localName];
    if (a == null)
      continue;
    let o;
    if (r.kind == "oneof") {
      const s = WR(n, r);
      if (!s)
        continue;
      o = s, a = JR(n, s);
    } else
      o = r;
    switch (o.fieldKind) {
      case "message":
        a = B0(o, a);
        break;
      case "scalar":
        a = zR(o, a);
        break;
      case "list":
        a = bz(o, a);
        break;
      case "map":
        a = pz(o, a);
        break;
    }
    ZR(t, o, a);
  }
  return t;
}
function zR(e, t) {
  return e.scalar == E.BYTES ? G0(t) : t;
}
function pz(e, t) {
  if (vo(t)) {
    if (e.scalar == E.BYTES)
      return RO(t, G0);
    if (e.mapKind == "message")
      return RO(t, (n) => B0(e, n));
  }
  return t;
}
function bz(e, t) {
  if (Array.isArray(t)) {
    if (e.scalar == E.BYTES)
      return t.map(G0);
    if (e.listKind == "message")
      return t.map((n) => B0(e, n));
  }
  return t;
}
function B0(e, t) {
  if (e.fieldKind == "message" && !e.oneof && Qc(e.message))
    return zR(e.message.fields[0], t);
  if (vo(t)) {
    if (e.message.typeName == "google.protobuf.Struct" && e.parent.typeName !== "google.protobuf.Value")
      return t;
    if (!P0(t, e.message))
      return yr(e.message, t);
  }
  return t;
}
function G0(e) {
  return Array.isArray(e) ? new Uint8Array(e) : e;
}
function RO(e, t) {
  const n = {};
  for (const r of Object.entries(e))
    n[r[0]] = t(r[1]);
  return n;
}
const gz = /* @__PURE__ */ Symbol(), $O = /* @__PURE__ */ new WeakMap();
function hz(e) {
  let t;
  if (yz(e)) {
    const n = $O.get(e);
    let r, a;
    if (n)
      ({ prototype: r, members: a } = n);
    else {
      r = {}, a = /* @__PURE__ */ new Set();
      for (const o of e.members)
        o.kind != "oneof" && (o.fieldKind != "scalar" && o.fieldKind != "enum" || o.presence != Qm && (a.add(o), r[o.localName] = Hg(o)));
      $O.set(e, { prototype: r, members: a });
    }
    t = Object.create(r), t.$typeName = e.typeName;
    for (const o of e.members)
      a.has(o) || o.kind == "field" && (o.fieldKind == "message" || (o.fieldKind == "scalar" || o.fieldKind == "enum") && o.presence != Qm) || (t[o.localName] = Hg(o));
  } else {
    t = {
      $typeName: e.typeName
    };
    for (const n of e.members)
      (n.kind == "oneof" || n.presence == Qm) && (t[n.localName] = Hg(n));
  }
  return t;
}
function yz(e) {
  switch (e.file.edition) {
    case fz:
      return !1;
    case mz:
      return !0;
    default:
      return e.fields.some((t) => t.presence != Qm && t.fieldKind != "message" && !t.oneof);
  }
}
function Hg(e) {
  if (e.kind == "oneof")
    return { case: void 0 };
  if (e.fieldKind == "list")
    return [];
  if (e.fieldKind == "map")
    return {};
  if (e.fieldKind == "message")
    return gz;
  const t = e.getDefaultValue();
  return t !== void 0 ? e.fieldKind == "scalar" && e.longAsString ? t.toString() : t : e.fieldKind == "scalar" ? Ys(e.scalar, e.longAsString) : e.enum.values[0].number;
}
const Nz = [
  "FieldValueInvalidError",
  "FieldListRangeError",
  "ForeignFieldError"
];
class xt extends Error {
  constructor(t, n, r = "FieldValueInvalidError") {
    super(n), this.name = r, this.field = () => t;
  }
}
function Ez(e) {
  return e instanceof Error && Nz.includes(e.name) && "field" in e && typeof e.field == "function";
}
const zg = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
function M0() {
  if (globalThis[zg] == null) {
    const e = new globalThis.TextEncoder(), t = new globalThis.TextDecoder();
    globalThis[zg] = {
      encodeUtf8(n) {
        return e.encode(n);
      },
      decodeUtf8(n) {
        return t.decode(n);
      },
      checkUtf8(n) {
        try {
          return encodeURIComponent(n), !0;
        } catch {
          return !1;
        }
      }
    };
  }
  return globalThis[zg];
}
var ie;
(function(e) {
  e[e.Varint = 0] = "Varint", e[e.Bit64 = 1] = "Bit64", e[e.LengthDelimited = 2] = "LengthDelimited", e[e.StartGroup = 3] = "StartGroup", e[e.EndGroup = 4] = "EndGroup", e[e.Bit32 = 5] = "Bit32";
})(ie || (ie = {}));
const qR = 34028234663852886e22, QR = -34028234663852886e22, e$ = 4294967295, t$ = 2147483647, n$ = -2147483648;
class r$ {
  constructor(t = M0().encodeUtf8) {
    this.encodeUtf8 = t, this.stack = [], this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []);
    let t = 0;
    for (let a = 0; a < this.chunks.length; a++)
      t += this.chunks[a].length;
    let n = new Uint8Array(t), r = 0;
    for (let a = 0; a < this.chunks.length; a++)
      n.set(this.chunks[a], r), r += this.chunks[a].length;
    return this.chunks = [], n;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), n = this.stack.pop();
    if (!n)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = n.chunks, this.buf = n.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, n) {
    return this.uint32((t << 3 | n) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (PO(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return qg(t), Yy(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let n = this.encodeUtf8(t);
    return this.uint32(n.byteLength), this.raw(n);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    vz(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setFloat32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let n = new Uint8Array(8);
    return new DataView(n.buffer).setFloat64(0, t, !0), this.raw(n);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    PO(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    qg(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setInt32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return qg(t), t = (t << 1 ^ t >> 31) >>> 0, Yy(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = Z.enc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = Z.uEnc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let n = Z.enc(t);
    return Zg(n.lo, n.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    const n = Z.enc(t), r = n.hi >> 31, a = n.lo << 1 ^ r, o = (n.hi << 1 | n.lo >>> 31) ^ r;
    return Zg(a, o, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    const n = Z.uEnc(t);
    return Zg(n.lo, n.hi, this.buf), this;
  }
}
class C0 {
  constructor(t, n = M0().decodeUtf8) {
    this.decodeUtf8 = n, this.varint64 = nz, this.uint32 = oz, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), n = t >>> 3, r = t & 7;
    if (n <= 0 || r < 0 || r > 5)
      throw new Error("illegal tag: field no " + n + " wire type " + r);
    return [n, r];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, n) {
    let r = this.pos;
    switch (t) {
      case ie.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case ie.Bit64:
        this.pos += 4;
      case ie.Bit32:
        this.pos += 4;
        break;
      case ie.LengthDelimited:
        let a = this.uint32();
        this.pos += a;
        break;
      case ie.StartGroup:
        for (; ; ) {
          const [o, s] = this.tag();
          if (s === ie.EndGroup) {
            if (n !== void 0 && o !== n)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(s, o);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return Z.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return Z.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, n] = this.varint64(), r = -(t & 1);
    return t = (t >>> 1 | (n & 1) << 31) ^ r, n = n >>> 1 ^ r, Z.dec(t, n);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, n] = this.varint64();
    return t !== 0 || n !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return Z.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return Z.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), n = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(n, n + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function qg(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid int32: " + typeof e);
  if (!Number.isInteger(e) || e > t$ || e < n$)
    throw new Error("invalid int32: " + e);
}
function PO(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid uint32: " + typeof e);
  if (!Number.isInteger(e) || e > e$ || e < 0)
    throw new Error("invalid uint32: " + e);
}
function vz(e) {
  if (typeof e == "string") {
    const t = e;
    if (e = Number(e), Number.isNaN(e) && t !== "NaN")
      throw new Error("invalid float32: " + t);
  } else if (typeof e != "number")
    throw new Error("invalid float32: " + typeof e);
  if (Number.isFinite(e) && (e > qR || e < QR))
    throw new Error("invalid float32: " + e);
}
function Ro(e, t) {
  const n = e.fieldKind == "list" ? x0(t, e) : e.fieldKind == "map" ? Y0(t, e) : K0(e, t);
  if (n === !0)
    return;
  let r;
  switch (e.fieldKind) {
    case "list":
      r = `expected ${s$(e)}, got ${Ve(t)}`;
      break;
    case "map":
      r = `expected ${i$(e)}, got ${Ve(t)}`;
      break;
    default:
      r = Wd(e, t, n);
  }
  return new xt(e, r);
}
function VO(e, t, n) {
  const r = K0(e, n);
  if (r !== !0)
    return new xt(e, `list item #${t + 1}: ${Wd(e, n, r)}`);
}
function Tz(e, t, n) {
  const r = a$(t, e.mapKey);
  if (r !== !0)
    return new xt(e, `invalid map key: ${Wd({ scalar: e.mapKey }, t, r)}`);
  const a = K0(e, n);
  if (a !== !0)
    return new xt(e, `map entry ${Ve(t)}: ${Wd(e, n, a)}`);
}
function K0(e, t) {
  return e.scalar !== void 0 ? a$(t, e.scalar) : e.enum !== void 0 ? e.enum.open ? Number.isInteger(t) : e.enum.values.some((n) => n.number === t) : j0(t, e.message);
}
function a$(e, t) {
  switch (t) {
    case E.DOUBLE:
      return typeof e == "number";
    case E.FLOAT:
      return typeof e != "number" ? !1 : Number.isNaN(e) || !Number.isFinite(e) ? !0 : e > qR || e < QR ? `${e.toFixed()} out of range` : !0;
    case E.INT32:
    case E.SFIXED32:
    case E.SINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > t$ || e < n$ ? `${e.toFixed()} out of range` : !0;
    case E.FIXED32:
    case E.UINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > e$ || e < 0 ? `${e.toFixed()} out of range` : !0;
    case E.BOOL:
      return typeof e == "boolean";
    case E.STRING:
      return typeof e != "string" ? !1 : M0().checkUtf8(e) || "invalid UTF8";
    case E.BYTES:
      return e instanceof Uint8Array;
    case E.INT64:
    case E.SFIXED64:
    case E.SINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return Z.parse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
    case E.FIXED64:
    case E.UINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return Z.uParse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
  }
}
function Wd(e, t, n) {
  return n = typeof n == "string" ? `: ${n}` : `, got ${Ve(t)}`, e.scalar !== void 0 ? `expected ${Iz(e.scalar)}` + n : e.enum !== void 0 ? `expected ${e.enum.toString()}` + n : `expected ${o$(e.message)}` + n;
}
function Ve(e) {
  switch (typeof e) {
    case "object":
      return e === null ? "null" : e instanceof Uint8Array ? `Uint8Array(${e.length})` : Array.isArray(e) ? `Array(${e.length})` : x0(e) ? s$(e.field()) : Y0(e) ? i$(e.field()) : j0(e) ? o$(e.desc) : P0(e) ? `message ${e.$typeName}` : "object";
    case "string":
      return e.length > 30 ? "string" : `"${e.split('"').join('\\"')}"`;
    case "boolean":
      return String(e);
    case "number":
      return String(e);
    case "bigint":
      return String(e) + "n";
    default:
      return typeof e;
  }
}
function o$(e) {
  return `ReflectMessage (${e.typeName})`;
}
function s$(e) {
  switch (e.listKind) {
    case "message":
      return `ReflectList (${e.message.toString()})`;
    case "enum":
      return `ReflectList (${e.enum.toString()})`;
    case "scalar":
      return `ReflectList (${E[e.scalar]})`;
  }
}
function i$(e) {
  switch (e.mapKind) {
    case "message":
      return `ReflectMap (${E[e.mapKey]}, ${e.message.toString()})`;
    case "enum":
      return `ReflectMap (${E[e.mapKey]}, ${e.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${E[e.mapKey]}, ${E[e.scalar]})`;
  }
}
function Iz(e) {
  switch (e) {
    case E.STRING:
      return "string";
    case E.BOOL:
      return "boolean";
    case E.INT64:
    case E.SINT64:
    case E.SFIXED64:
      return "bigint (int64)";
    case E.UINT64:
    case E.FIXED64:
      return "bigint (uint64)";
    case E.BYTES:
      return "Uint8Array";
    case E.DOUBLE:
      return "number (float64)";
    case E.FLOAT:
      return "number (float32)";
    case E.FIXED32:
    case E.UINT32:
      return "number (uint32)";
    case E.INT32:
    case E.SFIXED32:
    case E.SINT32:
      return "number (int32)";
  }
}
function Zn(e, t, n = !0) {
  return new u$(e, t, n);
}
const xO = /* @__PURE__ */ new WeakMap();
class u$ {
  get sortedFields() {
    const t = xO.get(this.desc);
    if (t)
      return t;
    const n = this.desc.fields.concat().sort((r, a) => r.number - a.number);
    return xO.set(this.desc, n), n;
  }
  constructor(t, n, r = !0) {
    this.lists = /* @__PURE__ */ new Map(), this.maps = /* @__PURE__ */ new Map(), this.check = r, this.desc = t, this.message = this[Aa] = n ?? yr(t), this.fields = t.fields, this.oneofs = t.oneofs, this.members = t.members;
  }
  findNumber(t) {
    return this._fieldsByNumber || (this._fieldsByNumber = new Map(this.desc.fields.map((n) => [n.number, n]))), this._fieldsByNumber.get(t);
  }
  oneofCase(t) {
    return Uu(this.message, t), WR(this.message, t);
  }
  isSet(t) {
    return Uu(this.message, t), uz(this.message, t);
  }
  clear(t) {
    Uu(this.message, t), lz(this.message, t);
  }
  get(t) {
    Uu(this.message, t);
    const n = JR(this.message, t);
    switch (t.fieldKind) {
      case "list":
        let r = this.lists.get(t);
        return (!r || r[Aa] !== n) && this.lists.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          r = new wz(t, n, this.check)
        ), r;
      case "map":
        let a = this.maps.get(t);
        return (!a || a[Aa] !== n) && this.maps.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = new _z(t, n, this.check)
        ), a;
      case "message":
        return W0(t, n, this.check);
      case "scalar":
        return n === void 0 ? Ys(t.scalar, !1) : J0(t, n);
      case "enum":
        return n ?? t.enum.values[0].number;
    }
  }
  set(t, n) {
    if (Uu(this.message, t), this.check) {
      const a = Ro(t, n);
      if (a)
        throw a;
    }
    let r;
    t.fieldKind == "message" ? r = X0(t, n) : Y0(n) || x0(n) ? r = n[Aa] : r = Z0(t, n), ZR(this.message, t, r);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(t) {
    this.message.$unknown = t;
  }
}
function Uu(e, t) {
  if (t.parent.typeName !== e.$typeName)
    throw new xt(t, `cannot use ${t.toString()} with message ${e.$typeName}`, "ForeignFieldError");
}
class wz {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(t, n, r) {
    this._field = t, this._arr = this[Aa] = n, this.check = r;
  }
  get(t) {
    const n = this._arr[t];
    return n === void 0 ? void 0 : Qg(this._field, n, this.check);
  }
  set(t, n) {
    if (t < 0 || t >= this._arr.length)
      throw new xt(this._field, `list item #${t + 1}: out of range`);
    if (this.check) {
      const r = VO(this._field, t, n);
      if (r)
        throw r;
    }
    this._arr[t] = YO(this._field, n);
  }
  add(t) {
    if (this.check) {
      const n = VO(this._field, this._arr.length, t);
      if (n)
        throw n;
    }
    this._arr.push(YO(this._field, t));
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const t of this._arr)
      yield Qg(this._field, t, this.check);
  }
  *entries() {
    for (let t = 0; t < this._arr.length; t++)
      yield [t, Qg(this._field, this._arr[t], this.check)];
  }
}
class _z {
  constructor(t, n, r = !0) {
    this.obj = this[Aa] = n ?? {}, this.check = r, this._field = t;
  }
  field() {
    return this._field;
  }
  set(t, n) {
    if (this.check) {
      const r = Tz(this._field, t, n);
      if (r)
        throw r;
    }
    return this.obj[lm(t)] = Oz(this._field, n), this;
  }
  delete(t) {
    const n = lm(t), r = Object.prototype.hasOwnProperty.call(this.obj, n);
    return r && delete this.obj[n], r;
  }
  clear() {
    for (const t of Object.keys(this.obj))
      delete this.obj[t];
  }
  get(t) {
    let n = this.obj[lm(t)];
    return n !== void 0 && (n = eh(this._field, n, this.check)), n;
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.obj, lm(t));
  }
  *keys() {
    for (const t of Object.keys(this.obj))
      yield jO(t, this._field.mapKey);
  }
  *entries() {
    for (const t of Object.entries(this.obj))
      yield [
        jO(t[0], this._field.mapKey),
        eh(this._field, t[1], this.check)
      ];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const t of Object.values(this.obj))
      yield eh(this._field, t, this.check);
  }
  forEach(t, n) {
    for (const r of this.entries())
      t.call(n, r[1], r[0], this);
  }
}
function X0(e, t) {
  return j0(t) ? cz(t.message) && !e.oneof && e.fieldKind == "message" ? t.message.value : t.desc.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" ? c$(t.message) : t.message : t;
}
function W0(e, t, n) {
  return t !== void 0 && (Qc(e.message) && !e.oneof && e.fieldKind == "message" ? t = {
    $typeName: e.message.typeName,
    value: J0(e.message.fields[0], t)
  } : e.message.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" && vo(t) && (t = l$(t))), new u$(e.message, t, n);
}
function YO(e, t) {
  return e.listKind == "message" ? X0(e, t) : Z0(e, t);
}
function Qg(e, t, n) {
  return e.listKind == "message" ? W0(e, t, n) : J0(e, t);
}
function Oz(e, t) {
  return e.mapKind == "message" ? X0(e, t) : Z0(e, t);
}
function eh(e, t, n) {
  return e.mapKind == "message" ? W0(e, t, n) : t;
}
function lm(e) {
  return typeof e == "string" || typeof e == "number" ? e : String(e);
}
function jO(e, t) {
  switch (t) {
    case E.STRING:
      return e;
    case E.INT32:
    case E.FIXED32:
    case E.UINT32:
    case E.SFIXED32:
    case E.SINT32: {
      const n = Number.parseInt(e);
      if (Number.isFinite(n))
        return n;
      break;
    }
    case E.BOOL:
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      break;
    case E.UINT64:
    case E.FIXED64:
      try {
        return Z.uParse(e);
      } catch {
      }
      break;
    default:
      try {
        return Z.parse(e);
      } catch {
      }
      break;
  }
  return e;
}
function J0(e, t) {
  switch (e.scalar) {
    case E.INT64:
    case E.SFIXED64:
    case E.SINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = Z.parse(t));
      break;
    case E.FIXED64:
    case E.UINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = Z.uParse(t));
      break;
  }
  return t;
}
function Z0(e, t) {
  switch (e.scalar) {
    case E.INT64:
    case E.SFIXED64:
    case E.SINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = Z.parse(t));
      break;
    case E.FIXED64:
    case E.UINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = Z.uParse(t));
      break;
  }
  return t;
}
function l$(e) {
  const t = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (vo(e))
    for (const [n, r] of Object.entries(e))
      t.fields[n] = m$(r);
  return t;
}
function c$(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = f$(r);
  return t;
}
function f$(e) {
  switch (e.kind.case) {
    case "structValue":
      return c$(e.kind.value);
    case "listValue":
      return e.kind.value.values.map(f$);
    case "nullValue":
    case void 0:
      return null;
    default:
      return e.kind.value;
  }
}
function m$(e) {
  const t = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof e) {
    case "number":
      t.kind = { case: "numberValue", value: e };
      break;
    case "string":
      t.kind = { case: "stringValue", value: e };
      break;
    case "boolean":
      t.kind = { case: "boolValue", value: e };
      break;
    case "object":
      if (e === null)
        t.kind = { case: "nullValue", value: 0 };
      else if (Array.isArray(e)) {
        const n = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(e))
          for (const r of e)
            n.values.push(m$(r));
        t.kind = {
          case: "listValue",
          value: n
        };
      } else
        t.kind = {
          case: "structValue",
          value: l$(e)
        };
      break;
  }
  return t;
}
function H0(e) {
  const t = Sz();
  let n = e.length * 3 / 4;
  e[e.length - 2] == "=" ? n -= 2 : e[e.length - 1] == "=" && (n -= 1);
  let r = new Uint8Array(n), a = 0, o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++) {
    if (s = t[e.charCodeAt(u)], s === void 0)
      switch (e[u]) {
        // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
        case "=":
          o = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string");
      }
    switch (o) {
      case 0:
        i = s, o = 1;
        break;
      case 1:
        r[a++] = i << 2 | (s & 48) >> 4, i = s, o = 2;
        break;
      case 2:
        r[a++] = (i & 15) << 4 | (s & 60) >> 2, i = s, o = 3;
        break;
      case 3:
        r[a++] = (i & 3) << 6 | s, o = 0;
        break;
    }
  }
  if (o == 1)
    throw Error("invalid base64 string");
  return r.subarray(0, a);
}
function d$(e, t = "std") {
  const n = p$(t), r = t == "std";
  let a = "", o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++)
    switch (s = e[u], o) {
      case 0:
        a += n[s >> 2], i = (s & 3) << 4, o = 1;
        break;
      case 1:
        a += n[i | s >> 4], i = (s & 15) << 2, o = 2;
        break;
      case 2:
        a += n[i | s >> 6], a += n[s & 63], o = 0;
        break;
    }
  return o && (a += n[i], r && (a += "=", o == 1 && (a += "="))), a;
}
let cm, BO, ri;
function p$(e) {
  return cm || (cm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), BO = cm.slice(0, -2).concat("-", "_")), e == "url" ? (
    // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
    BO
  ) : cm;
}
function Sz() {
  if (!ri) {
    ri = [];
    const e = p$("std");
    for (let t = 0; t < e.length; t++)
      ri[e[t].charCodeAt(0)] = t;
    ri[45] = e.indexOf("+"), ri[95] = e.indexOf("/");
  }
  return ri;
}
function _l(e) {
  let t = !1;
  const n = [];
  for (let r = 0; r < e.length; r++) {
    let a = e.charAt(r);
    switch (a) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        n.push(a), t = !1;
        break;
      default:
        t && (t = !1, a = a.toUpperCase()), n.push(a);
        break;
    }
  }
  return n.join("");
}
const Dz = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function Ol(e) {
  return Dz.has(e) ? e + "$" : e;
}
function z0(e) {
  for (const t of e.field)
    wl(t, "jsonName") || (t.jsonName = _l(t.name));
  e.nestedType.forEach(z0);
}
function kz(e, t) {
  const n = e.values.find((r) => r.name === t);
  if (!n)
    throw new Error(`cannot parse ${e} default value: ${t}`);
  return n.number;
}
function Az(e, t) {
  switch (e) {
    case E.STRING:
      return t;
    case E.BYTES: {
      const n = Lz(t);
      if (n === !1)
        throw new Error(`cannot parse ${E[e]} default value: ${t}`);
      return n;
    }
    case E.INT64:
    case E.SFIXED64:
    case E.SINT64:
      return Z.parse(t);
    case E.UINT64:
    case E.FIXED64:
      return Z.uParse(t);
    case E.DOUBLE:
    case E.FLOAT:
      switch (t) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(t);
      }
    case E.BOOL:
      return t === "true";
    case E.INT32:
    case E.UINT32:
    case E.SINT32:
    case E.FIXED32:
    case E.SFIXED32:
      return parseInt(t, 10);
  }
}
function Lz(e) {
  const t = [], n = {
    tail: e,
    c: "",
    next() {
      return this.tail.length == 0 ? !1 : (this.c = this.tail[0], this.tail = this.tail.substring(1), !0);
    },
    take(r) {
      if (this.tail.length >= r) {
        const a = this.tail.substring(0, r);
        return this.tail = this.tail.substring(r), a;
      }
      return !1;
    }
  };
  for (; n.next(); )
    switch (n.c) {
      case "\\":
        if (n.next())
          switch (n.c) {
            case "\\":
              t.push(n.c.charCodeAt(0));
              break;
            case "b":
              t.push(8);
              break;
            case "f":
              t.push(12);
              break;
            case "n":
              t.push(10);
              break;
            case "r":
              t.push(13);
              break;
            case "t":
              t.push(9);
              break;
            case "v":
              t.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 8);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "x": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "u": {
              const r = n.c, a = n.take(4);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              const s = new Uint8Array(4);
              new DataView(s.buffer).setInt32(0, o, !0), t.push(s[0], s[1], s[2], s[3]);
              break;
            }
            case "U": {
              const r = n.c, a = n.take(8);
              if (a === !1)
                return !1;
              const o = Z.uEnc(r + a), s = new Uint8Array(8), i = new DataView(s.buffer);
              i.setInt32(0, o.lo, !0), i.setInt32(4, o.hi, !0), t.push(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
              break;
            }
          }
        break;
      default:
        t.push(n.c.charCodeAt(0));
    }
  return new Uint8Array(t);
}
function* jy(e) {
  switch (e.kind) {
    case "file":
      for (const t of e.messages)
        yield t, yield* jy(t);
      yield* e.enums, yield* e.services, yield* e.extensions;
      break;
    case "message":
      for (const t of e.nestedMessages)
        yield t, yield* jy(t);
      yield* e.nestedEnums, yield* e.nestedExtensions;
      break;
  }
}
function b$(...e) {
  const t = Fz();
  if (!e.length)
    return t;
  if ("$typeName" in e[0] && e[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const n of e[0].file)
      XO(n, t);
    return t;
  }
  if ("$typeName" in e[0]) {
    let n = function(s) {
      const i = [];
      for (const u of s.dependency) {
        if (t.getFile(u) != null || o.has(u))
          continue;
        const l = a(u);
        if (!l)
          throw new Error(`Unable to resolve ${u}, imported by ${s.name}`);
        "kind" in l ? t.addFile(l, !1, !0) : (o.add(l.name), i.push(l));
      }
      return i.concat(...i.map(n));
    };
    const r = e[0], a = e[1], o = /* @__PURE__ */ new Set();
    for (const s of [r, ...n(r)].reverse())
      XO(s, t);
  } else
    for (const n of e)
      for (const r of n.files)
        t.addFile(r);
  return t;
}
function Fz() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    kind: "registry",
    types: e,
    extendees: t,
    [Symbol.iterator]() {
      return e.values();
    },
    get files() {
      return n.values();
    },
    addFile(r, a, o) {
      if (n.set(r.proto.name, r), !a)
        for (const s of jy(r))
          this.add(s);
      if (o)
        for (const s of r.dependencies)
          this.addFile(s, a, o);
    },
    add(r) {
      if (r.kind == "extension") {
        let a = t.get(r.extendee.typeName);
        a || t.set(
          r.extendee.typeName,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = /* @__PURE__ */ new Map()
        ), a.set(r.number, r);
      }
      e.set(r.typeName, r);
    },
    get(r) {
      return e.get(r);
    },
    getFile(r) {
      return n.get(r);
    },
    getMessage(r) {
      const a = e.get(r);
      return a?.kind == "message" ? a : void 0;
    },
    getEnum(r) {
      const a = e.get(r);
      return a?.kind == "enum" ? a : void 0;
    },
    getExtension(r) {
      const a = e.get(r);
      return a?.kind == "extension" ? a : void 0;
    },
    getExtensionFor(r, a) {
      var o;
      return (o = t.get(r.typeName)) === null || o === void 0 ? void 0 : o.get(a);
    },
    getService(r) {
      const a = e.get(r);
      return a?.kind == "service" ? a : void 0;
    }
  };
}
const Uz = 998, Rz = 999, $z = 9, Sl = 10, Cu = 11, Pz = 12, GO = 14, q0 = 3, Vz = 2, MO = 1, xz = 0, CO = 1, KO = 2, Yz = 3, jz = 1, Bz = 2, Gz = 1, g$ = {
  // EDITION_PROTO2
  998: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 2,
    // CLOSED,
    repeatedFieldEncoding: 2,
    // EXPANDED,
    utf8Validation: 3,
    // NONE,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 2,
    // LEGACY_BEST_EFFORT,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_PROTO3
  999: {
    fieldPresence: 2,
    // IMPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2023
  1e3: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2024
  1001: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 1,
    // STYLE2024,
    defaultSymbolVisibility: 2
    // EXPORT_TOP_LEVEL,
  }
};
function XO(e, t) {
  var n, r;
  const a = {
    kind: "file",
    proto: e,
    deprecated: (r = (n = e.options) === null || n === void 0 ? void 0 : n.deprecated) !== null && r !== void 0 ? r : !1,
    edition: Xz(e),
    name: e.name.replace(/\.proto$/, ""),
    dependencies: Wz(e, t),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${e.name}`;
    }
  }, o = /* @__PURE__ */ new Map(), s = {
    get(i) {
      return o.get(i);
    },
    add(i) {
      var u;
      or(((u = i.proto.options) === null || u === void 0 ? void 0 : u.mapEntry) === !0), o.set(i.typeName, i);
    }
  };
  for (const i of e.enumType)
    h$(i, a, void 0, t);
  for (const i of e.messageType)
    y$(i, a, void 0, t, s);
  for (const i of e.service)
    Mz(i, a, t);
  By(a, t);
  for (const i of o.values())
    Gy(i, t, s);
  for (const i of a.messages)
    Gy(i, t, s), By(i, t);
  t.addFile(a, !0);
}
function By(e, t) {
  switch (e.kind) {
    case "file":
      for (const n of e.proto.extension) {
        const r = My(n, e, t);
        e.extensions.push(r), t.add(r);
      }
      break;
    case "message":
      for (const n of e.proto.extension) {
        const r = My(n, e, t);
        e.nestedExtensions.push(r), t.add(r);
      }
      for (const n of e.nestedMessages)
        By(n, t);
      break;
  }
}
function Gy(e, t, n) {
  const r = e.proto.oneofDecl.map((o) => Kz(o, e)), a = /* @__PURE__ */ new Set();
  for (const o of e.proto.field) {
    const s = Hz(o, r), i = My(o, e, t, s, n);
    e.fields.push(i), e.field[i.localName] = i, s === void 0 ? e.members.push(i) : (s.fields.push(i), a.has(s) || (a.add(s), e.members.push(s)));
  }
  for (const o of r.filter((s) => a.has(s)))
    e.oneofs.push(o);
  for (const o of e.nestedMessages)
    Gy(o, t, n);
}
function h$(e, t, n, r) {
  var a, o, s, i, u;
  const l = Jz(e.name, e.value), c = {
    kind: "enum",
    proto: e,
    deprecated: (o = (a = e.options) === null || a === void 0 ? void 0 : a.deprecated) !== null && o !== void 0 ? o : !1,
    file: t,
    parent: n,
    open: !0,
    name: e.name,
    typeName: _b(e, n, t),
    value: {},
    values: [],
    sharedPrefix: l,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  c.open = eq(c), r.add(c);
  for (const f of e.value) {
    const d = f.name;
    c.values.push(
      // biome-ignore lint/suspicious/noAssignInExpressions: no
      c.value[f.number] = {
        kind: "enum_value",
        proto: f,
        deprecated: (i = (s = f.options) === null || s === void 0 ? void 0 : s.deprecated) !== null && i !== void 0 ? i : !1,
        parent: c,
        name: d,
        localName: Ol(l == null ? d : d.substring(l.length)),
        number: f.number,
        toString() {
          return `enum value ${c.typeName}.${d}`;
        }
      }
    );
  }
  ((u = n?.nestedEnums) !== null && u !== void 0 ? u : t.enums).push(c);
}
function y$(e, t, n, r, a) {
  var o, s, i, u;
  const l = {
    kind: "message",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    file: t,
    parent: n,
    name: e.name,
    typeName: _b(e, n, t),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  ((i = e.options) === null || i === void 0 ? void 0 : i.mapEntry) === !0 ? a.add(l) : (((u = n?.nestedMessages) !== null && u !== void 0 ? u : t.messages).push(l), r.add(l));
  for (const c of e.enumType)
    h$(c, t, l, r);
  for (const c of e.nestedType)
    y$(c, t, l, r, a);
}
function Mz(e, t, n) {
  var r, a;
  const o = {
    kind: "service",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    file: t,
    name: e.name,
    typeName: _b(e, void 0, t),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  t.services.push(o), n.add(o);
  for (const s of e.method) {
    const i = Cz(s, o, n);
    o.methods.push(i), o.method[i.localName] = i;
  }
}
function Cz(e, t, n) {
  var r, a, o, s;
  let i;
  e.clientStreaming && e.serverStreaming ? i = "bidi_streaming" : e.clientStreaming ? i = "client_streaming" : e.serverStreaming ? i = "server_streaming" : i = "unary";
  const u = n.getMessage(da(e.inputType)), l = n.getMessage(da(e.outputType));
  or(u, `invalid MethodDescriptorProto: input_type ${e.inputType} not found`), or(l, `invalid MethodDescriptorProto: output_type ${e.inputType} not found`);
  const c = e.name;
  return {
    kind: "rpc",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    parent: t,
    name: c,
    localName: Ol(c.length ? Ol(c[0].toLowerCase() + c.substring(1)) : c),
    methodKind: i,
    input: u,
    output: l,
    idempotency: (s = (o = e.options) === null || o === void 0 ? void 0 : o.idempotencyLevel) !== null && s !== void 0 ? s : xz,
    toString() {
      return `rpc ${t.typeName}.${c}`;
    }
  };
}
function Kz(e, t) {
  return {
    kind: "oneof",
    proto: e,
    deprecated: !1,
    parent: t,
    fields: [],
    name: e.name,
    localName: Ol(_l(e.name)),
    toString() {
      return `oneof ${t.typeName}.${this.name}`;
    }
  };
}
function My(e, t, n, r, a) {
  var o, s, i;
  const u = a === void 0, l = {
    kind: "field",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    name: e.name,
    number: e.number,
    scalar: void 0,
    message: void 0,
    enum: void 0,
    presence: zz(e, r, u, t),
    listKind: void 0,
    mapKind: void 0,
    mapKey: void 0,
    delimitedEncoding: void 0,
    packed: void 0,
    longAsString: !1,
    getDefaultValue: void 0
  };
  if (u) {
    const m = t.kind == "file" ? t : t.file, p = t.kind == "file" ? void 0 : t, b = _b(e, p, m);
    l.kind = "extension", l.file = m, l.parent = p, l.oneof = void 0, l.typeName = b, l.jsonName = `[${b}]`, l.toString = () => `extension ${b}`;
    const g = n.getMessage(da(e.extendee));
    or(g, `invalid FieldDescriptorProto: extendee ${e.extendee} not found`), l.extendee = g;
  } else {
    const m = t;
    or(m.kind == "message"), l.parent = m, l.oneof = r, l.localName = r ? _l(e.name) : Ol(_l(e.name)), l.jsonName = e.jsonName, l.toString = () => `field ${m.typeName}.${e.name}`;
  }
  const c = e.label, f = e.type, d = (i = e.options) === null || i === void 0 ? void 0 : i.jstype;
  if (c === q0) {
    const m = f == Cu ? a?.get(da(e.typeName)) : void 0;
    if (m) {
      l.fieldKind = "map";
      const { key: p, value: b } = Qz(m);
      return l.mapKey = p.scalar, l.mapKind = b.fieldKind, l.message = b.message, l.delimitedEncoding = !1, l.enum = b.enum, l.scalar = b.scalar, l;
    }
    switch (l.fieldKind = "list", f) {
      case Cu:
      case Sl:
        l.listKind = "message", l.message = n.getMessage(da(e.typeName)), or(l.message), l.delimitedEncoding = WO(e, t);
        break;
      case GO:
        l.listKind = "enum", l.enum = n.getEnum(da(e.typeName)), or(l.enum);
        break;
      default:
        l.listKind = "scalar", l.scalar = f, l.longAsString = d == MO;
        break;
    }
    return l.packed = qz(e, t), l;
  }
  switch (f) {
    case Cu:
    case Sl:
      l.fieldKind = "message", l.message = n.getMessage(da(e.typeName)), or(l.message, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.delimitedEncoding = WO(e, t), l.getDefaultValue = () => {
      };
      break;
    case GO: {
      const m = n.getEnum(da(e.typeName));
      or(m !== void 0, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.fieldKind = "enum", l.enum = n.getEnum(da(e.typeName)), l.getDefaultValue = () => wl(e, "defaultValue") ? kz(m, e.defaultValue) : void 0;
      break;
    }
    default: {
      l.fieldKind = "scalar", l.scalar = f, l.longAsString = d == MO, l.getDefaultValue = () => wl(e, "defaultValue") ? Az(f, e.defaultValue) : void 0;
      break;
    }
  }
  return l;
}
function Xz(e) {
  switch (e.syntax) {
    case "":
    case "proto2":
      return Uz;
    case "proto3":
      return Rz;
    case "editions":
      if (e.edition in g$)
        return e.edition;
      throw new Error(`${e.name}: unsupported edition`);
    default:
      throw new Error(`${e.name}: unsupported syntax "${e.syntax}"`);
  }
}
function Wz(e, t) {
  return e.dependency.map((n) => {
    const r = t.getFile(n);
    if (!r)
      throw new Error(`Cannot find ${n}, imported by ${e.name}`);
    return r;
  });
}
function Jz(e, t) {
  const n = Zz(e) + "_";
  for (const r of t) {
    if (!r.name.toLowerCase().startsWith(n))
      return;
    const a = r.name.substring(n.length);
    if (a.length == 0 || /^\d/.test(a))
      return;
  }
  return n;
}
function Zz(e) {
  return (e.substring(0, 1) + e.substring(1).replace(/[A-Z]/g, (t) => "_" + t)).toLowerCase();
}
function _b(e, t, n) {
  let r;
  return t ? r = `${t.typeName}.${e.name}` : n.proto.package.length > 0 ? r = `${n.proto.package}.${e.name}` : r = `${e.name}`, r;
}
function da(e) {
  return e.startsWith(".") ? e.substring(1) : e;
}
function Hz(e, t) {
  if (!wl(e, "oneofIndex") || e.proto3Optional)
    return;
  const n = t[e.oneofIndex];
  return or(n, `invalid FieldDescriptorProto: oneof #${e.oneofIndex} for field #${e.number} not found`), n;
}
function zz(e, t, n, r) {
  if (e.label == Vz)
    return Yz;
  if (e.label == q0)
    return KO;
  if (t || e.proto3Optional || n)
    return CO;
  const a = Xi("fieldPresence", { proto: e, parent: r });
  return a == KO && (e.type == Cu || e.type == Sl) ? CO : a;
}
function qz(e, t) {
  if (e.label != q0)
    return !1;
  switch (e.type) {
    case $z:
    case Pz:
    case Sl:
    case Cu:
      return !1;
  }
  const n = e.options;
  return n && wl(n, "packed") ? n.packed : jz == Xi("repeatedFieldEncoding", {
    proto: e,
    parent: t
  });
}
function Qz(e) {
  const t = e.fields.find((r) => r.number === 1), n = e.fields.find((r) => r.number === 2);
  return or(t && t.fieldKind == "scalar" && t.scalar != E.BYTES && t.scalar != E.FLOAT && t.scalar != E.DOUBLE && n && n.fieldKind != "list" && n.fieldKind != "map"), { key: t, value: n };
}
function eq(e) {
  var t;
  return Gz == Xi("enumType", {
    proto: e.proto,
    parent: (t = e.parent) !== null && t !== void 0 ? t : e.file
  });
}
function WO(e, t) {
  return e.type == Sl ? !0 : Bz == Xi("messageEncoding", {
    proto: e,
    parent: t
  });
}
function Xi(e, t) {
  var n, r;
  const a = (n = t.proto.options) === null || n === void 0 ? void 0 : n.features;
  if (a) {
    const o = a[e];
    if (o != 0)
      return o;
  }
  if ("kind" in t) {
    if (t.kind == "message")
      return Xi(e, (r = t.parent) !== null && r !== void 0 ? r : t.file);
    const o = g$[t.edition];
    if (!o)
      throw new Error(`feature default for edition ${t.edition} not found`);
    return o[e];
  }
  return Xi(e, t.parent);
}
function or(e, t) {
  if (!e)
    throw new Error(t);
}
function tq(e) {
  const t = nq(e);
  return t.messageType.forEach(z0), b$(t, () => {
  }).getFile(t.name);
}
function nq(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    syntax: "",
    edition: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, e), { messageType: e.messageType.map(N$), enumType: e.enumType.map(E$) }));
}
function N$(e) {
  var t, n, r, a, o, s, i, u;
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.DescriptorProto",
    name: e.name,
    field: (n = (t = e.field) === null || t === void 0 ? void 0 : t.map(rq)) !== null && n !== void 0 ? n : [],
    extension: [],
    nestedType: (a = (r = e.nestedType) === null || r === void 0 ? void 0 : r.map(N$)) !== null && a !== void 0 ? a : [],
    enumType: (s = (o = e.enumType) === null || o === void 0 ? void 0 : o.map(E$)) !== null && s !== void 0 ? s : [],
    extensionRange: (u = (i = e.extensionRange) === null || i === void 0 ? void 0 : i.map((l) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, l))) !== null && u !== void 0 ? u : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function rq(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: !1
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, e), { options: e.options ? aq(e.options) : void 0 }));
}
function aq(e) {
  var t, n, r;
  return Object.assign(/* @__PURE__ */ Object.create({
    ctype: 0,
    packed: !1,
    jstype: 0,
    lazy: !1,
    unverifiedLazy: !1,
    deprecated: !1,
    weak: !1,
    debugRedact: !1,
    retention: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, e), { targets: (t = e.targets) !== null && t !== void 0 ? t : [], editionDefaults: (r = (n = e.editionDefaults) === null || n === void 0 ? void 0 : n.map((a) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, a))) !== null && r !== void 0 ? r : [], uninterpretedOption: [] }));
}
function E$(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: e.name,
    reservedName: [],
    reservedRange: [],
    value: e.value.map((t) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, t))
  });
}
function ef(e, t, ...n) {
  return n.reduce((r, a) => r.nestedMessages[a], e.messages[t]);
}
const oq = /* @__PURE__ */ tq({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: !0 } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false", options: { deprecated: !0 } }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1e3 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1e3, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: !0 } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1e3 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_UNSTABLE", number: 9999 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] }), sq = /* @__PURE__ */ ef(oq, 1);
var JO;
(function(e) {
  e[e.DECLARATION = 0] = "DECLARATION", e[e.UNVERIFIED = 1] = "UNVERIFIED";
})(JO || (JO = {}));
var ZO;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.GROUP = 10] = "GROUP", e[e.MESSAGE = 11] = "MESSAGE", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.ENUM = 14] = "ENUM", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(ZO || (ZO = {}));
var HO;
(function(e) {
  e[e.OPTIONAL = 1] = "OPTIONAL", e[e.REPEATED = 3] = "REPEATED", e[e.REQUIRED = 2] = "REQUIRED";
})(HO || (HO = {}));
var zO;
(function(e) {
  e[e.SPEED = 1] = "SPEED", e[e.CODE_SIZE = 2] = "CODE_SIZE", e[e.LITE_RUNTIME = 3] = "LITE_RUNTIME";
})(zO || (zO = {}));
var qO;
(function(e) {
  e[e.STRING = 0] = "STRING", e[e.CORD = 1] = "CORD", e[e.STRING_PIECE = 2] = "STRING_PIECE";
})(qO || (qO = {}));
var QO;
(function(e) {
  e[e.JS_NORMAL = 0] = "JS_NORMAL", e[e.JS_STRING = 1] = "JS_STRING", e[e.JS_NUMBER = 2] = "JS_NUMBER";
})(QO || (QO = {}));
var eS;
(function(e) {
  e[e.RETENTION_UNKNOWN = 0] = "RETENTION_UNKNOWN", e[e.RETENTION_RUNTIME = 1] = "RETENTION_RUNTIME", e[e.RETENTION_SOURCE = 2] = "RETENTION_SOURCE";
})(eS || (eS = {}));
var tS;
(function(e) {
  e[e.TARGET_TYPE_UNKNOWN = 0] = "TARGET_TYPE_UNKNOWN", e[e.TARGET_TYPE_FILE = 1] = "TARGET_TYPE_FILE", e[e.TARGET_TYPE_EXTENSION_RANGE = 2] = "TARGET_TYPE_EXTENSION_RANGE", e[e.TARGET_TYPE_MESSAGE = 3] = "TARGET_TYPE_MESSAGE", e[e.TARGET_TYPE_FIELD = 4] = "TARGET_TYPE_FIELD", e[e.TARGET_TYPE_ONEOF = 5] = "TARGET_TYPE_ONEOF", e[e.TARGET_TYPE_ENUM = 6] = "TARGET_TYPE_ENUM", e[e.TARGET_TYPE_ENUM_ENTRY = 7] = "TARGET_TYPE_ENUM_ENTRY", e[e.TARGET_TYPE_SERVICE = 8] = "TARGET_TYPE_SERVICE", e[e.TARGET_TYPE_METHOD = 9] = "TARGET_TYPE_METHOD";
})(tS || (tS = {}));
var Cy;
(function(e) {
  e[e.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e[e.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e[e.IDEMPOTENT = 2] = "IDEMPOTENT";
})(Cy || (Cy = {}));
var nS;
(function(e) {
  e[e.DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", e[e.EXPORT_ALL = 1] = "EXPORT_ALL", e[e.EXPORT_TOP_LEVEL = 2] = "EXPORT_TOP_LEVEL", e[e.LOCAL_ALL = 3] = "LOCAL_ALL", e[e.STRICT = 4] = "STRICT";
})(nS || (nS = {}));
var rS;
(function(e) {
  e[e.FIELD_PRESENCE_UNKNOWN = 0] = "FIELD_PRESENCE_UNKNOWN", e[e.EXPLICIT = 1] = "EXPLICIT", e[e.IMPLICIT = 2] = "IMPLICIT", e[e.LEGACY_REQUIRED = 3] = "LEGACY_REQUIRED";
})(rS || (rS = {}));
var aS;
(function(e) {
  e[e.ENUM_TYPE_UNKNOWN = 0] = "ENUM_TYPE_UNKNOWN", e[e.OPEN = 1] = "OPEN", e[e.CLOSED = 2] = "CLOSED";
})(aS || (aS = {}));
var oS;
(function(e) {
  e[e.REPEATED_FIELD_ENCODING_UNKNOWN = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN", e[e.PACKED = 1] = "PACKED", e[e.EXPANDED = 2] = "EXPANDED";
})(oS || (oS = {}));
var sS;
(function(e) {
  e[e.UTF8_VALIDATION_UNKNOWN = 0] = "UTF8_VALIDATION_UNKNOWN", e[e.VERIFY = 2] = "VERIFY", e[e.NONE = 3] = "NONE";
})(sS || (sS = {}));
var iS;
(function(e) {
  e[e.MESSAGE_ENCODING_UNKNOWN = 0] = "MESSAGE_ENCODING_UNKNOWN", e[e.LENGTH_PREFIXED = 1] = "LENGTH_PREFIXED", e[e.DELIMITED = 2] = "DELIMITED";
})(iS || (iS = {}));
var uS;
(function(e) {
  e[e.JSON_FORMAT_UNKNOWN = 0] = "JSON_FORMAT_UNKNOWN", e[e.ALLOW = 1] = "ALLOW", e[e.LEGACY_BEST_EFFORT = 2] = "LEGACY_BEST_EFFORT";
})(uS || (uS = {}));
var lS;
(function(e) {
  e[e.ENFORCE_NAMING_STYLE_UNKNOWN = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN", e[e.STYLE2024 = 1] = "STYLE2024", e[e.STYLE_LEGACY = 2] = "STYLE_LEGACY";
})(lS || (lS = {}));
var cS;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SET = 1] = "SET", e[e.ALIAS = 2] = "ALIAS";
})(cS || (cS = {}));
var fS;
(function(e) {
  e[e.EDITION_UNKNOWN = 0] = "EDITION_UNKNOWN", e[e.EDITION_LEGACY = 900] = "EDITION_LEGACY", e[e.EDITION_PROTO2 = 998] = "EDITION_PROTO2", e[e.EDITION_PROTO3 = 999] = "EDITION_PROTO3", e[e.EDITION_2023 = 1e3] = "EDITION_2023", e[e.EDITION_2024 = 1001] = "EDITION_2024", e[e.EDITION_UNSTABLE = 9999] = "EDITION_UNSTABLE", e[e.EDITION_1_TEST_ONLY = 1] = "EDITION_1_TEST_ONLY", e[e.EDITION_2_TEST_ONLY = 2] = "EDITION_2_TEST_ONLY", e[e.EDITION_99997_TEST_ONLY = 99997] = "EDITION_99997_TEST_ONLY", e[e.EDITION_99998_TEST_ONLY = 99998] = "EDITION_99998_TEST_ONLY", e[e.EDITION_99999_TEST_ONLY = 99999] = "EDITION_99999_TEST_ONLY", e[e.EDITION_MAX = 2147483647] = "EDITION_MAX";
})(fS || (fS = {}));
var mS;
(function(e) {
  e[e.VISIBILITY_UNSET = 0] = "VISIBILITY_UNSET", e[e.VISIBILITY_LOCAL = 1] = "VISIBILITY_LOCAL", e[e.VISIBILITY_EXPORT = 2] = "VISIBILITY_EXPORT";
})(mS || (mS = {}));
const dS = {
  readUnknownFields: !0
};
function iq(e) {
  return e ? Object.assign(Object.assign({}, dS), e) : dS;
}
function Ob(e, t, n) {
  const r = Zn(e, void 0, !1);
  return v$(r, new C0(t), iq(n), !1, t.byteLength), r.message;
}
function v$(e, t, n, r, a) {
  var o;
  const s = r ? t.len : t.pos + a;
  let i, u;
  const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
  for (; t.pos < s && ([i, u] = t.tag(), !(r && u == ie.EndGroup)); ) {
    const c = e.findNumber(i);
    if (!c) {
      const f = t.skip(u, i);
      n.readUnknownFields && l.push({ no: i, wireType: u, data: f });
      continue;
    }
    T$(e, t, c, u, n);
  }
  if (r && (u != ie.EndGroup || i !== a))
    throw new Error("invalid end group tag");
  l.length > 0 && e.setUnknown(l);
}
function T$(e, t, n, r, a) {
  var o;
  switch (n.fieldKind) {
    case "scalar":
      e.set(n, Wi(t, n.scalar));
      break;
    case "enum":
      const s = Wi(t, E.INT32);
      if (n.enum.open)
        e.set(n, s);
      else if (n.enum.values.some((i) => i.number === s))
        e.set(n, s);
      else if (a.readUnknownFields) {
        const i = [];
        Yy(s, i);
        const u = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
        u.push({
          no: n.number,
          wireType: r,
          data: new Uint8Array(i)
        }), e.setUnknown(u);
      }
      break;
    case "message":
      e.set(n, Q0(t, a, n, e.get(n)));
      break;
    case "list":
      lq(t, r, e.get(n), a);
      break;
    case "map":
      uq(t, e.get(n), a);
      break;
  }
}
function uq(e, t, n) {
  const r = t.field();
  let a, o;
  const s = e.uint32(), i = e.pos + s;
  for (; e.pos < i; ) {
    const [u] = e.tag();
    switch (u) {
      case 1:
        a = Wi(e, r.mapKey);
        break;
      case 2:
        switch (r.mapKind) {
          case "scalar":
            o = Wi(e, r.scalar);
            break;
          case "enum":
            o = e.int32();
            break;
          case "message":
            o = Q0(e, n, r);
            break;
        }
        break;
    }
  }
  if (a === void 0 && (a = Ys(r.mapKey, !1)), o === void 0)
    switch (r.mapKind) {
      case "scalar":
        o = Ys(r.scalar, !1);
        break;
      case "enum":
        o = r.enum.values[0].number;
        break;
      case "message":
        o = Zn(r.message, void 0, !1);
        break;
    }
  t.set(a, o);
}
function lq(e, t, n, r) {
  var a;
  const o = n.field();
  if (o.listKind === "message") {
    n.add(Q0(e, r, o));
    return;
  }
  const s = (a = o.scalar) !== null && a !== void 0 ? a : E.INT32;
  if (!(t == ie.LengthDelimited && s != E.STRING && s != E.BYTES)) {
    n.add(Wi(e, s));
    return;
  }
  const i = e.uint32() + e.pos;
  for (; e.pos < i; )
    n.add(Wi(e, s));
}
function Q0(e, t, n, r) {
  const a = n.delimitedEncoding, o = r ?? Zn(n.message, void 0, !1);
  return v$(o, e, t, a, a ? n.number : e.uint32()), o;
}
function Wi(e, t) {
  switch (t) {
    case E.STRING:
      return e.string();
    case E.BOOL:
      return e.bool();
    case E.DOUBLE:
      return e.double();
    case E.FLOAT:
      return e.float();
    case E.INT32:
      return e.int32();
    case E.INT64:
      return e.int64();
    case E.UINT64:
      return e.uint64();
    case E.FIXED64:
      return e.fixed64();
    case E.BYTES:
      return e.bytes();
    case E.FIXED32:
      return e.fixed32();
    case E.SFIXED32:
      return e.sfixed32();
    case E.SFIXED64:
      return e.sfixed64();
    case E.SINT64:
      return e.sint64();
    case E.UINT32:
      return e.uint32();
    case E.SINT32:
      return e.sint32();
  }
}
function I$(e, t) {
  var n;
  const r = Ob(sq, H0(e));
  return r.messageType.forEach(z0), r.dependency = (n = void 0) !== null && n !== void 0 ? n : [], b$(r, (a) => {
  }).getFile(r.name);
}
const cq = /* @__PURE__ */ I$("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), fq = /* @__PURE__ */ ef(cq, 0), mq = 3, pS = {
  writeUnknownFields: !0
};
function dq(e) {
  return e ? Object.assign(Object.assign({}, pS), e) : pS;
}
function w$(e, t, n) {
  return Jd(new r$(), dq(n), Zn(e, t)).finish();
}
function Jd(e, t, n) {
  var r;
  for (const a of n.sortedFields) {
    if (!n.isSet(a)) {
      if (a.presence == mq)
        throw new Error(`cannot encode ${a} to binary: required field not set`);
      continue;
    }
    _$(e, t, n, a);
  }
  if (t.writeUnknownFields)
    for (const { no: a, wireType: o, data: s } of (r = n.getUnknown()) !== null && r !== void 0 ? r : [])
      e.tag(a, o).raw(s);
  return e;
}
function _$(e, t, n, r) {
  var a;
  switch (r.fieldKind) {
    case "scalar":
    case "enum":
      Zd(e, n.desc.typeName, r.name, (a = r.scalar) !== null && a !== void 0 ? a : E.INT32, r.number, n.get(r));
      break;
    case "list":
      pq(e, t, r, n.get(r));
      break;
    case "message":
      O$(e, t, r, n.get(r));
      break;
    case "map":
      for (const [o, s] of n.get(r))
        bq(e, t, r, o, s);
      break;
  }
}
function Zd(e, t, n, r, a, o) {
  S$(e.tag(a, gq(r)), t, n, r, o);
}
function O$(e, t, n, r) {
  n.delimitedEncoding ? Jd(e.tag(n.number, ie.StartGroup), t, r).tag(n.number, ie.EndGroup) : Jd(e.tag(n.number, ie.LengthDelimited).fork(), t, r).join();
}
function pq(e, t, n, r) {
  var a;
  if (n.listKind == "message") {
    for (const s of r)
      O$(e, t, n, s);
    return;
  }
  const o = (a = n.scalar) !== null && a !== void 0 ? a : E.INT32;
  if (n.packed) {
    if (!r.size)
      return;
    e.tag(n.number, ie.LengthDelimited).fork();
    for (const s of r)
      S$(e, n.parent.typeName, n.name, o, s);
    e.join();
    return;
  }
  for (const s of r)
    Zd(e, n.parent.typeName, n.name, o, n.number, s);
}
function bq(e, t, n, r, a) {
  var o;
  switch (e.tag(n.number, ie.LengthDelimited).fork(), Zd(e, n.parent.typeName, n.name, n.mapKey, 1, r), n.mapKind) {
    case "scalar":
    case "enum":
      Zd(e, n.parent.typeName, n.name, (o = n.scalar) !== null && o !== void 0 ? o : E.INT32, 2, a);
      break;
    case "message":
      Jd(e.tag(2, ie.LengthDelimited).fork(), t, a).join();
      break;
  }
  e.join();
}
function S$(e, t, n, r, a) {
  try {
    switch (r) {
      case E.STRING:
        e.string(a);
        break;
      case E.BOOL:
        e.bool(a);
        break;
      case E.DOUBLE:
        e.double(a);
        break;
      case E.FLOAT:
        e.float(a);
        break;
      case E.INT32:
        e.int32(a);
        break;
      case E.INT64:
        e.int64(a);
        break;
      case E.UINT64:
        e.uint64(a);
        break;
      case E.FIXED64:
        e.fixed64(a);
        break;
      case E.BYTES:
        e.bytes(a);
        break;
      case E.FIXED32:
        e.fixed32(a);
        break;
      case E.SFIXED32:
        e.sfixed32(a);
        break;
      case E.SFIXED64:
        e.sfixed64(a);
        break;
      case E.SINT64:
        e.sint64(a);
        break;
      case E.UINT32:
        e.uint32(a);
        break;
      case E.SINT32:
        e.sint32(a);
        break;
    }
  } catch (o) {
    throw o instanceof Error ? new Error(`cannot encode field ${t}.${n} to binary: ${o.message}`) : o;
  }
}
function gq(e) {
  switch (e) {
    case E.BYTES:
    case E.STRING:
      return ie.LengthDelimited;
    case E.DOUBLE:
    case E.FIXED64:
    case E.SFIXED64:
      return ie.Bit64;
    case E.FIXED32:
    case E.SFIXED32:
    case E.FLOAT:
      return ie.Bit32;
    default:
      return ie.Varint;
  }
}
function hq(e, t, n) {
  let r = !1;
  return n || (n = yr(fq), r = !0), n.value = w$(e, t), n.typeUrl = Eq(t.$typeName), r ? n : void 0;
}
function yq(e, t) {
  if (e.typeUrl === "")
    return !1;
  const n = typeof t == "string" ? t : t.typeName, r = D$(e.typeUrl);
  return n === r;
}
function Nq(e, t) {
  if (e.typeUrl === "")
    return;
  const n = t.kind == "message" ? t : t.getMessage(D$(e.typeUrl));
  if (!(!n || !yq(e, n)))
    return Ob(n, e.value);
}
function Eq(e) {
  return `type.googleapis.com/${e}`;
}
function D$(e) {
  const t = e.lastIndexOf("/"), n = t >= 0 ? e.substring(t + 1) : e;
  if (!n.length)
    throw new Error(`invalid type url: ${e}`);
  return n;
}
const ev = /* @__PURE__ */ I$("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), vq = /* @__PURE__ */ ef(ev, 0), k$ = /* @__PURE__ */ ef(ev, 1), Tq = /* @__PURE__ */ ef(ev, 2);
var Ky;
(function(e) {
  e[e.NULL_VALUE = 0] = "NULL_VALUE";
})(Ky || (Ky = {}));
function Iq(e, t) {
  A$(t, e);
  const n = _q(e.$unknown, t), [r, a, o] = Sb(t);
  for (const s of n)
    T$(r, new C0(s.data), a, s.wireType, {
      readUnknownFields: !0
    });
  return o();
}
function wq(e, t, n) {
  var r;
  A$(t, e);
  const a = ((r = e.$unknown) !== null && r !== void 0 ? r : []).filter((l) => l.no !== t.number), [o, s] = Sb(t, n), i = new r$();
  _$(i, { writeUnknownFields: !0 }, o, s);
  const u = new C0(i.finish());
  for (; u.pos < u.len; ) {
    const [l, c] = u.tag(), f = u.skip(c, l);
    a.push({ no: l, wireType: c, data: f });
  }
  e.$unknown = a;
}
function _q(e, t) {
  if (e === void 0)
    return [];
  if (t.fieldKind === "enum" || t.fieldKind === "scalar") {
    for (let n = e.length - 1; n >= 0; --n)
      if (e[n].no == t.number)
        return [e[n]];
    return [];
  }
  return e.filter((n) => n.no === t.number);
}
function Sb(e, t) {
  const n = e.typeName, r = Object.assign(Object.assign({}, e), { kind: "field", parent: e.extendee, localName: n }), a = Object.assign(Object.assign({}, e.extendee), { fields: [r], members: [r], oneofs: [] }), o = yr(a, t !== void 0 ? { [n]: t } : void 0);
  return [
    Zn(a, o),
    r,
    () => {
      const s = o[n];
      if (s === void 0) {
        const i = e.message;
        return Qc(i) ? Ys(i.fields[0].scalar, i.fields[0].longAsString) : yr(i);
      }
      return s;
    }
  ];
}
function A$(e, t) {
  if (e.extendee.typeName != t.$typeName)
    throw new Error(`extension ${e.typeName} can only be applied to message ${e.extendee.typeName}`);
}
const Oq = 3, Sq = 2, bS = {
  alwaysEmitImplicit: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1
};
function Dq(e) {
  return e ? Object.assign(Object.assign({}, bS), e) : bS;
}
function kq(e, t, n) {
  return tf(Zn(e, t), Dq(n));
}
function Aq(e, t, n) {
  var r;
  const a = kq(e, t, n);
  return JSON.stringify(a, null, (r = n?.prettySpaces) !== null && r !== void 0 ? r : 0);
}
function tf(e, t) {
  var n;
  const r = Rq(e, t);
  if (r !== void 0)
    return r;
  const a = {};
  for (const o of e.sortedFields) {
    if (!e.isSet(o)) {
      if (o.presence == Oq)
        throw new Error(`cannot encode ${o} to JSON: required field not set`);
      if (!t.alwaysEmitImplicit || o.presence !== Sq)
        continue;
    }
    const s = gS(o, e.get(o), t);
    s !== void 0 && (a[Uq(o, t)] = s);
  }
  if (t.registry) {
    const o = /* @__PURE__ */ new Set();
    for (const { no: s } of (n = e.getUnknown()) !== null && n !== void 0 ? n : [])
      if (!o.has(s)) {
        o.add(s);
        const i = t.registry.getExtensionFor(e.desc, s);
        if (!i)
          continue;
        const u = Iq(e.message, i), [l, c] = Sb(i, u), f = gS(c, l.get(c), t);
        f !== void 0 && (a[i.jsonName] = f);
      }
  }
  return a;
}
function gS(e, t, n) {
  switch (e.fieldKind) {
    case "scalar":
      return Db(e, t);
    case "message":
      return tf(t, n);
    case "enum":
      return tv(e.enum, t, n.enumAsInteger);
    case "list":
      return Fq(t, n);
    case "map":
      return Lq(t, n);
  }
}
function Lq(e, t) {
  const n = e.field(), r = {};
  switch (n.mapKind) {
    case "scalar":
      for (const [a, o] of e)
        r[a] = Db(n, o);
      break;
    case "message":
      for (const [a, o] of e)
        r[a] = tf(o, t);
      break;
    case "enum":
      for (const [a, o] of e)
        r[a] = tv(n.enum, o, t.enumAsInteger);
      break;
  }
  return t.alwaysEmitImplicit || e.size > 0 ? r : void 0;
}
function Fq(e, t) {
  const n = e.field(), r = [];
  switch (n.listKind) {
    case "scalar":
      for (const a of e)
        r.push(Db(n, a));
      break;
    case "enum":
      for (const a of e)
        r.push(tv(n.enum, a, t.enumAsInteger));
      break;
    case "message":
      for (const a of e)
        r.push(tf(a, t));
      break;
  }
  return t.alwaysEmitImplicit || r.length > 0 ? r : void 0;
}
function tv(e, t, n) {
  var r;
  if (typeof t != "number")
    throw new Error(`cannot encode ${e} to JSON: expected number, got ${Ve(t)}`);
  return e.typeName == "google.protobuf.NullValue" ? null : n ? t : (r = e.value[t]?.name) !== null && r !== void 0 ? r : t;
}
function Db(e, t) {
  var n, r, a, o, s, i;
  switch (e.scalar) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case E.INT32:
    case E.SFIXED32:
    case E.SINT32:
    case E.FIXED32:
    case E.UINT32:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(n = Ro(e, t)) === null || n === void 0 ? void 0 : n.message}`);
      return t;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case E.FLOAT:
    case E.DOUBLE:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(r = Ro(e, t)) === null || r === void 0 ? void 0 : r.message}`);
      return Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    // string:
    case E.STRING:
      if (typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(a = Ro(e, t)) === null || a === void 0 ? void 0 : a.message}`);
      return t;
    // bool:
    case E.BOOL:
      if (typeof t != "boolean")
        throw new Error(`cannot encode ${e} to JSON: ${(o = Ro(e, t)) === null || o === void 0 ? void 0 : o.message}`);
      return t;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case E.UINT64:
    case E.FIXED64:
    case E.INT64:
    case E.SFIXED64:
    case E.SINT64:
      if (typeof t != "bigint" && typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(s = Ro(e, t)) === null || s === void 0 ? void 0 : s.message}`);
      return t.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case E.BYTES:
      if (t instanceof Uint8Array)
        return d$(t);
      throw new Error(`cannot encode ${e} to JSON: ${(i = Ro(e, t)) === null || i === void 0 ? void 0 : i.message}`);
  }
}
function Uq(e, t) {
  return t.useProtoFieldName ? e.name : e.jsonName;
}
function Rq(e, t) {
  if (e.desc.typeName.startsWith("google.protobuf."))
    switch (e.desc.typeName) {
      case "google.protobuf.Any":
        return $q(e.message, t);
      case "google.protobuf.Timestamp":
        return xq(e.message);
      case "google.protobuf.Duration":
        return Pq(e.message);
      case "google.protobuf.FieldMask":
        return Vq(e.message);
      case "google.protobuf.Struct":
        return L$(e.message);
      case "google.protobuf.Value":
        return nv(e.message);
      case "google.protobuf.ListValue":
        return F$(e.message);
      default:
        if (Qc(e.desc)) {
          const n = e.desc.fields[0];
          return Db(n, e.get(n));
        }
        return;
    }
}
function $q(e, t) {
  if (e.typeUrl === "")
    return {};
  const { registry: n } = t;
  let r, a;
  if (n && (r = Nq(e, n), r && (a = n.getMessage(r.$typeName))), !a || !r)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: "${e.typeUrl}" is not in the type registry`);
  let o = tf(Zn(a, r), t);
  return (a.typeName.startsWith("google.protobuf.") || o === null || Array.isArray(o) || typeof o != "object") && (o = { value: o }), o["@type"] = e.typeUrl, o;
}
function Pq(e) {
  const t = Number(e.seconds), n = e.nanos;
  if (t > 315576e6 || t < -315576e6)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: value out of range`);
  if (t > 0 && n < 0 || t < 0 && n > 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos sign must match seconds sign`);
  let r = e.seconds.toString();
  if (n !== 0) {
    let a = Math.abs(n).toString();
    a = "0".repeat(9 - a.length) + a, a.substring(3) === "000000" ? a = a.substring(0, 3) : a.substring(6) === "000" && (a = a.substring(0, 6)), r += "." + a, n < 0 && t == 0 && (r = "-" + r);
  }
  return r + "s";
}
function Vq(e) {
  return e.paths.map((t) => {
    if (t.match(/_[0-9]?_/g) || t.match(/[A-Z]/g))
      throw new Error(`cannot encode message ${e.$typeName} to JSON: lowerCamelCase of path name "` + t + '" is irreversible');
    return _l(t);
  }).join(",");
}
function L$(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = nv(r);
  return t;
}
function nv(e) {
  switch (e.kind.case) {
    case "nullValue":
      return null;
    case "numberValue":
      if (!Number.isFinite(e.kind.value))
        throw new Error(`${e.$typeName} cannot be NaN or Infinity`);
      return e.kind.value;
    case "boolValue":
      return e.kind.value;
    case "stringValue":
      return e.kind.value;
    case "structValue":
      return L$(e.kind.value);
    case "listValue":
      return F$(e.kind.value);
    default:
      throw new Error(`${e.$typeName} must have a value`);
  }
}
function F$(e) {
  return e.values.map(nv);
}
function xq(e) {
  const t = Number(e.seconds) * 1e3;
  if (t < Date.parse("0001-01-01T00:00:00Z") || t > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot encode message ${e.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  if (e.nanos < 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be negative`);
  if (e.nanos > 999999999)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be greater than 99999999`);
  let n = "Z";
  if (e.nanos > 0) {
    const r = (e.nanos + 1e9).toString().substring(1);
    r.substring(3) === "000000" ? n = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? n = "." + r.substring(0, 6) + "Z" : n = "." + r + "Z";
  }
  return new Date(t).toISOString().replace(".000Z", n);
}
const hS = {
  ignoreUnknownFields: !1
};
function Yq(e) {
  return e ? Object.assign(Object.assign({}, hS), e) : hS;
}
function jq(e, t, n) {
  return U$(e, Wq(t, e.typeName), n);
}
function U$(e, t, n) {
  const r = Zn(e);
  try {
    Ji(r, t, Yq(n));
  } catch (a) {
    throw Ez(a) ? new Error(`cannot decode ${a.field()} from JSON: ${a.message}`, {
      cause: a
    }) : a;
  }
  return r.message;
}
function Ji(e, t, n) {
  var r;
  if (Jq(e, t, n))
    return;
  if (t == null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode ${e.desc} from JSON: ${Ve(t)}`);
  const a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const s of e.desc.fields)
    o.set(s.name, s).set(s.jsonName, s);
  for (const [s, i] of Object.entries(t)) {
    const u = o.get(s);
    if (u) {
      if (u.oneof) {
        if (i === null && u.fieldKind == "scalar")
          continue;
        const l = a.get(u.oneof);
        if (l !== void 0)
          throw new xt(u.oneof, `oneof set multiple times by ${l.name} and ${u.name}`);
        a.set(u.oneof, u);
      }
      yS(e, u, i, n);
    } else {
      let l;
      if (s.startsWith("[") && s.endsWith("]") && // biome-ignore lint/suspicious/noAssignInExpressions: no
      (l = (r = n.registry) === null || r === void 0 ? void 0 : r.getExtension(s.substring(1, s.length - 1))) && l.extendee.typeName === e.desc.typeName) {
        const [c, f, d] = Sb(l);
        yS(c, f, i, n), wq(e.message, l, d());
      }
      if (!l && !n.ignoreUnknownFields)
        throw new Error(`cannot decode ${e.desc} from JSON: key "${s}" is unknown`);
    }
  }
}
function yS(e, t, n, r) {
  switch (t.fieldKind) {
    case "scalar":
      Kq(e, t, n);
      break;
    case "enum":
      Cq(e, t, n, r);
      break;
    case "message":
      Mq(e, t, n, r);
      break;
    case "list":
      Gq(e.get(t), n, r);
      break;
    case "map":
      Bq(e.get(t), n, r);
      break;
  }
}
function Bq(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (typeof t != "object" || Array.isArray(t))
    throw new xt(r, "expected object, got " + Ve(t));
  for (const [a, o] of Object.entries(t)) {
    if (o === null && !R$(r))
      throw new xt(r, "map value must not be null");
    let s;
    switch (r.mapKind) {
      case "message":
        const u = Zn(r.message);
        Ji(u, o, n), s = u;
        break;
      case "enum":
        if (s = rv(r.enum, o, n.ignoreUnknownFields, !0), s === kb)
          return;
        break;
      case "scalar":
        s = Lb(r, o, !0);
        break;
    }
    const i = Xq(r.mapKey, a);
    e.set(i, s);
  }
}
function Gq(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (!Array.isArray(t))
    throw new xt(r, "expected Array, got " + Ve(t));
  for (const a of t) {
    if (a === null && !R$(r))
      throw new xt(r, "list item must not be null");
    switch (r.listKind) {
      case "message":
        const o = Zn(r.message);
        Ji(o, a, n), e.add(o);
        break;
      case "enum":
        const s = rv(r.enum, a, n.ignoreUnknownFields, !0);
        s !== kb && e.add(s);
        break;
      case "scalar":
        e.add(Lb(r, a, !0));
        break;
    }
  }
}
function R$(e) {
  var t, n;
  return ((t = e.message) === null || t === void 0 ? void 0 : t.typeName) == "google.protobuf.Value" || ((n = e.enum) === null || n === void 0 ? void 0 : n.typeName) == "google.protobuf.NullValue";
}
function Mq(e, t, n, r) {
  if (n === null && t.message.typeName != "google.protobuf.Value") {
    e.clear(t);
    return;
  }
  const a = e.isSet(t) ? e.get(t) : Zn(t.message);
  Ji(a, n, r), e.set(t, a);
}
function Cq(e, t, n, r) {
  const a = rv(t.enum, n, r.ignoreUnknownFields, !1);
  a === Ab ? e.clear(t) : a !== kb && e.set(t, a);
}
function Kq(e, t, n) {
  const r = Lb(t, n, !1);
  r === Ab ? e.clear(t) : e.set(t, r);
}
const kb = /* @__PURE__ */ Symbol();
function rv(e, t, n, r) {
  if (t === null)
    return e.typeName == "google.protobuf.NullValue" ? 0 : r ? e.values[0].number : Ab;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const a = e.values.find((o) => o.name === t);
      if (a !== void 0)
        return a.number;
      if (n)
        return kb;
      break;
  }
  throw new Error(`cannot decode ${e} from JSON: ${Ve(t)}`);
}
const Ab = /* @__PURE__ */ Symbol();
function Lb(e, t, n) {
  if (t === null)
    return n ? Ys(e.scalar, !1) : Ab;
  switch (e.scalar) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case E.DOUBLE:
    case E.FLOAT:
      if (t === "NaN")
        return NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (typeof t == "number") {
        if (Number.isNaN(t))
          throw new xt(e, "unexpected NaN number");
        if (!Number.isFinite(t))
          throw new xt(e, "unexpected infinite number");
        break;
      }
      if (typeof t == "string") {
        if (t === "" || t.trim().length !== t.length)
          break;
        const r = Number(t);
        if (!Number.isFinite(r))
          break;
        return r;
      }
      break;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case E.INT32:
    case E.FIXED32:
    case E.SFIXED32:
    case E.SINT32:
    case E.UINT32:
      return $$(t);
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case E.BYTES:
      if (typeof t == "string") {
        if (t === "")
          return new Uint8Array(0);
        try {
          return H0(t);
        } catch (r) {
          const a = r instanceof Error ? r.message : String(r);
          throw new xt(e, a);
        }
      }
      break;
  }
  return t;
}
function Xq(e, t) {
  switch (e) {
    case E.BOOL:
      switch (t) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      return t;
    case E.INT32:
    case E.FIXED32:
    case E.UINT32:
    case E.SFIXED32:
    case E.SINT32:
      return $$(t);
    default:
      return t;
  }
}
function $$(e) {
  if (typeof e == "string") {
    if (e === "" || e.trim().length !== e.length)
      return e;
    const t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
function Wq(e, t) {
  try {
    return JSON.parse(e);
  } catch (n) {
    const r = n instanceof Error ? n.message : String(n);
    throw new Error(
      `cannot decode message ${t} from JSON: ${r}`,
      // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
      { cause: n }
    );
  }
}
function Jq(e, t, n) {
  if (!e.desc.typeName.startsWith("google.protobuf."))
    return !1;
  switch (e.desc.typeName) {
    case "google.protobuf.Any":
      return Zq(e.message, t, n), !0;
    case "google.protobuf.Timestamp":
      return Hq(e.message, t), !0;
    case "google.protobuf.Duration":
      return zq(e.message, t), !0;
    case "google.protobuf.FieldMask":
      return qq(e.message, t), !0;
    case "google.protobuf.Struct":
      return P$(e.message, t), !0;
    case "google.protobuf.Value":
      return av(e.message, t), !0;
    case "google.protobuf.ListValue":
      return V$(e.message, t), !0;
    default:
      if (Qc(e.desc)) {
        const r = e.desc.fields[0];
        return t === null ? e.clear(r) : e.set(r, Lb(r, t, !0)), !0;
      }
      return !1;
  }
}
function Zq(e, t, n) {
  var r;
  if (t === null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: expected object but got ${Ve(t)}`);
  if (Object.keys(t).length == 0)
    return;
  const a = t["@type"];
  if (typeof a != "string" || a == "")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is empty`);
  const o = a.includes("/") ? a.substring(a.lastIndexOf("/") + 1) : a;
  if (!o.length)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is invalid`);
  const s = (r = n.registry) === null || r === void 0 ? void 0 : r.getMessage(o);
  if (!s)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${a} is not in the type registry`);
  const i = Zn(s);
  if (o.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(t, "value")) {
    const u = t.value;
    Ji(i, u, n);
  } else {
    const u = Object.assign({}, t);
    delete u["@type"], Ji(i, u, n);
  }
  hq(i.desc, i.message, e);
}
function Hq(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ve(t)}`);
  const n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
  if (!n)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  const r = Date.parse(
    // biome-ignore format: want this to read well
    n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z")
  );
  if (Number.isNaN(r))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  e.seconds = Z.parse(r / 1e3), e.nanos = 0, n[7] && (e.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9);
}
function zq(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ve(t)}`);
  const n = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
  if (n === null)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ve(t)}`);
  const r = Number(n[1]);
  if (r > 315576e6 || r < -315576e6)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ve(t)}`);
  if (e.seconds = Z.parse(r), typeof n[2] != "string")
    return;
  const a = n[2] + "0".repeat(9 - n[2].length);
  e.nanos = parseInt(a), (r < 0 || Object.is(r, -0)) && (e.nanos = -e.nanos);
}
function qq(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ve(t)}`);
  if (t === "")
    return;
  function n(r) {
    if (r.includes("_"))
      throw new Error(`cannot decode message ${e.$typeName} from JSON: path names must be lowerCamelCase`);
    const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase());
    return a[0] === "_" ? a.substring(1) : a;
  }
  e.paths = t.split(",").map(n);
}
function P$(e, t) {
  if (typeof t != "object" || t == null || Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Ve(t)}`);
  for (const [n, r] of Object.entries(t)) {
    const a = yr(k$);
    av(a, r), e.fields[n] = a;
  }
}
function av(e, t) {
  switch (typeof t) {
    case "number":
      e.kind = { case: "numberValue", value: t };
      break;
    case "string":
      e.kind = { case: "stringValue", value: t };
      break;
    case "boolean":
      e.kind = { case: "boolValue", value: t };
      break;
    case "object":
      if (t === null)
        e.kind = { case: "nullValue", value: Ky.NULL_VALUE };
      else if (Array.isArray(t)) {
        const n = yr(Tq);
        V$(n, t), e.kind = { case: "listValue", value: n };
      } else {
        const n = yr(vq);
        P$(n, t), e.kind = { case: "structValue", value: n };
      }
      break;
    default:
      throw new Error(`cannot decode message ${e.$typeName} from JSON ${Ve(t)}`);
  }
  return e;
}
function V$(e, t) {
  if (!Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Ve(t)}`);
  for (const n of t) {
    const r = yr(k$);
    av(r, n), e.values.push(r);
  }
}
function Xy(e) {
  const t = Y[e];
  return typeof t != "string" ? e.toString() : t[0].toLowerCase() + t.substring(1).replace(/[A-Z]/g, (n) => "_" + n.toLowerCase());
}
let fm;
function Qq(e) {
  if (!fm) {
    fm = {};
    for (const t of Object.values(Y))
      typeof t != "string" && (fm[Xy(t)] = t);
  }
  return fm[e];
}
class Se extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(t, n = Y.Unknown, r, a, o) {
    super(eQ(t, n)), this.name = "ConnectError", Object.setPrototypeOf(this, new.target.prototype), this.rawMessage = t, this.code = n, this.metadata = new Headers(r ?? {}), this.details = a ?? [], this.cause = o;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(t, n = Y.Unknown) {
    return t instanceof Se ? t : t instanceof Error ? t.name == "AbortError" || t.name == "TimeoutError" ? new Se(t.message, Y.Canceled) : new Se(t.message, n, void 0, void 0, t) : new Se(String(t), n, void 0, void 0, t);
  }
  static [Symbol.hasInstance](t) {
    return t instanceof Error ? Object.getPrototypeOf(t) === Se.prototype ? !0 : t.name === "ConnectError" && "code" in t && typeof t.code == "number" && "metadata" in t && "details" in t && Array.isArray(t.details) && "rawMessage" in t && typeof t.rawMessage == "string" && "cause" in t : !1;
  }
  findDetails(t) {
    const n = t.kind === "message" ? {
      getMessage: (a) => a === t.typeName ? t : void 0
    } : t, r = [];
    for (const a of this.details) {
      if ("desc" in a) {
        n.getMessage(a.desc.typeName) && r.push(yr(a.desc, a.value));
        continue;
      }
      const o = n.getMessage(a.type);
      if (o)
        try {
          r.push(Ob(o, a.value));
        } catch {
        }
    }
    return r;
  }
}
function eQ(e, t) {
  return e.length ? `[${Xy(t)}] ${e}` : `[${Xy(t)}]`;
}
function tQ(...e) {
  const t = new Headers();
  for (const n of e)
    n.forEach((r, a) => {
      t.append(a, r);
    });
  return t;
}
const NS = 1;
function nQ(e, t, n = !1) {
  if (t > e) {
    let r = `message size is larger than configured readMaxBytes ${e}`;
    throw n && (r = `message size ${t} is larger than configured readMaxBytes ${e}`), new Se(r, Y.ResourceExhausted);
  }
}
function rQ(e) {
  return new aQ(e);
}
class aQ {
  constructor(t) {
    this.readMaxBytes = t, this.header = new Uint8Array(5), this.headerView = new DataView(this.header.buffer), this.buf = [];
  }
  get byteLength() {
    return this.buf.reduce((t, n) => t + n.byteLength, 0);
  }
  decode(t) {
    this.buf.push(t);
    const n = [];
    for (; ; ) {
      let r = this.pop();
      if (!r)
        break;
      n.push(r);
    }
    return n;
  }
  // consume an enveloped message
  pop() {
    if (!(!this.env && (this.env = this.head(), !this.env)) && this.cons(this.env.data)) {
      const t = this.env;
      return this.env = void 0, t;
    }
  }
  // consume header
  head() {
    if (!this.cons(this.header))
      return;
    const t = this.headerView.getUint8(0), n = this.headerView.getUint32(1);
    return nQ(this.readMaxBytes, n, !0), {
      flags: t,
      data: new Uint8Array(n)
    };
  }
  // consume from buffer, fill target
  cons(t) {
    const n = t.byteLength;
    if (this.byteLength < n)
      return !1;
    let r = 0;
    for (; r < n; ) {
      const a = this.buf.shift();
      a.byteLength > n - r ? (t.set(a.subarray(0, n - r), r), this.buf.unshift(a.subarray(n - r)), r += n - r) : (t.set(a, r), r += a.byteLength);
    }
    return !0;
  }
}
function oQ(e) {
  let t;
  const n = rQ(4294967295);
  return new ReadableStream({
    start() {
      t = e.getReader();
    },
    async pull(r) {
      let a = !1;
      for (; !a; ) {
        const o = await t.read();
        if (o.done)
          n.byteLength > 0 && r.error(new Se("protocol error: incomplete envelope", Y.InvalidArgument)), r.close();
        else
          for (const s of n.decode(o.value))
            r.enqueue(s), a = !0;
      }
    }
  });
}
function sQ(e, t) {
  const n = new Uint8Array(t.length + 5);
  n.set(t, 5);
  const r = new DataView(n.buffer, n.byteOffset, n.byteLength);
  return r.setUint8(0, e), r.setUint32(1, t.length), n;
}
function iQ(...e) {
  const t = new AbortController(), n = e.filter((a) => a !== void 0).concat(t.signal);
  for (const a of n) {
    if (a.aborted) {
      r.apply(a);
      break;
    }
    a.addEventListener("abort", r);
  }
  function r() {
    t.signal.aborted || t.abort(x$(this));
    for (const a of n)
      a.removeEventListener("abort", r);
  }
  return t;
}
function uQ(e) {
  const t = new AbortController(), n = () => {
    t.abort(new Se("the operation timed out", Y.DeadlineExceeded));
  };
  let r;
  return e !== void 0 && (e <= 0 ? n() : r = setTimeout(n, e)), {
    signal: t.signal,
    cleanup: () => clearTimeout(r)
  };
}
function x$(e) {
  if (!e.aborted)
    return;
  if (e.reason !== void 0)
    return e.reason;
  const t = new Error("This operation was aborted");
  return t.name = "AbortError", t;
}
function ES() {
  return {
    get(e) {
      return e.id in this ? this[e.id] : e.defaultValue;
    },
    set(e, t) {
      return this[e.id] = t, this;
    },
    delete(e) {
      return delete this[e.id], this;
    }
  };
}
function vS(e, t) {
  return e.toString().replace(/\/?$/, `/${t.parent.typeName}/${t.name}`);
}
function Y$(e, t) {
  return yr(e, t);
}
function lQ(e, t) {
  function n(r) {
    return r.done === !0 ? r : {
      done: r.done,
      value: Y$(e, r.value)
    };
  }
  return {
    [Symbol.asyncIterator]() {
      const r = t[Symbol.asyncIterator](), a = {
        next: () => r.next().then(n)
      };
      return r.throw !== void 0 && (a.throw = (o) => r.throw(o).then(n)), r.return !== void 0 && (a.return = (o) => r.return(o).then(n)), a;
    }
  };
}
function j$(e, t) {
  if (!t)
    return e;
  for (const n of t.concat().reverse())
    e = n(e);
  return e;
}
function B$(e) {
  var t;
  const n = Object.assign({}, e);
  return (t = n.ignoreUnknownFields) !== null && t !== void 0 || (n.ignoreUnknownFields = !0), n;
}
function TS(e, t, n, r) {
  const a = t ? IS(e.input, r) : wS(e.input, n);
  return { parse: (t ? IS(e.output, r) : wS(e.output, n)).parse, serialize: a.serialize };
}
function IS(e, t) {
  return {
    parse(n) {
      try {
        return Ob(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Se(`parse binary: ${a}`, Y.Internal);
      }
    },
    serialize(n) {
      try {
        return w$(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Se(`serialize binary: ${a}`, Y.Internal);
      }
    }
  };
}
function wS(e, t) {
  var n, r;
  const a = (n = t?.textEncoder) !== null && n !== void 0 ? n : new TextEncoder(), o = (r = t?.textDecoder) !== null && r !== void 0 ? r : new TextDecoder(), s = B$(t);
  return {
    parse(i) {
      try {
        const u = o.decode(i);
        return jq(e, u, s);
      } catch (u) {
        throw Se.from(u, Y.InvalidArgument);
      }
    },
    serialize(i) {
      try {
        const u = Aq(e, i, s);
        return a.encode(u);
      } catch (u) {
        throw Se.from(u, Y.Internal);
      }
    }
  };
}
const cQ = /^application\/(connect\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i, fQ = "application/proto", mQ = "application/json", dQ = "application/connect+proto", pQ = "application/connect+json";
function bQ(e) {
  const t = e?.match(cQ);
  if (!t)
    return;
  const n = !!t[1], r = !!t[3];
  return { stream: n, binary: r };
}
function G$(e, t, n) {
  var r;
  if (t && new Headers(t).forEach((i, u) => n.metadata.append(u, i)), typeof e != "object" || e == null || Array.isArray(e))
    throw n;
  let a = n.code;
  "code" in e && typeof e.code == "string" && (a = (r = Qq(e.code)) !== null && r !== void 0 ? r : a);
  const o = e.message;
  if (o != null && typeof o != "string")
    throw n;
  const s = new Se(o ?? "", a, t);
  if ("details" in e && Array.isArray(e.details))
    for (const i of e.details) {
      if (i === null || typeof i != "object" || Array.isArray(i) || typeof i.type != "string" || typeof i.value != "string")
        throw n;
      try {
        s.details.push({
          type: i.type,
          value: H0(i.value),
          debug: i.debug
        });
      } catch {
        throw n;
      }
    }
  return s;
}
const _S = 2;
function gQ(e) {
  const t = new Se("invalid end stream", Y.Unknown);
  let n;
  try {
    n = JSON.parse(typeof e == "string" ? e : new TextDecoder().decode(e));
  } catch {
    throw t;
  }
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw t;
  const r = new Headers();
  if ("metadata" in n) {
    if (typeof n.metadata != "object" || n.metadata == null || Array.isArray(n.metadata))
      throw t;
    for (const [o, s] of Object.entries(n.metadata)) {
      if (!Array.isArray(s) || s.some((i) => typeof i != "string"))
        throw t;
      for (const i of s)
        r.append(o, i);
    }
  }
  const a = "error" in n && n.error != null ? G$(n.error, r, t) : void 0;
  return { metadata: r, error: a };
}
const Hd = "Content-Type", hQ = "Content-Length", OS = "Content-Encoding", yQ = "Accept-Encoding", NQ = "Connect-Timeout-Ms", M$ = "Connect-Protocol-Version", EQ = "User-Agent";
function vQ(e) {
  switch (e) {
    case 400:
      return Y.Internal;
    case 401:
      return Y.Unauthenticated;
    case 403:
      return Y.PermissionDenied;
    case 404:
      return Y.Unimplemented;
    case 429:
      return Y.Unavailable;
    case 502:
      return Y.Unavailable;
    case 503:
      return Y.Unavailable;
    case 504:
      return Y.Unavailable;
    default:
      return Y.Unknown;
  }
}
function SS(e) {
  const t = new Headers(), n = new Headers();
  return e.forEach((r, a) => {
    a.toLowerCase().startsWith("trailer-") ? n.append(a.substring(8), r) : t.append(a, r);
  }), [t, n];
}
const C$ = "1";
function DS(e, t, n, r, a) {
  const o = new Headers(r ?? {});
  return n !== void 0 && o.set(NQ, `${n}`), o.set(Hd, e == "unary" ? t ? fQ : mQ : t ? dQ : pQ), o.set(M$, C$), o.has(EQ), o;
}
function kS(e, t, n, r) {
  const a = r.get(Hd), o = bQ(a);
  if (n !== 200) {
    const i = new Se(`HTTP ${n}`, vQ(n), r);
    if (e == "unary" && o && !o.binary)
      return { isUnaryError: !0, unaryError: i };
    throw i;
  }
  const s = {
    binary: t,
    stream: e !== "unary"
  };
  if (o?.binary !== s.binary || o.stream !== s.stream)
    throw new Se(`unsupported content type ${a}`, o === void 0 ? Y.Unknown : Y.Internal, r);
  return { isUnaryError: !1 };
}
const AS = "application/";
function TQ(e, t) {
  return t ? d$(e, "url") : encodeURIComponent(new TextDecoder().decode(e));
}
function IQ(e, t, n) {
  let r = `?connect=v${C$}`;
  const a = e.header.get(Hd);
  a?.indexOf(AS) === 0 && (r += "&encoding=" + encodeURIComponent(a.slice(AS.length)));
  const o = e.header.get(OS);
  o !== null && o !== "identity" && (r += "&compression=" + encodeURIComponent(o), n = !0), n && (r += "&base64=1"), r += "&message=" + TQ(t, n);
  const s = e.url + r, i = new Headers(e.header);
  for (const u of [
    M$,
    Hd,
    hQ,
    OS,
    yQ
  ])
    i.delete(u);
  return Object.assign(Object.assign({}, e), {
    requestMethod: "GET",
    url: s,
    header: i
  });
}
function wQ(e) {
  const t = j$(e.next, e.interceptors), [n, r, a] = K$(e), o = Object.assign(Object.assign({}, e.req), { message: Y$(e.req.method.input, e.req.message), signal: n });
  return t(o).then((s) => (a(), s), r);
}
function _Q(e) {
  const t = j$(e.next, e.interceptors), [n, r, a] = K$(e), o = Object.assign(Object.assign({}, e.req), { message: lQ(e.req.method.input, e.req.message), signal: n });
  let s = !1;
  return n.addEventListener("abort", function() {
    var i, u;
    const l = e.req.message[Symbol.asyncIterator]();
    s || (i = l.throw) === null || i === void 0 || i.call(l, this.reason).catch(() => {
    }), (u = l.return) === null || u === void 0 || u.call(l).catch(() => {
    });
  }), t(o).then((i) => Object.assign(Object.assign({}, i), { message: {
    [Symbol.asyncIterator]() {
      const u = i.message[Symbol.asyncIterator]();
      return {
        next() {
          return u.next().then((l) => (l.done == !0 && (s = !0, a()), l), r);
        }
        // We deliberately omit throw/return.
      };
    }
  } }), r);
}
function K$(e) {
  const { signal: t, cleanup: n } = uQ(e.timeoutMs), r = iQ(e.signal, t);
  return [
    r.signal,
    function(a) {
      const o = Se.from(t.aborted ? x$(t) : a);
      return r.abort(o), n(), Promise.reject(o);
    },
    function() {
      n(), r.abort();
    }
  ];
}
function OQ() {
  try {
    new Headers();
  } catch {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}
var Dl = function(e) {
  return this instanceof Dl ? (this.v = e, this) : new Dl(e);
}, SQ = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof Dl ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
const LS = {
  redirect: "error"
};
function DQ(e) {
  var t;
  OQ();
  const n = (t = e.useBinaryFormat) !== null && t !== void 0 ? t : !1;
  return {
    async unary(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = TS(r, n, e.jsonOptions, e.binaryOptions);
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await wQ({
        interceptors: e.interceptors,
        signal: a,
        timeoutMs: o,
        req: {
          stream: !1,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: vS(e.baseUrl, r),
          header: DS(r.methodKind, n, o, s),
          contextValues: u ?? ES(),
          message: i
        },
        next: async (f) => {
          var d;
          const m = e.useHttpGet === !0 && r.idempotency === Cy.NO_SIDE_EFFECTS;
          let p = null;
          m ? f = IQ(f, l(f.message), n) : p = l(f.message);
          const b = await ((d = e.fetch) !== null && d !== void 0 ? d : globalThis.fetch)(f.url, Object.assign(Object.assign({}, LS), { method: f.requestMethod, headers: f.header, signal: f.signal, body: p })), { isUnaryError: g, unaryError: S } = kS(r.methodKind, n, b.status, b.headers);
          if (g)
            throw G$(await b.json(), tQ(...SS(b.headers)), S);
          const [D, k] = SS(b.headers);
          return {
            stream: !1,
            service: r.parent,
            method: r,
            header: D,
            message: n ? c(new Uint8Array(await b.arrayBuffer())) : U$(r.output, await b.json(), B$(e.jsonOptions)),
            trailer: k
          };
        }
      });
    },
    async stream(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = TS(r, n, e.jsonOptions, e.binaryOptions);
      function f(m, p, b, g) {
        return SQ(this, arguments, function* () {
          const S = oQ(m).getReader();
          let D = !1;
          for (; ; ) {
            const k = yield Dl(S.read());
            if (k.done)
              break;
            const { flags: U, data: R } = k.value;
            if ((U & NS) === NS)
              throw new Se("protocol error: received unsupported compressed output", Y.Internal);
            if ((U & _S) === _S) {
              D = !0;
              const F = gQ(R);
              if (F.error) {
                const A = F.error;
                throw b.forEach((L, re) => {
                  A.metadata.append(re, L);
                }), A;
              }
              F.metadata.forEach((A, L) => p.set(L, A));
              continue;
            }
            yield yield Dl(c(R));
          }
          if ("throwIfAborted" in g && g.throwIfAborted(), !D)
            throw "missing EndStreamResponse";
        });
      }
      async function d(m) {
        if (r.methodKind != "server_streaming")
          throw "The fetch API does not support streaming request bodies";
        const p = await m[Symbol.asyncIterator]().next();
        if (p.done == !0)
          throw "missing request message";
        return sQ(0, l(p.value));
      }
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await _Q({
        interceptors: e.interceptors,
        timeoutMs: o,
        signal: a,
        req: {
          stream: !0,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: vS(e.baseUrl, r),
          header: DS(r.methodKind, n, o, s),
          contextValues: u ?? ES(),
          message: i
        },
        next: async (m) => {
          var p;
          const b = await ((p = e.fetch) !== null && p !== void 0 ? p : globalThis.fetch)(m.url, Object.assign(Object.assign({}, LS), { method: m.requestMethod, headers: m.header, signal: m.signal, body: await d(m.message) }));
          if (kS(r.methodKind, n, b.status, b.headers), b.body === null)
            throw "missing response body";
          const g = new Headers();
          return Object.assign(Object.assign({}, m), { header: b.headers, trailer: g, message: f(b.body, g, b.headers, m.signal) });
        }
      });
    }
  };
}
DQ({
  baseUrl: "/api",
  useBinaryFormat: !0,
  fetch: (e, t) => {
    const n = t?.headers ?? {};
    return fetch(e, {
      ...t,
      headers: {
        ...n,
        "qt-widget-id": window.qtWidgetId
      }
    });
  }
});
const bt = /* @__PURE__ */ Symbol(), kQ = !1;
var AQ = Array.isArray, LQ = Array.prototype.indexOf, th = Object.getOwnPropertyDescriptor, FQ = Object.prototype, UQ = Array.prototype, RQ = Object.getPrototypeOf;
function $Q(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function PQ() {
  var e, t, n = new Promise((r, a) => {
    e = r, t = a;
  });
  return { promise: n, resolve: e, reject: t };
}
const un = 2, VQ = 4, xQ = 1 << 24, Iu = 16, nf = 32, rf = 64, ov = 128, Wr = 512, wt = 1024, Nr = 2048, Jr = 4096, ed = 8192, ms = 16384, YQ = 32768, FS = 1 << 17, X$ = 1 << 18, js = 32768, Wy = 1 << 21, W$ = 1 << 22, kl = 1 << 23, nh = /* @__PURE__ */ Symbol("$state"), J$ = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function jQ() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function BQ() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function GQ() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function MQ() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function CQ(e) {
  return e === this.v;
}
let KQ = !1;
function Z$() {
  return !0;
}
let hi = [];
function XQ() {
  var e = hi;
  hi = [], $Q(e);
}
function WQ(e) {
  if (hi.length === 0) {
    var t = hi;
    queueMicrotask(() => {
      t === hi && XQ();
    });
  }
  hi.push(e);
}
function JQ(e) {
  var t = Yt;
  if (t === null)
    return ye.f |= kl, e;
  if ((t.f & YQ) === 0) {
    if ((t.f & ov) === 0)
      throw e;
    t.b.error(e);
  } else
    H$(e, t);
}
function H$(e, t) {
  for (; t !== null; ) {
    if ((t.f & ov) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e;
}
const mm = /* @__PURE__ */ new Set();
let Je = null, Yn = null, $r = [], sv = null, Jy = !1;
class Al {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #e = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #i = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    $r = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const r of t)
      this.#u(r, n);
    this.is_fork || this.#c(), this.is_deferred() ? (this.#n(n.effects), this.#n(n.render_effects)) : (Je = null, US(n.render_effects), US(n.effects), this.#i?.resolve()), Yn = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #u(t, n) {
    t.f ^= wt;
    for (var r = t.first; r !== null; ) {
      var a = r.f, o = (a & (nf | rf)) !== 0, s = o && (a & wt) !== 0, i = s || (a & ed) !== 0 || this.skipped_effects.has(r);
      if ((r.f & ov) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: []
      }), !i && r.fn !== null) {
        o ? r.f ^= wt : (a & VQ) !== 0 ? n.effects.push(r) : of(r) && ((r.f & Iu) !== 0 && this.#o.add(r), tp(r));
        var u = r.first;
        if (u !== null) {
          r = u;
          continue;
        }
      }
      var l = r.parent;
      for (r = r.next; r === null && l !== null; )
        l === n.effect && (this.#n(n.effects), this.#n(n.render_effects), n = /** @type {EffectTarget} */
        n.parent), r = l.next, l = l.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #n(t) {
    for (const n of t)
      (n.f & Nr) !== 0 ? this.#o.add(n) : (n.f & Jr) !== 0 && this.#s.add(n), this.#l(n.deps), jt(n, wt);
  }
  /**
   * @param {Value[] | null} deps
   */
  #l(t) {
    if (t !== null)
      for (const n of t)
        (n.f & un) === 0 || (n.f & js) === 0 || (n.f ^= js, this.#l(
          /** @type {Derived} */
          n.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.previous.has(t) || this.previous.set(t, n), (t.f & kl) === 0 && (this.current.set(t, t.v), Yn?.set(t, t.v));
  }
  activate() {
    Je = this, this.apply();
  }
  deactivate() {
    Je === this && (Je = null, Yn = null);
  }
  flush() {
    if (this.activate(), $r.length > 0) {
      if (ZQ(), Je !== null && Je !== this)
        return;
    } else this.#e === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const t of this.#a) t(this);
    this.#a.clear();
  }
  #c() {
    if (this.#t === 0) {
      for (const t of this.#r) t();
      this.#r.clear();
    }
    this.#e === 0 && this.#f();
  }
  #f() {
    if (mm.size > 1) {
      this.previous.clear();
      var t = Yn, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const o of mm) {
        if (o === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [u, l] of this.current) {
          if (o.current.has(u))
            if (n && l !== o.current.get(u))
              o.current.set(u, l);
            else
              continue;
          s.push(u);
        }
        if (s.length === 0)
          continue;
        const i = [...o.current.keys()].filter((u) => !this.current.has(u));
        if (i.length > 0) {
          var a = $r;
          $r = [];
          const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            z$(c, i, u, l);
          if ($r.length > 0) {
            Je = o, o.apply();
            for (const c of $r)
              o.#u(c, r);
            o.deactivate();
          }
          $r = a;
        }
      }
      Je = null, Yn = t;
    }
    this.committed = !0, mm.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(t) {
    this.#e += 1, t && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(t) {
    this.#e -= 1, t && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const t of this.#o)
      this.#s.delete(t), jt(t, Nr), Ll(t);
    for (const t of this.#s)
      jt(t, Jr), Ll(t);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(t) {
    this.#r.add(t);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(t) {
    this.#a.add(t);
  }
  settled() {
    return (this.#i ??= PQ()).promise;
  }
  static ensure() {
    if (Je === null) {
      const t = Je = new Al();
      mm.add(Je), Al.enqueue(() => {
        Je === t && t.flush();
      });
    }
    return Je;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    WQ(t);
  }
  apply() {
  }
}
function ZQ() {
  var e = ds;
  Jy = !0;
  try {
    var t = 0;
    for (qd(!0); $r.length > 0; ) {
      var n = Al.ensure();
      if (t++ > 1e3) {
        var r, a;
        HQ();
      }
      n.process($r), lo.clear();
    }
  } finally {
    Jy = !1, qd(e), sv = null;
  }
}
function HQ() {
  try {
    jQ();
  } catch (e) {
    H$(e, sv);
  }
}
let pa = null;
function US(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (ms | ed)) === 0 && of(r) && (pa = /* @__PURE__ */ new Set(), tp(r), r.deps === null && r.first === null && r.nodes === null && (r.teardown === null && r.ac === null ? sP(r) : r.fn = null), pa?.size > 0)) {
        lo.clear();
        for (const a of pa) {
          if ((a.f & (ms | ed)) !== 0) continue;
          const o = [a];
          let s = a.parent;
          for (; s !== null; )
            pa.has(s) && (pa.delete(s), o.push(s)), s = s.parent;
          for (let i = o.length - 1; i >= 0; i--) {
            const u = o[i];
            (u.f & (ms | ed)) === 0 && tp(u);
          }
        }
        pa.clear();
      }
    }
    pa = null;
  }
}
function z$(e, t, n, r) {
  if (!n.has(e) && (n.add(e), e.reactions !== null))
    for (const a of e.reactions) {
      const o = a.f;
      (o & un) !== 0 ? z$(
        /** @type {Derived} */
        a,
        t,
        n,
        r
      ) : (o & (W$ | Iu)) !== 0 && (o & Nr) === 0 && q$(a, t, r) && (jt(a, Nr), Ll(
        /** @type {Effect} */
        a
      ));
    }
}
function q$(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (e.deps !== null)
    for (const a of e.deps) {
      if (t.includes(a))
        return !0;
      if ((a.f & un) !== 0 && q$(
        /** @type {Derived} */
        a,
        t,
        n
      ))
        return n.set(
          /** @type {Derived} */
          a,
          !0
        ), !0;
    }
  return n.set(e, !1), !1;
}
function Ll(e) {
  for (var t = sv = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (Jy && t === Yt && (n & Iu) !== 0 && (n & X$) === 0)
      return;
    if ((n & (rf | nf)) !== 0) {
      if ((n & wt) === 0) return;
      t.f ^= wt;
    }
  }
  $r.push(t);
}
function Q$(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      uv(
        /** @type {Effect} */
        t[n]
      );
  }
}
function zQ(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & un) === 0)
      return (t.f & ms) === 0 ? (
        /** @type {Effect} */
        t
      ) : null;
    t = t.parent;
  }
  return null;
}
function iv(e) {
  var t, n = Yt;
  Qd(zQ(e));
  try {
    e.f &= ~js, Q$(e), t = cP(e);
  } finally {
    Qd(n);
  }
  return t;
}
function eP(e) {
  var t = iv(e);
  if (e.equals(t) || (Je?.is_fork || (e.v = t), e.wv = uP()), !af)
    if (Yn !== null)
      (zd() || Je?.is_fork) && Yn.set(e, t);
    else {
      var n = (e.f & Wr) === 0 ? Jr : wt;
      jt(e, n);
    }
}
let Zy = /* @__PURE__ */ new Set();
const lo = /* @__PURE__ */ new Map();
let tP = !1;
function qQ(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: CQ,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function za(e, t) {
  const n = qQ(e);
  return oee(n), n;
}
function $o(e, t, n = !1) {
  ye !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!zo || (ye.f & FS) !== 0) && Z$() && (ye.f & (un | Iu | W$ | FS)) !== 0 && !ja?.includes(e) && MQ();
  let r = n ? yi(t) : t;
  return QQ(e, r);
}
function QQ(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    af ? lo.set(e, t) : lo.set(e, n), e.v = t;
    var r = Al.ensure();
    r.capture(e, n), (e.f & un) !== 0 && ((e.f & Nr) !== 0 && iv(
      /** @type {Derived} */
      e
    ), jt(e, (e.f & Wr) !== 0 ? wt : Jr)), e.wv = uP(), nP(e, Nr), Yt !== null && (Yt.f & wt) !== 0 && (Yt.f & (nf | rf)) === 0 && (kn === null ? see([e]) : kn.push(e)), !r.is_fork && Zy.size > 0 && !tP && eee();
  }
  return t;
}
function eee() {
  tP = !1;
  var e = ds;
  qd(!0);
  const t = Array.from(Zy);
  try {
    for (const n of t)
      (n.f & wt) !== 0 && jt(n, Jr), of(n) && tp(n);
  } finally {
    qd(e);
  }
  Zy.clear();
}
function rh(e) {
  $o(e, e.v + 1);
}
function nP(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, a = 0; a < r; a++) {
      var o = n[a], s = o.f, i = (s & Nr) === 0;
      if (i && jt(o, t), (s & un) !== 0) {
        var u = (
          /** @type {Derived} */
          o
        );
        Yn?.delete(u), (s & js) === 0 && (s & Wr && (o.f |= js), nP(u, Jr));
      } else i && ((s & Iu) !== 0 && pa !== null && pa.add(
        /** @type {Effect} */
        o
      ), Ll(
        /** @type {Effect} */
        o
      ));
    }
}
function yi(e) {
  if (typeof e != "object" || e === null || nh in e)
    return e;
  const t = RQ(e);
  if (t !== FQ && t !== UQ)
    return e;
  var n = /* @__PURE__ */ new Map(), r = AQ(e), a = /* @__PURE__ */ za(0), o = ps, s = (i) => {
    if (ps === o)
      return i();
    var u = ye, l = ps;
    Zi(null), $S(o);
    var c = i();
    return Zi(u), $S(l), c;
  };
  return r && n.set("length", /* @__PURE__ */ za(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(i, u, l) {
        (!("value" in l) || l.configurable === !1 || l.enumerable === !1 || l.writable === !1) && BQ();
        var c = n.get(u);
        return c === void 0 ? c = s(() => {
          var f = /* @__PURE__ */ za(l.value);
          return n.set(u, f), f;
        }) : $o(c, l.value, !0), !0;
      },
      deleteProperty(i, u) {
        var l = n.get(u);
        if (l === void 0) {
          if (u in i) {
            const c = s(() => /* @__PURE__ */ za(bt));
            n.set(u, c), rh(a);
          }
        } else
          $o(l, bt), rh(a);
        return !0;
      },
      get(i, u, l) {
        if (u === nh)
          return e;
        var c = n.get(u), f = u in i;
        if (c === void 0 && (!f || th(i, u)?.writable) && (c = s(() => {
          var m = yi(f ? i[u] : bt), p = /* @__PURE__ */ za(m);
          return p;
        }), n.set(u, c)), c !== void 0) {
          var d = dm(c);
          return d === bt ? void 0 : d;
        }
        return Reflect.get(i, u, l);
      },
      getOwnPropertyDescriptor(i, u) {
        var l = Reflect.getOwnPropertyDescriptor(i, u);
        if (l && "value" in l) {
          var c = n.get(u);
          c && (l.value = dm(c));
        } else if (l === void 0) {
          var f = n.get(u), d = f?.v;
          if (f !== void 0 && d !== bt)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return l;
      },
      has(i, u) {
        if (u === nh)
          return !0;
        var l = n.get(u), c = l !== void 0 && l.v !== bt || Reflect.has(i, u);
        if (l !== void 0 || Yt !== null && (!c || th(i, u)?.writable)) {
          l === void 0 && (l = s(() => {
            var d = c ? yi(i[u]) : bt, m = /* @__PURE__ */ za(d);
            return m;
          }), n.set(u, l));
          var f = dm(l);
          if (f === bt)
            return !1;
        }
        return c;
      },
      set(i, u, l, c) {
        var f = n.get(u), d = u in i;
        if (r && u === "length")
          for (var m = l; m < /** @type {Source<number>} */
          f.v; m += 1) {
            var p = n.get(m + "");
            p !== void 0 ? $o(p, bt) : m in i && (p = s(() => /* @__PURE__ */ za(bt)), n.set(m + "", p));
          }
        if (f === void 0)
          (!d || th(i, u)?.writable) && (f = s(() => /* @__PURE__ */ za(void 0)), $o(f, yi(l)), n.set(u, f));
        else {
          d = f.v !== bt;
          var b = s(() => yi(l));
          $o(f, b);
        }
        var g = Reflect.getOwnPropertyDescriptor(i, u);
        if (g?.set && g.set.call(c, l), !d) {
          if (r && typeof u == "string") {
            var S = (
              /** @type {Source<number>} */
              n.get("length")
            ), D = Number(u);
            Number.isInteger(D) && D >= S.v && $o(S, D + 1);
          }
          rh(a);
        }
        return !0;
      },
      ownKeys(i) {
        dm(a);
        var u = Reflect.ownKeys(i).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== bt;
        });
        for (var [l, c] of n)
          c.v !== bt && !(l in i) && u.push(l);
        return u;
      },
      setPrototypeOf() {
        GQ();
      }
    }
  );
}
var tee;
// @__NO_SIDE_EFFECTS__
function nee(e) {
  return (
    /** @type {TemplateNode | null} */
    tee.call(e)
  );
}
function rP(e) {
  var t = ye, n = Yt;
  Zi(null), Qd(null);
  try {
    return e();
  } finally {
    Zi(t), Qd(n);
  }
}
function zd() {
  return ye !== null && !zo;
}
function aP(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = af, r = ye;
    RS(!0), Zi(null);
    try {
      t.call(null);
    } finally {
      RS(n), Zi(r);
    }
  }
}
function oP(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const a = n.ac;
    a !== null && rP(() => {
      a.abort(J$);
    });
    var r = n.next;
    (n.f & rf) !== 0 ? n.parent = null : uv(n, t), n = r;
  }
}
function ree(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & nf) === 0 && uv(t), t = n;
  }
}
function uv(e, t = !0) {
  var n = !1;
  (t || (e.f & X$) !== 0) && e.nodes !== null && e.nodes.end !== null && (aee(
    e.nodes.start,
    /** @type {TemplateNode} */
    e.nodes.end
  ), n = !0), oP(e, t && !n), ep(e, 0), jt(e, ms);
  var r = e.nodes && e.nodes.t;
  if (r !== null)
    for (const o of r)
      o.stop();
  aP(e);
  var a = e.parent;
  a !== null && a.first !== null && sP(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes = e.ac = null;
}
function aee(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : /* @__PURE__ */ nee(e);
    e.remove(), e = n;
  }
}
function sP(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
let ds = !1;
function qd(e) {
  ds = e;
}
let af = !1;
function RS(e) {
  af = e;
}
let ye = null, zo = !1;
function Zi(e) {
  ye = e;
}
let Yt = null;
function Qd(e) {
  Yt = e;
}
let ja = null;
function oee(e) {
  ye !== null && (ja === null ? ja = [e] : ja.push(e));
}
let at = null, yn = 0, kn = null;
function see(e) {
  kn = e;
}
let iP = 1, Fl = 0, ps = Fl;
function $S(e) {
  ps = e;
}
function uP() {
  return ++iP;
}
function of(e) {
  var t = e.f;
  if ((t & Nr) !== 0)
    return !0;
  if (t & un && (e.f &= ~js), (t & Jr) !== 0) {
    var n = e.deps;
    if (n !== null)
      for (var r = n.length, a = 0; a < r; a++) {
        var o = n[a];
        if (of(
          /** @type {Derived} */
          o
        ) && eP(
          /** @type {Derived} */
          o
        ), o.wv > e.wv)
          return !0;
      }
    (t & Wr) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Yn === null && jt(e, wt);
  }
  return !1;
}
function lP(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !ja?.includes(e))
    for (var a = 0; a < r.length; a++) {
      var o = r[a];
      (o.f & un) !== 0 ? lP(
        /** @type {Derived} */
        o,
        t,
        !1
      ) : t === o && (n ? jt(o, Nr) : (o.f & wt) !== 0 && jt(o, Jr), Ll(
        /** @type {Effect} */
        o
      ));
    }
}
function cP(e) {
  var t = at, n = yn, r = kn, a = ye, o = ja, s = zo, i = ps, u = e.f;
  at = /** @type {null | Value[]} */
  null, yn = 0, kn = null, ye = (u & (nf | rf)) === 0 ? e : null, ja = null, e.ctx, zo = !1, ps = ++Fl, e.ac !== null && (rP(() => {
    e.ac.abort(J$);
  }), e.ac = null);
  try {
    e.f |= Wy;
    var l = (
      /** @type {Function} */
      e.fn
    ), c = l(), f = e.deps;
    if (at !== null) {
      var d;
      if (ep(e, yn), f !== null && yn > 0)
        for (f.length = yn + at.length, d = 0; d < at.length; d++)
          f[yn + d] = at[d];
      else
        e.deps = f = at;
      if (zd() && (e.f & Wr) !== 0)
        for (d = yn; d < f.length; d++)
          (f[d].reactions ??= []).push(e);
    } else f !== null && yn < f.length && (ep(e, yn), f.length = yn);
    if (Z$() && kn !== null && !zo && f !== null && (e.f & (un | Jr | Nr)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      kn.length; d++)
        lP(
          kn[d],
          /** @type {Effect} */
          e
        );
    return a !== null && a !== e && (Fl++, kn !== null && (r === null ? r = kn : r.push(.../** @type {Source[]} */
    kn))), (e.f & kl) !== 0 && (e.f ^= kl), c;
  } catch (m) {
    return JQ(m);
  } finally {
    e.f ^= Wy, at = t, yn = n, kn = r, ye = a, ja = o, zo = s, ps = i;
  }
}
function iee(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = LQ.call(n, e);
    if (r !== -1) {
      var a = n.length - 1;
      a === 0 ? n = t.reactions = null : (n[r] = n[a], n.pop());
    }
  }
  n === null && (t.f & un) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (at === null || !at.includes(t)) && (jt(t, Jr), (t.f & Wr) !== 0 && (t.f ^= Wr, t.f &= ~js), Q$(
    /** @type {Derived} **/
    t
  ), ep(
    /** @type {Derived} **/
    t,
    0
  ));
}
function ep(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      iee(e, n[r]);
}
function tp(e) {
  var t = e.f;
  if ((t & ms) === 0) {
    jt(e, wt);
    var n = Yt, r = ds;
    Yt = e, ds = !0;
    try {
      (t & (Iu | xQ)) !== 0 ? ree(e) : oP(e), aP(e);
      var a = cP(e);
      e.teardown = typeof a == "function" ? a : null, e.wv = iP;
      var o;
      kQ && KQ && (e.f & Nr) !== 0 && e.deps;
    } finally {
      ds = r, Yt = n;
    }
  }
}
function dm(e) {
  var t = e.f, n = (t & un) !== 0;
  if (ye !== null && !zo) {
    var r = Yt !== null && (Yt.f & ms) !== 0;
    if (!r && !ja?.includes(e)) {
      var a = ye.deps;
      if ((ye.f & Wy) !== 0)
        e.rv < Fl && (e.rv = Fl, at === null && a !== null && a[yn] === e ? yn++ : at === null ? at = [e] : at.includes(e) || at.push(e));
      else {
        (ye.deps ??= []).push(e);
        var o = e.reactions;
        o === null ? e.reactions = [ye] : o.includes(ye) || o.push(ye);
      }
    }
  }
  if (af) {
    if (lo.has(e))
      return lo.get(e);
    if (n) {
      var s = (
        /** @type {Derived} */
        e
      ), i = s.v;
      return ((s.f & wt) === 0 && s.reactions !== null || mP(s)) && (i = iv(s)), lo.set(s, i), i;
    }
  } else n && (!Yn?.has(e) || Je?.is_fork && !zd()) && (s = /** @type {Derived} */
  e, of(s) && eP(s), ds && zd() && (s.f & Wr) === 0 && fP(s));
  if (Yn?.has(e))
    return Yn.get(e);
  if ((e.f & kl) !== 0)
    throw e.v;
  return e.v;
}
function fP(e) {
  if (e.deps !== null) {
    e.f ^= Wr;
    for (const t of e.deps)
      (t.reactions ??= []).push(e), (t.f & un) !== 0 && (t.f & Wr) === 0 && fP(
        /** @type {Derived} */
        t
      );
  }
}
function mP(e) {
  if (e.v === bt) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (lo.has(t) || (t.f & un) !== 0 && mP(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
const uee = -7169;
function jt(e, t) {
  e.f = e.f & uee | t;
}
function dP() {
  return {
    isDark: document.documentElement.classList.contains("night-mode")
  };
}
const lee = yi(dP()), cee = new MutationObserver((e, t) => {
  lee.isDark = dP().isDark;
});
cee.observe(document.documentElement, { attributeFilter: ["class"] });
const fee = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(fee);
var j;
(function(e) {
  e[e.Canceled = 1] = "Canceled", e[e.Unknown = 2] = "Unknown", e[e.InvalidArgument = 3] = "InvalidArgument", e[e.DeadlineExceeded = 4] = "DeadlineExceeded", e[e.NotFound = 5] = "NotFound", e[e.AlreadyExists = 6] = "AlreadyExists", e[e.PermissionDenied = 7] = "PermissionDenied", e[e.ResourceExhausted = 8] = "ResourceExhausted", e[e.FailedPrecondition = 9] = "FailedPrecondition", e[e.Aborted = 10] = "Aborted", e[e.OutOfRange = 11] = "OutOfRange", e[e.Unimplemented = 12] = "Unimplemented", e[e.Internal = 13] = "Internal", e[e.Unavailable = 14] = "Unavailable", e[e.DataLoss = 15] = "DataLoss", e[e.Unauthenticated = 16] = "Unauthenticated";
})(j || (j = {}));
function lv(e, t) {
  return e !== null && typeof e == "object" && "$typeName" in e && typeof e.$typeName == "string" ? t === void 0 ? !0 : t.typeName === e.$typeName : !1;
}
var v;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(v || (v = {}));
function mee() {
  let e = 0, t = 0;
  for (let r = 0; r < 28; r += 7) {
    let a = this.buf[this.pos++];
    if (e |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  let n = this.buf[this.pos++];
  if (e |= (n & 15) << 28, t = (n & 112) >> 4, (n & 128) == 0)
    return this.assertBounds(), [e, t];
  for (let r = 3; r <= 31; r += 7) {
    let a = this.buf[this.pos++];
    if (t |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  throw new Error("invalid varint");
}
function ah(e, t, n) {
  for (let o = 0; o < 28; o = o + 7) {
    const s = e >>> o, i = !(!(s >>> 7) && t == 0), u = (i ? s | 128 : s) & 255;
    if (n.push(u), !i)
      return;
  }
  const r = e >>> 28 & 15 | (t & 7) << 4, a = t >> 3 != 0;
  if (n.push((a ? r | 128 : r) & 255), !!a) {
    for (let o = 3; o < 31; o = o + 7) {
      const s = t >>> o, i = !!(s >>> 7), u = (i ? s | 128 : s) & 255;
      if (n.push(u), !i)
        return;
    }
    n.push(t >>> 31 & 1);
  }
}
const td = 4294967296;
function PS(e) {
  const t = e[0] === "-";
  t && (e = e.slice(1));
  const n = 1e6;
  let r = 0, a = 0;
  function o(s, i) {
    const u = Number(e.slice(s, i));
    a *= n, r = r * n + u, r >= td && (a = a + (r / td | 0), r = r % td);
  }
  return o(-24, -18), o(-18, -12), o(-12, -6), o(-6), t ? bP(r, a) : cv(r, a);
}
function dee(e, t) {
  let n = cv(e, t);
  const r = n.hi & 2147483648;
  r && (n = bP(n.lo, n.hi));
  const a = pP(n.lo, n.hi);
  return r ? "-" + a : a;
}
function pP(e, t) {
  if ({ lo: e, hi: t } = pee(e, t), t <= 2097151)
    return String(td * t + e);
  const n = e & 16777215, r = (e >>> 24 | t << 8) & 16777215, a = t >> 16 & 65535;
  let o = n + r * 6777216 + a * 6710656, s = r + a * 8147497, i = a * 2;
  const u = 1e7;
  return o >= u && (s += Math.floor(o / u), o %= u), s >= u && (i += Math.floor(s / u), s %= u), i.toString() + VS(s) + VS(o);
}
function pee(e, t) {
  return { lo: e >>> 0, hi: t >>> 0 };
}
function cv(e, t) {
  return { lo: e | 0, hi: t | 0 };
}
function bP(e, t) {
  return t = ~t, e ? e = ~e + 1 : t += 1, cv(e, t);
}
const VS = (e) => {
  const t = String(e);
  return "0000000".slice(t.length) + t;
};
function Hy(e, t) {
  if (e >= 0) {
    for (; e > 127; )
      t.push(e & 127 | 128), e = e >>> 7;
    t.push(e);
  } else {
    for (let n = 0; n < 9; n++)
      t.push(e & 127 | 128), e = e >> 7;
    t.push(1);
  }
}
function bee() {
  let e = this.buf[this.pos++], t = e & 127;
  if ((e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 7, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 14, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 21, (e & 128) == 0)
    return this.assertBounds(), t;
  e = this.buf[this.pos++], t |= (e & 15) << 28;
  for (let n = 5; (e & 128) !== 0 && n < 10; n++)
    e = this.buf[this.pos++];
  if ((e & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
const H = /* @__PURE__ */ gee();
function gee() {
  const e = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof e.getBigInt64 == "function" && typeof e.getBigUint64 == "function" && typeof e.setBigInt64 == "function" && typeof e.setBigUint64 == "function" && (globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const t = BigInt("-9223372036854775808"), n = BigInt("9223372036854775807"), r = BigInt("0"), a = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > n || s < t)
          throw new Error(`invalid int64: ${o}`);
        return s;
      },
      uParse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > a || s < r)
          throw new Error(`invalid uint64: ${o}`);
        return s;
      },
      enc(o) {
        return e.setBigInt64(0, this.parse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      uEnc(o) {
        return e.setBigInt64(0, this.uParse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      dec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigInt64(0, !0);
      },
      uDec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigUint64(0, !0);
      }
    };
  }
  return {
    zero: "0",
    supported: !1,
    parse(t) {
      return typeof t != "string" && (t = t.toString()), xS(t), t;
    },
    uParse(t) {
      return typeof t != "string" && (t = t.toString()), YS(t), t;
    },
    enc(t) {
      return typeof t != "string" && (t = t.toString()), xS(t), PS(t);
    },
    uEnc(t) {
      return typeof t != "string" && (t = t.toString()), YS(t), PS(t);
    },
    dec(t, n) {
      return dee(t, n);
    },
    uDec(t, n) {
      return pP(t, n);
    }
  };
}
function xS(e) {
  if (!/^-?[0-9]+$/.test(e))
    throw new Error("invalid int64: " + e);
}
function YS(e) {
  if (!/^[0-9]+$/.test(e))
    throw new Error("invalid uint64: " + e);
}
function Bs(e, t) {
  switch (e) {
    case v.STRING:
      return "";
    case v.BOOL:
      return !1;
    case v.DOUBLE:
    case v.FLOAT:
      return 0;
    case v.INT64:
    case v.UINT64:
    case v.SFIXED64:
    case v.FIXED64:
    case v.SINT64:
      return t ? "0" : H.zero;
    case v.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function hee(e, t) {
  switch (e) {
    case v.BOOL:
      return t === !1;
    case v.STRING:
      return t === "";
    case v.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
const gP = 2, La = /* @__PURE__ */ Symbol.for("reflect unsafe local");
function hP(e, t) {
  const n = e[t.localName].case;
  return n === void 0 ? n : t.fields.find((r) => r.localName === n);
}
function yee(e, t) {
  const n = t.localName;
  if (t.oneof)
    return e[t.oneof.localName].case === n;
  if (t.presence != gP)
    return e[n] !== void 0 && Object.prototype.hasOwnProperty.call(e, n);
  switch (t.fieldKind) {
    case "list":
      return e[n].length > 0;
    case "map":
      return Object.keys(e[n]).length > 0;
    case "scalar":
      return !hee(t.scalar, e[n]);
    case "enum":
      return e[n] !== t.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function Ul(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) && e[t] !== void 0;
}
function yP(e, t) {
  if (t.oneof) {
    const n = e[t.oneof.localName];
    return n.case === t.localName ? n.value : void 0;
  }
  return e[t.localName];
}
function NP(e, t, n) {
  t.oneof ? e[t.oneof.localName] = {
    case: t.localName,
    value: n
  } : e[t.localName] = n;
}
function Nee(e, t) {
  const n = t.localName;
  if (t.oneof) {
    const r = t.oneof.localName;
    e[r].case === n && (e[r] = { case: void 0 });
  } else if (t.presence != gP)
    delete e[n];
  else
    switch (t.fieldKind) {
      case "map":
        e[n] = {};
        break;
      case "list":
        e[n] = [];
        break;
      case "enum":
        e[n] = t.enum.values[0].number;
        break;
      case "scalar":
        e[n] = Bs(t.scalar, t.longAsString);
        break;
    }
}
function To(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function fv(e, t) {
  var n, r, a, o;
  if (To(e) && La in e && "add" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.listKind == i.listKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function mv(e, t) {
  var n, r, a, o;
  if (To(e) && La in e && "has" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.mapKey === i.mapKey && s.mapKind == i.mapKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function dv(e, t) {
  return To(e) && La in e && "desc" in e && To(e.desc) && e.desc.kind === "message" && (t === void 0 || e.desc.typeName == t.typeName);
}
function Eee(e) {
  return EP(e.$typeName);
}
function sf(e) {
  const t = e.fields[0];
  return EP(e.typeName) && t !== void 0 && t.fieldKind == "scalar" && t.name == "value" && t.number == 1;
}
function EP(e) {
  return e.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(e.substring(16));
}
const vee = 999, Tee = 998, nd = 2;
function Er(e, t) {
  if (lv(t, e))
    return t;
  const n = See(e);
  return t !== void 0 && Iee(e, n, t), n;
}
function Iee(e, t, n) {
  for (const r of e.members) {
    let a = n[r.localName];
    if (a == null)
      continue;
    let o;
    if (r.kind == "oneof") {
      const s = hP(n, r);
      if (!s)
        continue;
      o = s, a = yP(n, s);
    } else
      o = r;
    switch (o.fieldKind) {
      case "message":
        a = pv(o, a);
        break;
      case "scalar":
        a = vP(o, a);
        break;
      case "list":
        a = _ee(o, a);
        break;
      case "map":
        a = wee(o, a);
        break;
    }
    NP(t, o, a);
  }
  return t;
}
function vP(e, t) {
  return e.scalar == v.BYTES ? bv(t) : t;
}
function wee(e, t) {
  if (To(t)) {
    if (e.scalar == v.BYTES)
      return jS(t, bv);
    if (e.mapKind == "message")
      return jS(t, (n) => pv(e, n));
  }
  return t;
}
function _ee(e, t) {
  if (Array.isArray(t)) {
    if (e.scalar == v.BYTES)
      return t.map(bv);
    if (e.listKind == "message")
      return t.map((n) => pv(e, n));
  }
  return t;
}
function pv(e, t) {
  if (e.fieldKind == "message" && !e.oneof && sf(e.message))
    return vP(e.message.fields[0], t);
  if (To(t)) {
    if (e.message.typeName == "google.protobuf.Struct" && e.parent.typeName !== "google.protobuf.Value")
      return t;
    if (!lv(t, e.message))
      return Er(e.message, t);
  }
  return t;
}
function bv(e) {
  return Array.isArray(e) ? new Uint8Array(e) : e;
}
function jS(e, t) {
  const n = {};
  for (const r of Object.entries(e))
    n[r[0]] = t(r[1]);
  return n;
}
const Oee = /* @__PURE__ */ Symbol(), BS = /* @__PURE__ */ new WeakMap();
function See(e) {
  let t;
  if (Dee(e)) {
    const n = BS.get(e);
    let r, a;
    if (n)
      ({ prototype: r, members: a } = n);
    else {
      r = {}, a = /* @__PURE__ */ new Set();
      for (const o of e.members)
        o.kind != "oneof" && (o.fieldKind != "scalar" && o.fieldKind != "enum" || o.presence != nd && (a.add(o), r[o.localName] = oh(o)));
      BS.set(e, { prototype: r, members: a });
    }
    t = Object.create(r), t.$typeName = e.typeName;
    for (const o of e.members)
      a.has(o) || o.kind == "field" && (o.fieldKind == "message" || (o.fieldKind == "scalar" || o.fieldKind == "enum") && o.presence != nd) || (t[o.localName] = oh(o));
  } else {
    t = {
      $typeName: e.typeName
    };
    for (const n of e.members)
      (n.kind == "oneof" || n.presence == nd) && (t[n.localName] = oh(n));
  }
  return t;
}
function Dee(e) {
  switch (e.file.edition) {
    case vee:
      return !1;
    case Tee:
      return !0;
    default:
      return e.fields.some((t) => t.presence != nd && t.fieldKind != "message" && !t.oneof);
  }
}
function oh(e) {
  if (e.kind == "oneof")
    return { case: void 0 };
  if (e.fieldKind == "list")
    return [];
  if (e.fieldKind == "map")
    return {};
  if (e.fieldKind == "message")
    return Oee;
  const t = e.getDefaultValue();
  return t !== void 0 ? e.fieldKind == "scalar" && e.longAsString ? t.toString() : t : e.fieldKind == "scalar" ? Bs(e.scalar, e.longAsString) : e.enum.values[0].number;
}
const kee = [
  "FieldValueInvalidError",
  "FieldListRangeError",
  "ForeignFieldError"
];
class Bt extends Error {
  constructor(t, n, r = "FieldValueInvalidError") {
    super(n), this.name = r, this.field = () => t;
  }
}
function Aee(e) {
  return e instanceof Error && kee.includes(e.name) && "field" in e && typeof e.field == "function";
}
const sh = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
function gv() {
  if (globalThis[sh] == null) {
    const e = new globalThis.TextEncoder(), t = new globalThis.TextDecoder();
    globalThis[sh] = {
      encodeUtf8(n) {
        return e.encode(n);
      },
      decodeUtf8(n) {
        return t.decode(n);
      },
      checkUtf8(n) {
        try {
          return encodeURIComponent(n), !0;
        } catch {
          return !1;
        }
      }
    };
  }
  return globalThis[sh];
}
var ue;
(function(e) {
  e[e.Varint = 0] = "Varint", e[e.Bit64 = 1] = "Bit64", e[e.LengthDelimited = 2] = "LengthDelimited", e[e.StartGroup = 3] = "StartGroup", e[e.EndGroup = 4] = "EndGroup", e[e.Bit32 = 5] = "Bit32";
})(ue || (ue = {}));
const TP = 34028234663852886e22, IP = -34028234663852886e22, wP = 4294967295, _P = 2147483647, OP = -2147483648;
class SP {
  constructor(t = gv().encodeUtf8) {
    this.encodeUtf8 = t, this.stack = [], this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []);
    let t = 0;
    for (let a = 0; a < this.chunks.length; a++)
      t += this.chunks[a].length;
    let n = new Uint8Array(t), r = 0;
    for (let a = 0; a < this.chunks.length; a++)
      n.set(this.chunks[a], r), r += this.chunks[a].length;
    return this.chunks = [], n;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), n = this.stack.pop();
    if (!n)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = n.chunks, this.buf = n.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, n) {
    return this.uint32((t << 3 | n) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (GS(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return ih(t), Hy(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let n = this.encodeUtf8(t);
    return this.uint32(n.byteLength), this.raw(n);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    Lee(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setFloat32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let n = new Uint8Array(8);
    return new DataView(n.buffer).setFloat64(0, t, !0), this.raw(n);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    GS(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    ih(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setInt32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return ih(t), t = (t << 1 ^ t >> 31) >>> 0, Hy(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = H.enc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = H.uEnc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let n = H.enc(t);
    return ah(n.lo, n.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    const n = H.enc(t), r = n.hi >> 31, a = n.lo << 1 ^ r, o = (n.hi << 1 | n.lo >>> 31) ^ r;
    return ah(a, o, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    const n = H.uEnc(t);
    return ah(n.lo, n.hi, this.buf), this;
  }
}
class hv {
  constructor(t, n = gv().decodeUtf8) {
    this.decodeUtf8 = n, this.varint64 = mee, this.uint32 = bee, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), n = t >>> 3, r = t & 7;
    if (n <= 0 || r < 0 || r > 5)
      throw new Error("illegal tag: field no " + n + " wire type " + r);
    return [n, r];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, n) {
    let r = this.pos;
    switch (t) {
      case ue.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case ue.Bit64:
        this.pos += 4;
      case ue.Bit32:
        this.pos += 4;
        break;
      case ue.LengthDelimited:
        let a = this.uint32();
        this.pos += a;
        break;
      case ue.StartGroup:
        for (; ; ) {
          const [o, s] = this.tag();
          if (s === ue.EndGroup) {
            if (n !== void 0 && o !== n)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(s, o);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return H.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return H.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, n] = this.varint64(), r = -(t & 1);
    return t = (t >>> 1 | (n & 1) << 31) ^ r, n = n >>> 1 ^ r, H.dec(t, n);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, n] = this.varint64();
    return t !== 0 || n !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return H.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return H.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), n = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(n, n + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function ih(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid int32: " + typeof e);
  if (!Number.isInteger(e) || e > _P || e < OP)
    throw new Error("invalid int32: " + e);
}
function GS(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid uint32: " + typeof e);
  if (!Number.isInteger(e) || e > wP || e < 0)
    throw new Error("invalid uint32: " + e);
}
function Lee(e) {
  if (typeof e == "string") {
    const t = e;
    if (e = Number(e), Number.isNaN(e) && t !== "NaN")
      throw new Error("invalid float32: " + t);
  } else if (typeof e != "number")
    throw new Error("invalid float32: " + typeof e);
  if (Number.isFinite(e) && (e > TP || e < IP))
    throw new Error("invalid float32: " + e);
}
function Po(e, t) {
  const n = e.fieldKind == "list" ? fv(t, e) : e.fieldKind == "map" ? mv(t, e) : yv(e, t);
  if (n === !0)
    return;
  let r;
  switch (e.fieldKind) {
    case "list":
      r = `expected ${AP(e)}, got ${xe(t)}`;
      break;
    case "map":
      r = `expected ${LP(e)}, got ${xe(t)}`;
      break;
    default:
      r = np(e, t, n);
  }
  return new Bt(e, r);
}
function MS(e, t, n) {
  const r = yv(e, n);
  if (r !== !0)
    return new Bt(e, `list item #${t + 1}: ${np(e, n, r)}`);
}
function Fee(e, t, n) {
  const r = DP(t, e.mapKey);
  if (r !== !0)
    return new Bt(e, `invalid map key: ${np({ scalar: e.mapKey }, t, r)}`);
  const a = yv(e, n);
  if (a !== !0)
    return new Bt(e, `map entry ${xe(t)}: ${np(e, n, a)}`);
}
function yv(e, t) {
  return e.scalar !== void 0 ? DP(t, e.scalar) : e.enum !== void 0 ? e.enum.open ? Number.isInteger(t) : e.enum.values.some((n) => n.number === t) : dv(t, e.message);
}
function DP(e, t) {
  switch (t) {
    case v.DOUBLE:
      return typeof e == "number";
    case v.FLOAT:
      return typeof e != "number" ? !1 : Number.isNaN(e) || !Number.isFinite(e) ? !0 : e > TP || e < IP ? `${e.toFixed()} out of range` : !0;
    case v.INT32:
    case v.SFIXED32:
    case v.SINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > _P || e < OP ? `${e.toFixed()} out of range` : !0;
    case v.FIXED32:
    case v.UINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > wP || e < 0 ? `${e.toFixed()} out of range` : !0;
    case v.BOOL:
      return typeof e == "boolean";
    case v.STRING:
      return typeof e != "string" ? !1 : gv().checkUtf8(e) || "invalid UTF8";
    case v.BYTES:
      return e instanceof Uint8Array;
    case v.INT64:
    case v.SFIXED64:
    case v.SINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return H.parse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
    case v.FIXED64:
    case v.UINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return H.uParse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
  }
}
function np(e, t, n) {
  return n = typeof n == "string" ? `: ${n}` : `, got ${xe(t)}`, e.scalar !== void 0 ? `expected ${Uee(e.scalar)}` + n : e.enum !== void 0 ? `expected ${e.enum.toString()}` + n : `expected ${kP(e.message)}` + n;
}
function xe(e) {
  switch (typeof e) {
    case "object":
      return e === null ? "null" : e instanceof Uint8Array ? `Uint8Array(${e.length})` : Array.isArray(e) ? `Array(${e.length})` : fv(e) ? AP(e.field()) : mv(e) ? LP(e.field()) : dv(e) ? kP(e.desc) : lv(e) ? `message ${e.$typeName}` : "object";
    case "string":
      return e.length > 30 ? "string" : `"${e.split('"').join('\\"')}"`;
    case "boolean":
      return String(e);
    case "number":
      return String(e);
    case "bigint":
      return String(e) + "n";
    default:
      return typeof e;
  }
}
function kP(e) {
  return `ReflectMessage (${e.typeName})`;
}
function AP(e) {
  switch (e.listKind) {
    case "message":
      return `ReflectList (${e.message.toString()})`;
    case "enum":
      return `ReflectList (${e.enum.toString()})`;
    case "scalar":
      return `ReflectList (${v[e.scalar]})`;
  }
}
function LP(e) {
  switch (e.mapKind) {
    case "message":
      return `ReflectMap (${v[e.mapKey]}, ${e.message.toString()})`;
    case "enum":
      return `ReflectMap (${v[e.mapKey]}, ${e.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${v[e.mapKey]}, ${v[e.scalar]})`;
  }
}
function Uee(e) {
  switch (e) {
    case v.STRING:
      return "string";
    case v.BOOL:
      return "boolean";
    case v.INT64:
    case v.SINT64:
    case v.SFIXED64:
      return "bigint (int64)";
    case v.UINT64:
    case v.FIXED64:
      return "bigint (uint64)";
    case v.BYTES:
      return "Uint8Array";
    case v.DOUBLE:
      return "number (float64)";
    case v.FLOAT:
      return "number (float32)";
    case v.FIXED32:
    case v.UINT32:
      return "number (uint32)";
    case v.INT32:
    case v.SFIXED32:
    case v.SINT32:
      return "number (int32)";
  }
}
function Hn(e, t, n = !0) {
  return new FP(e, t, n);
}
const CS = /* @__PURE__ */ new WeakMap();
class FP {
  get sortedFields() {
    const t = CS.get(this.desc);
    if (t)
      return t;
    const n = this.desc.fields.concat().sort((r, a) => r.number - a.number);
    return CS.set(this.desc, n), n;
  }
  constructor(t, n, r = !0) {
    this.lists = /* @__PURE__ */ new Map(), this.maps = /* @__PURE__ */ new Map(), this.check = r, this.desc = t, this.message = this[La] = n ?? Er(t), this.fields = t.fields, this.oneofs = t.oneofs, this.members = t.members;
  }
  findNumber(t) {
    return this._fieldsByNumber || (this._fieldsByNumber = new Map(this.desc.fields.map((n) => [n.number, n]))), this._fieldsByNumber.get(t);
  }
  oneofCase(t) {
    return Ru(this.message, t), hP(this.message, t);
  }
  isSet(t) {
    return Ru(this.message, t), yee(this.message, t);
  }
  clear(t) {
    Ru(this.message, t), Nee(this.message, t);
  }
  get(t) {
    Ru(this.message, t);
    const n = yP(this.message, t);
    switch (t.fieldKind) {
      case "list":
        let r = this.lists.get(t);
        return (!r || r[La] !== n) && this.lists.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          r = new Ree(t, n, this.check)
        ), r;
      case "map":
        let a = this.maps.get(t);
        return (!a || a[La] !== n) && this.maps.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = new $ee(t, n, this.check)
        ), a;
      case "message":
        return Ev(t, n, this.check);
      case "scalar":
        return n === void 0 ? Bs(t.scalar, !1) : vv(t, n);
      case "enum":
        return n ?? t.enum.values[0].number;
    }
  }
  set(t, n) {
    if (Ru(this.message, t), this.check) {
      const a = Po(t, n);
      if (a)
        throw a;
    }
    let r;
    t.fieldKind == "message" ? r = Nv(t, n) : mv(n) || fv(n) ? r = n[La] : r = Tv(t, n), NP(this.message, t, r);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(t) {
    this.message.$unknown = t;
  }
}
function Ru(e, t) {
  if (t.parent.typeName !== e.$typeName)
    throw new Bt(t, `cannot use ${t.toString()} with message ${e.$typeName}`, "ForeignFieldError");
}
class Ree {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(t, n, r) {
    this._field = t, this._arr = this[La] = n, this.check = r;
  }
  get(t) {
    const n = this._arr[t];
    return n === void 0 ? void 0 : uh(this._field, n, this.check);
  }
  set(t, n) {
    if (t < 0 || t >= this._arr.length)
      throw new Bt(this._field, `list item #${t + 1}: out of range`);
    if (this.check) {
      const r = MS(this._field, t, n);
      if (r)
        throw r;
    }
    this._arr[t] = KS(this._field, n);
  }
  add(t) {
    if (this.check) {
      const n = MS(this._field, this._arr.length, t);
      if (n)
        throw n;
    }
    this._arr.push(KS(this._field, t));
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const t of this._arr)
      yield uh(this._field, t, this.check);
  }
  *entries() {
    for (let t = 0; t < this._arr.length; t++)
      yield [t, uh(this._field, this._arr[t], this.check)];
  }
}
class $ee {
  constructor(t, n, r = !0) {
    this.obj = this[La] = n ?? {}, this.check = r, this._field = t;
  }
  field() {
    return this._field;
  }
  set(t, n) {
    if (this.check) {
      const r = Fee(this._field, t, n);
      if (r)
        throw r;
    }
    return this.obj[pm(t)] = Pee(this._field, n), this;
  }
  delete(t) {
    const n = pm(t), r = Object.prototype.hasOwnProperty.call(this.obj, n);
    return r && delete this.obj[n], r;
  }
  clear() {
    for (const t of Object.keys(this.obj))
      delete this.obj[t];
  }
  get(t) {
    let n = this.obj[pm(t)];
    return n !== void 0 && (n = lh(this._field, n, this.check)), n;
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.obj, pm(t));
  }
  *keys() {
    for (const t of Object.keys(this.obj))
      yield XS(t, this._field.mapKey);
  }
  *entries() {
    for (const t of Object.entries(this.obj))
      yield [
        XS(t[0], this._field.mapKey),
        lh(this._field, t[1], this.check)
      ];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const t of Object.values(this.obj))
      yield lh(this._field, t, this.check);
  }
  forEach(t, n) {
    for (const r of this.entries())
      t.call(n, r[1], r[0], this);
  }
}
function Nv(e, t) {
  return dv(t) ? Eee(t.message) && !e.oneof && e.fieldKind == "message" ? t.message.value : t.desc.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" ? RP(t.message) : t.message : t;
}
function Ev(e, t, n) {
  return t !== void 0 && (sf(e.message) && !e.oneof && e.fieldKind == "message" ? t = {
    $typeName: e.message.typeName,
    value: vv(e.message.fields[0], t)
  } : e.message.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" && To(t) && (t = UP(t))), new FP(e.message, t, n);
}
function KS(e, t) {
  return e.listKind == "message" ? Nv(e, t) : Tv(e, t);
}
function uh(e, t, n) {
  return e.listKind == "message" ? Ev(e, t, n) : vv(e, t);
}
function Pee(e, t) {
  return e.mapKind == "message" ? Nv(e, t) : Tv(e, t);
}
function lh(e, t, n) {
  return e.mapKind == "message" ? Ev(e, t, n) : t;
}
function pm(e) {
  return typeof e == "string" || typeof e == "number" ? e : String(e);
}
function XS(e, t) {
  switch (t) {
    case v.STRING:
      return e;
    case v.INT32:
    case v.FIXED32:
    case v.UINT32:
    case v.SFIXED32:
    case v.SINT32: {
      const n = Number.parseInt(e);
      if (Number.isFinite(n))
        return n;
      break;
    }
    case v.BOOL:
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      break;
    case v.UINT64:
    case v.FIXED64:
      try {
        return H.uParse(e);
      } catch {
      }
      break;
    default:
      try {
        return H.parse(e);
      } catch {
      }
      break;
  }
  return e;
}
function vv(e, t) {
  switch (e.scalar) {
    case v.INT64:
    case v.SFIXED64:
    case v.SINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = H.parse(t));
      break;
    case v.FIXED64:
    case v.UINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = H.uParse(t));
      break;
  }
  return t;
}
function Tv(e, t) {
  switch (e.scalar) {
    case v.INT64:
    case v.SFIXED64:
    case v.SINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = H.parse(t));
      break;
    case v.FIXED64:
    case v.UINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = H.uParse(t));
      break;
  }
  return t;
}
function UP(e) {
  const t = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (To(e))
    for (const [n, r] of Object.entries(e))
      t.fields[n] = PP(r);
  return t;
}
function RP(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = $P(r);
  return t;
}
function $P(e) {
  switch (e.kind.case) {
    case "structValue":
      return RP(e.kind.value);
    case "listValue":
      return e.kind.value.values.map($P);
    case "nullValue":
    case void 0:
      return null;
    default:
      return e.kind.value;
  }
}
function PP(e) {
  const t = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof e) {
    case "number":
      t.kind = { case: "numberValue", value: e };
      break;
    case "string":
      t.kind = { case: "stringValue", value: e };
      break;
    case "boolean":
      t.kind = { case: "boolValue", value: e };
      break;
    case "object":
      if (e === null)
        t.kind = { case: "nullValue", value: 0 };
      else if (Array.isArray(e)) {
        const n = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(e))
          for (const r of e)
            n.values.push(PP(r));
        t.kind = {
          case: "listValue",
          value: n
        };
      } else
        t.kind = {
          case: "structValue",
          value: UP(e)
        };
      break;
  }
  return t;
}
function Iv(e) {
  const t = Vee();
  let n = e.length * 3 / 4;
  e[e.length - 2] == "=" ? n -= 2 : e[e.length - 1] == "=" && (n -= 1);
  let r = new Uint8Array(n), a = 0, o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++) {
    if (s = t[e.charCodeAt(u)], s === void 0)
      switch (e[u]) {
        // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
        case "=":
          o = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string");
      }
    switch (o) {
      case 0:
        i = s, o = 1;
        break;
      case 1:
        r[a++] = i << 2 | (s & 48) >> 4, i = s, o = 2;
        break;
      case 2:
        r[a++] = (i & 15) << 4 | (s & 60) >> 2, i = s, o = 3;
        break;
      case 3:
        r[a++] = (i & 3) << 6 | s, o = 0;
        break;
    }
  }
  if (o == 1)
    throw Error("invalid base64 string");
  return r.subarray(0, a);
}
function VP(e, t = "std") {
  const n = xP(t), r = t == "std";
  let a = "", o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++)
    switch (s = e[u], o) {
      case 0:
        a += n[s >> 2], i = (s & 3) << 4, o = 1;
        break;
      case 1:
        a += n[i | s >> 4], i = (s & 15) << 2, o = 2;
        break;
      case 2:
        a += n[i | s >> 6], a += n[s & 63], o = 0;
        break;
    }
  return o && (a += n[i], r && (a += "=", o == 1 && (a += "="))), a;
}
let bm, WS, ai;
function xP(e) {
  return bm || (bm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), WS = bm.slice(0, -2).concat("-", "_")), e == "url" ? (
    // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
    WS
  ) : bm;
}
function Vee() {
  if (!ai) {
    ai = [];
    const e = xP("std");
    for (let t = 0; t < e.length; t++)
      ai[e[t].charCodeAt(0)] = t;
    ai[45] = e.indexOf("+"), ai[95] = e.indexOf("/");
  }
  return ai;
}
function Rl(e) {
  let t = !1;
  const n = [];
  for (let r = 0; r < e.length; r++) {
    let a = e.charAt(r);
    switch (a) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        n.push(a), t = !1;
        break;
      default:
        t && (t = !1, a = a.toUpperCase()), n.push(a);
        break;
    }
  }
  return n.join("");
}
const xee = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function $l(e) {
  return xee.has(e) ? e + "$" : e;
}
function wv(e) {
  for (const t of e.field)
    Ul(t, "jsonName") || (t.jsonName = Rl(t.name));
  e.nestedType.forEach(wv);
}
function Yee(e, t) {
  const n = e.values.find((r) => r.name === t);
  if (!n)
    throw new Error(`cannot parse ${e} default value: ${t}`);
  return n.number;
}
function jee(e, t) {
  switch (e) {
    case v.STRING:
      return t;
    case v.BYTES: {
      const n = Bee(t);
      if (n === !1)
        throw new Error(`cannot parse ${v[e]} default value: ${t}`);
      return n;
    }
    case v.INT64:
    case v.SFIXED64:
    case v.SINT64:
      return H.parse(t);
    case v.UINT64:
    case v.FIXED64:
      return H.uParse(t);
    case v.DOUBLE:
    case v.FLOAT:
      switch (t) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(t);
      }
    case v.BOOL:
      return t === "true";
    case v.INT32:
    case v.UINT32:
    case v.SINT32:
    case v.FIXED32:
    case v.SFIXED32:
      return parseInt(t, 10);
  }
}
function Bee(e) {
  const t = [], n = {
    tail: e,
    c: "",
    next() {
      return this.tail.length == 0 ? !1 : (this.c = this.tail[0], this.tail = this.tail.substring(1), !0);
    },
    take(r) {
      if (this.tail.length >= r) {
        const a = this.tail.substring(0, r);
        return this.tail = this.tail.substring(r), a;
      }
      return !1;
    }
  };
  for (; n.next(); )
    switch (n.c) {
      case "\\":
        if (n.next())
          switch (n.c) {
            case "\\":
              t.push(n.c.charCodeAt(0));
              break;
            case "b":
              t.push(8);
              break;
            case "f":
              t.push(12);
              break;
            case "n":
              t.push(10);
              break;
            case "r":
              t.push(13);
              break;
            case "t":
              t.push(9);
              break;
            case "v":
              t.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 8);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "x": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "u": {
              const r = n.c, a = n.take(4);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              const s = new Uint8Array(4);
              new DataView(s.buffer).setInt32(0, o, !0), t.push(s[0], s[1], s[2], s[3]);
              break;
            }
            case "U": {
              const r = n.c, a = n.take(8);
              if (a === !1)
                return !1;
              const o = H.uEnc(r + a), s = new Uint8Array(8), i = new DataView(s.buffer);
              i.setInt32(0, o.lo, !0), i.setInt32(4, o.hi, !0), t.push(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
              break;
            }
          }
        break;
      default:
        t.push(n.c.charCodeAt(0));
    }
  return new Uint8Array(t);
}
function* zy(e) {
  switch (e.kind) {
    case "file":
      for (const t of e.messages)
        yield t, yield* zy(t);
      yield* e.enums, yield* e.services, yield* e.extensions;
      break;
    case "message":
      for (const t of e.nestedMessages)
        yield t, yield* zy(t);
      yield* e.nestedEnums, yield* e.nestedExtensions;
      break;
  }
}
function YP(...e) {
  const t = Gee();
  if (!e.length)
    return t;
  if ("$typeName" in e[0] && e[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const n of e[0].file)
      qS(n, t);
    return t;
  }
  if ("$typeName" in e[0]) {
    let n = function(s) {
      const i = [];
      for (const u of s.dependency) {
        if (t.getFile(u) != null || o.has(u))
          continue;
        const l = a(u);
        if (!l)
          throw new Error(`Unable to resolve ${u}, imported by ${s.name}`);
        "kind" in l ? t.addFile(l, !1, !0) : (o.add(l.name), i.push(l));
      }
      return i.concat(...i.map(n));
    };
    const r = e[0], a = e[1], o = /* @__PURE__ */ new Set();
    for (const s of [r, ...n(r)].reverse())
      qS(s, t);
  } else
    for (const n of e)
      for (const r of n.files)
        t.addFile(r);
  return t;
}
function Gee() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    kind: "registry",
    types: e,
    extendees: t,
    [Symbol.iterator]() {
      return e.values();
    },
    get files() {
      return n.values();
    },
    addFile(r, a, o) {
      if (n.set(r.proto.name, r), !a)
        for (const s of zy(r))
          this.add(s);
      if (o)
        for (const s of r.dependencies)
          this.addFile(s, a, o);
    },
    add(r) {
      if (r.kind == "extension") {
        let a = t.get(r.extendee.typeName);
        a || t.set(
          r.extendee.typeName,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = /* @__PURE__ */ new Map()
        ), a.set(r.number, r);
      }
      e.set(r.typeName, r);
    },
    get(r) {
      return e.get(r);
    },
    getFile(r) {
      return n.get(r);
    },
    getMessage(r) {
      const a = e.get(r);
      return a?.kind == "message" ? a : void 0;
    },
    getEnum(r) {
      const a = e.get(r);
      return a?.kind == "enum" ? a : void 0;
    },
    getExtension(r) {
      const a = e.get(r);
      return a?.kind == "extension" ? a : void 0;
    },
    getExtensionFor(r, a) {
      var o;
      return (o = t.get(r.typeName)) === null || o === void 0 ? void 0 : o.get(a);
    },
    getService(r) {
      const a = e.get(r);
      return a?.kind == "service" ? a : void 0;
    }
  };
}
const Mee = 998, Cee = 999, Kee = 9, Pl = 10, Ku = 11, Xee = 12, JS = 14, _v = 3, Wee = 2, ZS = 1, Jee = 0, HS = 1, zS = 2, Zee = 3, Hee = 1, zee = 2, qee = 1, jP = {
  // EDITION_PROTO2
  998: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 2,
    // CLOSED,
    repeatedFieldEncoding: 2,
    // EXPANDED,
    utf8Validation: 3,
    // NONE,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 2,
    // LEGACY_BEST_EFFORT,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_PROTO3
  999: {
    fieldPresence: 2,
    // IMPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2023
  1e3: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2024
  1001: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 1,
    // STYLE2024,
    defaultSymbolVisibility: 2
    // EXPORT_TOP_LEVEL,
  }
};
function qS(e, t) {
  var n, r;
  const a = {
    kind: "file",
    proto: e,
    deprecated: (r = (n = e.options) === null || n === void 0 ? void 0 : n.deprecated) !== null && r !== void 0 ? r : !1,
    edition: nte(e),
    name: e.name.replace(/\.proto$/, ""),
    dependencies: rte(e, t),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${e.name}`;
    }
  }, o = /* @__PURE__ */ new Map(), s = {
    get(i) {
      return o.get(i);
    },
    add(i) {
      var u;
      sr(((u = i.proto.options) === null || u === void 0 ? void 0 : u.mapEntry) === !0), o.set(i.typeName, i);
    }
  };
  for (const i of e.enumType)
    BP(i, a, void 0, t);
  for (const i of e.messageType)
    GP(i, a, void 0, t, s);
  for (const i of e.service)
    Qee(i, a, t);
  qy(a, t);
  for (const i of o.values())
    Qy(i, t, s);
  for (const i of a.messages)
    Qy(i, t, s), qy(i, t);
  t.addFile(a, !0);
}
function qy(e, t) {
  switch (e.kind) {
    case "file":
      for (const n of e.proto.extension) {
        const r = eN(n, e, t);
        e.extensions.push(r), t.add(r);
      }
      break;
    case "message":
      for (const n of e.proto.extension) {
        const r = eN(n, e, t);
        e.nestedExtensions.push(r), t.add(r);
      }
      for (const n of e.nestedMessages)
        qy(n, t);
      break;
  }
}
function Qy(e, t, n) {
  const r = e.proto.oneofDecl.map((o) => tte(o, e)), a = /* @__PURE__ */ new Set();
  for (const o of e.proto.field) {
    const s = ste(o, r), i = eN(o, e, t, s, n);
    e.fields.push(i), e.field[i.localName] = i, s === void 0 ? e.members.push(i) : (s.fields.push(i), a.has(s) || (a.add(s), e.members.push(s)));
  }
  for (const o of r.filter((s) => a.has(s)))
    e.oneofs.push(o);
  for (const o of e.nestedMessages)
    Qy(o, t, n);
}
function BP(e, t, n, r) {
  var a, o, s, i, u;
  const l = ate(e.name, e.value), c = {
    kind: "enum",
    proto: e,
    deprecated: (o = (a = e.options) === null || a === void 0 ? void 0 : a.deprecated) !== null && o !== void 0 ? o : !1,
    file: t,
    parent: n,
    open: !0,
    name: e.name,
    typeName: Fb(e, n, t),
    value: {},
    values: [],
    sharedPrefix: l,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  c.open = cte(c), r.add(c);
  for (const f of e.value) {
    const d = f.name;
    c.values.push(
      // biome-ignore lint/suspicious/noAssignInExpressions: no
      c.value[f.number] = {
        kind: "enum_value",
        proto: f,
        deprecated: (i = (s = f.options) === null || s === void 0 ? void 0 : s.deprecated) !== null && i !== void 0 ? i : !1,
        parent: c,
        name: d,
        localName: $l(l == null ? d : d.substring(l.length)),
        number: f.number,
        toString() {
          return `enum value ${c.typeName}.${d}`;
        }
      }
    );
  }
  ((u = n?.nestedEnums) !== null && u !== void 0 ? u : t.enums).push(c);
}
function GP(e, t, n, r, a) {
  var o, s, i, u;
  const l = {
    kind: "message",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    file: t,
    parent: n,
    name: e.name,
    typeName: Fb(e, n, t),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  ((i = e.options) === null || i === void 0 ? void 0 : i.mapEntry) === !0 ? a.add(l) : (((u = n?.nestedMessages) !== null && u !== void 0 ? u : t.messages).push(l), r.add(l));
  for (const c of e.enumType)
    BP(c, t, l, r);
  for (const c of e.nestedType)
    GP(c, t, l, r, a);
}
function Qee(e, t, n) {
  var r, a;
  const o = {
    kind: "service",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    file: t,
    name: e.name,
    typeName: Fb(e, void 0, t),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  t.services.push(o), n.add(o);
  for (const s of e.method) {
    const i = ete(s, o, n);
    o.methods.push(i), o.method[i.localName] = i;
  }
}
function ete(e, t, n) {
  var r, a, o, s;
  let i;
  e.clientStreaming && e.serverStreaming ? i = "bidi_streaming" : e.clientStreaming ? i = "client_streaming" : e.serverStreaming ? i = "server_streaming" : i = "unary";
  const u = n.getMessage(ba(e.inputType)), l = n.getMessage(ba(e.outputType));
  sr(u, `invalid MethodDescriptorProto: input_type ${e.inputType} not found`), sr(l, `invalid MethodDescriptorProto: output_type ${e.inputType} not found`);
  const c = e.name;
  return {
    kind: "rpc",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    parent: t,
    name: c,
    localName: $l(c.length ? $l(c[0].toLowerCase() + c.substring(1)) : c),
    methodKind: i,
    input: u,
    output: l,
    idempotency: (s = (o = e.options) === null || o === void 0 ? void 0 : o.idempotencyLevel) !== null && s !== void 0 ? s : Jee,
    toString() {
      return `rpc ${t.typeName}.${c}`;
    }
  };
}
function tte(e, t) {
  return {
    kind: "oneof",
    proto: e,
    deprecated: !1,
    parent: t,
    fields: [],
    name: e.name,
    localName: $l(Rl(e.name)),
    toString() {
      return `oneof ${t.typeName}.${this.name}`;
    }
  };
}
function eN(e, t, n, r, a) {
  var o, s, i;
  const u = a === void 0, l = {
    kind: "field",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    name: e.name,
    number: e.number,
    scalar: void 0,
    message: void 0,
    enum: void 0,
    presence: ite(e, r, u, t),
    listKind: void 0,
    mapKind: void 0,
    mapKey: void 0,
    delimitedEncoding: void 0,
    packed: void 0,
    longAsString: !1,
    getDefaultValue: void 0
  };
  if (u) {
    const m = t.kind == "file" ? t : t.file, p = t.kind == "file" ? void 0 : t, b = Fb(e, p, m);
    l.kind = "extension", l.file = m, l.parent = p, l.oneof = void 0, l.typeName = b, l.jsonName = `[${b}]`, l.toString = () => `extension ${b}`;
    const g = n.getMessage(ba(e.extendee));
    sr(g, `invalid FieldDescriptorProto: extendee ${e.extendee} not found`), l.extendee = g;
  } else {
    const m = t;
    sr(m.kind == "message"), l.parent = m, l.oneof = r, l.localName = r ? Rl(e.name) : $l(Rl(e.name)), l.jsonName = e.jsonName, l.toString = () => `field ${m.typeName}.${e.name}`;
  }
  const c = e.label, f = e.type, d = (i = e.options) === null || i === void 0 ? void 0 : i.jstype;
  if (c === _v) {
    const m = f == Ku ? a?.get(ba(e.typeName)) : void 0;
    if (m) {
      l.fieldKind = "map";
      const { key: p, value: b } = lte(m);
      return l.mapKey = p.scalar, l.mapKind = b.fieldKind, l.message = b.message, l.delimitedEncoding = !1, l.enum = b.enum, l.scalar = b.scalar, l;
    }
    switch (l.fieldKind = "list", f) {
      case Ku:
      case Pl:
        l.listKind = "message", l.message = n.getMessage(ba(e.typeName)), sr(l.message), l.delimitedEncoding = QS(e, t);
        break;
      case JS:
        l.listKind = "enum", l.enum = n.getEnum(ba(e.typeName)), sr(l.enum);
        break;
      default:
        l.listKind = "scalar", l.scalar = f, l.longAsString = d == ZS;
        break;
    }
    return l.packed = ute(e, t), l;
  }
  switch (f) {
    case Ku:
    case Pl:
      l.fieldKind = "message", l.message = n.getMessage(ba(e.typeName)), sr(l.message, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.delimitedEncoding = QS(e, t), l.getDefaultValue = () => {
      };
      break;
    case JS: {
      const m = n.getEnum(ba(e.typeName));
      sr(m !== void 0, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.fieldKind = "enum", l.enum = n.getEnum(ba(e.typeName)), l.getDefaultValue = () => Ul(e, "defaultValue") ? Yee(m, e.defaultValue) : void 0;
      break;
    }
    default: {
      l.fieldKind = "scalar", l.scalar = f, l.longAsString = d == ZS, l.getDefaultValue = () => Ul(e, "defaultValue") ? jee(f, e.defaultValue) : void 0;
      break;
    }
  }
  return l;
}
function nte(e) {
  switch (e.syntax) {
    case "":
    case "proto2":
      return Mee;
    case "proto3":
      return Cee;
    case "editions":
      if (e.edition in jP)
        return e.edition;
      throw new Error(`${e.name}: unsupported edition`);
    default:
      throw new Error(`${e.name}: unsupported syntax "${e.syntax}"`);
  }
}
function rte(e, t) {
  return e.dependency.map((n) => {
    const r = t.getFile(n);
    if (!r)
      throw new Error(`Cannot find ${n}, imported by ${e.name}`);
    return r;
  });
}
function ate(e, t) {
  const n = ote(e) + "_";
  for (const r of t) {
    if (!r.name.toLowerCase().startsWith(n))
      return;
    const a = r.name.substring(n.length);
    if (a.length == 0 || /^\d/.test(a))
      return;
  }
  return n;
}
function ote(e) {
  return (e.substring(0, 1) + e.substring(1).replace(/[A-Z]/g, (t) => "_" + t)).toLowerCase();
}
function Fb(e, t, n) {
  let r;
  return t ? r = `${t.typeName}.${e.name}` : n.proto.package.length > 0 ? r = `${n.proto.package}.${e.name}` : r = `${e.name}`, r;
}
function ba(e) {
  return e.startsWith(".") ? e.substring(1) : e;
}
function ste(e, t) {
  if (!Ul(e, "oneofIndex") || e.proto3Optional)
    return;
  const n = t[e.oneofIndex];
  return sr(n, `invalid FieldDescriptorProto: oneof #${e.oneofIndex} for field #${e.number} not found`), n;
}
function ite(e, t, n, r) {
  if (e.label == Wee)
    return Zee;
  if (e.label == _v)
    return zS;
  if (t || e.proto3Optional || n)
    return HS;
  const a = Hi("fieldPresence", { proto: e, parent: r });
  return a == zS && (e.type == Ku || e.type == Pl) ? HS : a;
}
function ute(e, t) {
  if (e.label != _v)
    return !1;
  switch (e.type) {
    case Kee:
    case Xee:
    case Pl:
    case Ku:
      return !1;
  }
  const n = e.options;
  return n && Ul(n, "packed") ? n.packed : Hee == Hi("repeatedFieldEncoding", {
    proto: e,
    parent: t
  });
}
function lte(e) {
  const t = e.fields.find((r) => r.number === 1), n = e.fields.find((r) => r.number === 2);
  return sr(t && t.fieldKind == "scalar" && t.scalar != v.BYTES && t.scalar != v.FLOAT && t.scalar != v.DOUBLE && n && n.fieldKind != "list" && n.fieldKind != "map"), { key: t, value: n };
}
function cte(e) {
  var t;
  return qee == Hi("enumType", {
    proto: e.proto,
    parent: (t = e.parent) !== null && t !== void 0 ? t : e.file
  });
}
function QS(e, t) {
  return e.type == Pl ? !0 : zee == Hi("messageEncoding", {
    proto: e,
    parent: t
  });
}
function Hi(e, t) {
  var n, r;
  const a = (n = t.proto.options) === null || n === void 0 ? void 0 : n.features;
  if (a) {
    const o = a[e];
    if (o != 0)
      return o;
  }
  if ("kind" in t) {
    if (t.kind == "message")
      return Hi(e, (r = t.parent) !== null && r !== void 0 ? r : t.file);
    const o = jP[t.edition];
    if (!o)
      throw new Error(`feature default for edition ${t.edition} not found`);
    return o[e];
  }
  return Hi(e, t.parent);
}
function sr(e, t) {
  if (!e)
    throw new Error(t);
}
function fte(e) {
  const t = mte(e);
  return t.messageType.forEach(wv), YP(t, () => {
  }).getFile(t.name);
}
function mte(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    syntax: "",
    edition: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, e), { messageType: e.messageType.map(MP), enumType: e.enumType.map(CP) }));
}
function MP(e) {
  var t, n, r, a, o, s, i, u;
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.DescriptorProto",
    name: e.name,
    field: (n = (t = e.field) === null || t === void 0 ? void 0 : t.map(dte)) !== null && n !== void 0 ? n : [],
    extension: [],
    nestedType: (a = (r = e.nestedType) === null || r === void 0 ? void 0 : r.map(MP)) !== null && a !== void 0 ? a : [],
    enumType: (s = (o = e.enumType) === null || o === void 0 ? void 0 : o.map(CP)) !== null && s !== void 0 ? s : [],
    extensionRange: (u = (i = e.extensionRange) === null || i === void 0 ? void 0 : i.map((l) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, l))) !== null && u !== void 0 ? u : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function dte(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: !1
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, e), { options: e.options ? pte(e.options) : void 0 }));
}
function pte(e) {
  var t, n, r;
  return Object.assign(/* @__PURE__ */ Object.create({
    ctype: 0,
    packed: !1,
    jstype: 0,
    lazy: !1,
    unverifiedLazy: !1,
    deprecated: !1,
    weak: !1,
    debugRedact: !1,
    retention: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, e), { targets: (t = e.targets) !== null && t !== void 0 ? t : [], editionDefaults: (r = (n = e.editionDefaults) === null || n === void 0 ? void 0 : n.map((a) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, a))) !== null && r !== void 0 ? r : [], uninterpretedOption: [] }));
}
function CP(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: e.name,
    reservedName: [],
    reservedRange: [],
    value: e.value.map((t) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, t))
  });
}
function uf(e, t, ...n) {
  return n.reduce((r, a) => r.nestedMessages[a], e.messages[t]);
}
const bte = /* @__PURE__ */ fte({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: !0 } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false", options: { deprecated: !0 } }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1e3 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1e3, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: !0 } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1e3 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_UNSTABLE", number: 9999 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] }), gte = /* @__PURE__ */ uf(bte, 1);
var e2;
(function(e) {
  e[e.DECLARATION = 0] = "DECLARATION", e[e.UNVERIFIED = 1] = "UNVERIFIED";
})(e2 || (e2 = {}));
var t2;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.GROUP = 10] = "GROUP", e[e.MESSAGE = 11] = "MESSAGE", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.ENUM = 14] = "ENUM", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(t2 || (t2 = {}));
var n2;
(function(e) {
  e[e.OPTIONAL = 1] = "OPTIONAL", e[e.REPEATED = 3] = "REPEATED", e[e.REQUIRED = 2] = "REQUIRED";
})(n2 || (n2 = {}));
var r2;
(function(e) {
  e[e.SPEED = 1] = "SPEED", e[e.CODE_SIZE = 2] = "CODE_SIZE", e[e.LITE_RUNTIME = 3] = "LITE_RUNTIME";
})(r2 || (r2 = {}));
var a2;
(function(e) {
  e[e.STRING = 0] = "STRING", e[e.CORD = 1] = "CORD", e[e.STRING_PIECE = 2] = "STRING_PIECE";
})(a2 || (a2 = {}));
var o2;
(function(e) {
  e[e.JS_NORMAL = 0] = "JS_NORMAL", e[e.JS_STRING = 1] = "JS_STRING", e[e.JS_NUMBER = 2] = "JS_NUMBER";
})(o2 || (o2 = {}));
var s2;
(function(e) {
  e[e.RETENTION_UNKNOWN = 0] = "RETENTION_UNKNOWN", e[e.RETENTION_RUNTIME = 1] = "RETENTION_RUNTIME", e[e.RETENTION_SOURCE = 2] = "RETENTION_SOURCE";
})(s2 || (s2 = {}));
var i2;
(function(e) {
  e[e.TARGET_TYPE_UNKNOWN = 0] = "TARGET_TYPE_UNKNOWN", e[e.TARGET_TYPE_FILE = 1] = "TARGET_TYPE_FILE", e[e.TARGET_TYPE_EXTENSION_RANGE = 2] = "TARGET_TYPE_EXTENSION_RANGE", e[e.TARGET_TYPE_MESSAGE = 3] = "TARGET_TYPE_MESSAGE", e[e.TARGET_TYPE_FIELD = 4] = "TARGET_TYPE_FIELD", e[e.TARGET_TYPE_ONEOF = 5] = "TARGET_TYPE_ONEOF", e[e.TARGET_TYPE_ENUM = 6] = "TARGET_TYPE_ENUM", e[e.TARGET_TYPE_ENUM_ENTRY = 7] = "TARGET_TYPE_ENUM_ENTRY", e[e.TARGET_TYPE_SERVICE = 8] = "TARGET_TYPE_SERVICE", e[e.TARGET_TYPE_METHOD = 9] = "TARGET_TYPE_METHOD";
})(i2 || (i2 = {}));
var tN;
(function(e) {
  e[e.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e[e.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e[e.IDEMPOTENT = 2] = "IDEMPOTENT";
})(tN || (tN = {}));
var u2;
(function(e) {
  e[e.DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", e[e.EXPORT_ALL = 1] = "EXPORT_ALL", e[e.EXPORT_TOP_LEVEL = 2] = "EXPORT_TOP_LEVEL", e[e.LOCAL_ALL = 3] = "LOCAL_ALL", e[e.STRICT = 4] = "STRICT";
})(u2 || (u2 = {}));
var l2;
(function(e) {
  e[e.FIELD_PRESENCE_UNKNOWN = 0] = "FIELD_PRESENCE_UNKNOWN", e[e.EXPLICIT = 1] = "EXPLICIT", e[e.IMPLICIT = 2] = "IMPLICIT", e[e.LEGACY_REQUIRED = 3] = "LEGACY_REQUIRED";
})(l2 || (l2 = {}));
var c2;
(function(e) {
  e[e.ENUM_TYPE_UNKNOWN = 0] = "ENUM_TYPE_UNKNOWN", e[e.OPEN = 1] = "OPEN", e[e.CLOSED = 2] = "CLOSED";
})(c2 || (c2 = {}));
var f2;
(function(e) {
  e[e.REPEATED_FIELD_ENCODING_UNKNOWN = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN", e[e.PACKED = 1] = "PACKED", e[e.EXPANDED = 2] = "EXPANDED";
})(f2 || (f2 = {}));
var m2;
(function(e) {
  e[e.UTF8_VALIDATION_UNKNOWN = 0] = "UTF8_VALIDATION_UNKNOWN", e[e.VERIFY = 2] = "VERIFY", e[e.NONE = 3] = "NONE";
})(m2 || (m2 = {}));
var d2;
(function(e) {
  e[e.MESSAGE_ENCODING_UNKNOWN = 0] = "MESSAGE_ENCODING_UNKNOWN", e[e.LENGTH_PREFIXED = 1] = "LENGTH_PREFIXED", e[e.DELIMITED = 2] = "DELIMITED";
})(d2 || (d2 = {}));
var p2;
(function(e) {
  e[e.JSON_FORMAT_UNKNOWN = 0] = "JSON_FORMAT_UNKNOWN", e[e.ALLOW = 1] = "ALLOW", e[e.LEGACY_BEST_EFFORT = 2] = "LEGACY_BEST_EFFORT";
})(p2 || (p2 = {}));
var b2;
(function(e) {
  e[e.ENFORCE_NAMING_STYLE_UNKNOWN = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN", e[e.STYLE2024 = 1] = "STYLE2024", e[e.STYLE_LEGACY = 2] = "STYLE_LEGACY";
})(b2 || (b2 = {}));
var g2;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SET = 1] = "SET", e[e.ALIAS = 2] = "ALIAS";
})(g2 || (g2 = {}));
var h2;
(function(e) {
  e[e.EDITION_UNKNOWN = 0] = "EDITION_UNKNOWN", e[e.EDITION_LEGACY = 900] = "EDITION_LEGACY", e[e.EDITION_PROTO2 = 998] = "EDITION_PROTO2", e[e.EDITION_PROTO3 = 999] = "EDITION_PROTO3", e[e.EDITION_2023 = 1e3] = "EDITION_2023", e[e.EDITION_2024 = 1001] = "EDITION_2024", e[e.EDITION_UNSTABLE = 9999] = "EDITION_UNSTABLE", e[e.EDITION_1_TEST_ONLY = 1] = "EDITION_1_TEST_ONLY", e[e.EDITION_2_TEST_ONLY = 2] = "EDITION_2_TEST_ONLY", e[e.EDITION_99997_TEST_ONLY = 99997] = "EDITION_99997_TEST_ONLY", e[e.EDITION_99998_TEST_ONLY = 99998] = "EDITION_99998_TEST_ONLY", e[e.EDITION_99999_TEST_ONLY = 99999] = "EDITION_99999_TEST_ONLY", e[e.EDITION_MAX = 2147483647] = "EDITION_MAX";
})(h2 || (h2 = {}));
var y2;
(function(e) {
  e[e.VISIBILITY_UNSET = 0] = "VISIBILITY_UNSET", e[e.VISIBILITY_LOCAL = 1] = "VISIBILITY_LOCAL", e[e.VISIBILITY_EXPORT = 2] = "VISIBILITY_EXPORT";
})(y2 || (y2 = {}));
const N2 = {
  readUnknownFields: !0
};
function hte(e) {
  return e ? Object.assign(Object.assign({}, N2), e) : N2;
}
function Ub(e, t, n) {
  const r = Hn(e, void 0, !1);
  return KP(r, new hv(t), hte(n), !1, t.byteLength), r.message;
}
function KP(e, t, n, r, a) {
  var o;
  const s = r ? t.len : t.pos + a;
  let i, u;
  const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
  for (; t.pos < s && ([i, u] = t.tag(), !(r && u == ue.EndGroup)); ) {
    const c = e.findNumber(i);
    if (!c) {
      const f = t.skip(u, i);
      n.readUnknownFields && l.push({ no: i, wireType: u, data: f });
      continue;
    }
    XP(e, t, c, u, n);
  }
  if (r && (u != ue.EndGroup || i !== a))
    throw new Error("invalid end group tag");
  l.length > 0 && e.setUnknown(l);
}
function XP(e, t, n, r, a) {
  var o;
  switch (n.fieldKind) {
    case "scalar":
      e.set(n, zi(t, n.scalar));
      break;
    case "enum":
      const s = zi(t, v.INT32);
      if (n.enum.open)
        e.set(n, s);
      else if (n.enum.values.some((i) => i.number === s))
        e.set(n, s);
      else if (a.readUnknownFields) {
        const i = [];
        Hy(s, i);
        const u = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
        u.push({
          no: n.number,
          wireType: r,
          data: new Uint8Array(i)
        }), e.setUnknown(u);
      }
      break;
    case "message":
      e.set(n, Ov(t, a, n, e.get(n)));
      break;
    case "list":
      Nte(t, r, e.get(n), a);
      break;
    case "map":
      yte(t, e.get(n), a);
      break;
  }
}
function yte(e, t, n) {
  const r = t.field();
  let a, o;
  const s = e.uint32(), i = e.pos + s;
  for (; e.pos < i; ) {
    const [u] = e.tag();
    switch (u) {
      case 1:
        a = zi(e, r.mapKey);
        break;
      case 2:
        switch (r.mapKind) {
          case "scalar":
            o = zi(e, r.scalar);
            break;
          case "enum":
            o = e.int32();
            break;
          case "message":
            o = Ov(e, n, r);
            break;
        }
        break;
    }
  }
  if (a === void 0 && (a = Bs(r.mapKey, !1)), o === void 0)
    switch (r.mapKind) {
      case "scalar":
        o = Bs(r.scalar, !1);
        break;
      case "enum":
        o = r.enum.values[0].number;
        break;
      case "message":
        o = Hn(r.message, void 0, !1);
        break;
    }
  t.set(a, o);
}
function Nte(e, t, n, r) {
  var a;
  const o = n.field();
  if (o.listKind === "message") {
    n.add(Ov(e, r, o));
    return;
  }
  const s = (a = o.scalar) !== null && a !== void 0 ? a : v.INT32;
  if (!(t == ue.LengthDelimited && s != v.STRING && s != v.BYTES)) {
    n.add(zi(e, s));
    return;
  }
  const i = e.uint32() + e.pos;
  for (; e.pos < i; )
    n.add(zi(e, s));
}
function Ov(e, t, n, r) {
  const a = n.delimitedEncoding, o = r ?? Hn(n.message, void 0, !1);
  return KP(o, e, t, a, a ? n.number : e.uint32()), o;
}
function zi(e, t) {
  switch (t) {
    case v.STRING:
      return e.string();
    case v.BOOL:
      return e.bool();
    case v.DOUBLE:
      return e.double();
    case v.FLOAT:
      return e.float();
    case v.INT32:
      return e.int32();
    case v.INT64:
      return e.int64();
    case v.UINT64:
      return e.uint64();
    case v.FIXED64:
      return e.fixed64();
    case v.BYTES:
      return e.bytes();
    case v.FIXED32:
      return e.fixed32();
    case v.SFIXED32:
      return e.sfixed32();
    case v.SFIXED64:
      return e.sfixed64();
    case v.SINT64:
      return e.sint64();
    case v.UINT32:
      return e.uint32();
    case v.SINT32:
      return e.sint32();
  }
}
function WP(e, t) {
  var n;
  const r = Ub(gte, Iv(e));
  return r.messageType.forEach(wv), r.dependency = (n = void 0) !== null && n !== void 0 ? n : [], YP(r, (a) => {
  }).getFile(r.name);
}
const Ete = /* @__PURE__ */ WP("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), vte = /* @__PURE__ */ uf(Ete, 0), Tte = 3, E2 = {
  writeUnknownFields: !0
};
function Ite(e) {
  return e ? Object.assign(Object.assign({}, E2), e) : E2;
}
function JP(e, t, n) {
  return rp(new SP(), Ite(n), Hn(e, t)).finish();
}
function rp(e, t, n) {
  var r;
  for (const a of n.sortedFields) {
    if (!n.isSet(a)) {
      if (a.presence == Tte)
        throw new Error(`cannot encode ${a} to binary: required field not set`);
      continue;
    }
    ZP(e, t, n, a);
  }
  if (t.writeUnknownFields)
    for (const { no: a, wireType: o, data: s } of (r = n.getUnknown()) !== null && r !== void 0 ? r : [])
      e.tag(a, o).raw(s);
  return e;
}
function ZP(e, t, n, r) {
  var a;
  switch (r.fieldKind) {
    case "scalar":
    case "enum":
      ap(e, n.desc.typeName, r.name, (a = r.scalar) !== null && a !== void 0 ? a : v.INT32, r.number, n.get(r));
      break;
    case "list":
      wte(e, t, r, n.get(r));
      break;
    case "message":
      HP(e, t, r, n.get(r));
      break;
    case "map":
      for (const [o, s] of n.get(r))
        _te(e, t, r, o, s);
      break;
  }
}
function ap(e, t, n, r, a, o) {
  zP(e.tag(a, Ote(r)), t, n, r, o);
}
function HP(e, t, n, r) {
  n.delimitedEncoding ? rp(e.tag(n.number, ue.StartGroup), t, r).tag(n.number, ue.EndGroup) : rp(e.tag(n.number, ue.LengthDelimited).fork(), t, r).join();
}
function wte(e, t, n, r) {
  var a;
  if (n.listKind == "message") {
    for (const s of r)
      HP(e, t, n, s);
    return;
  }
  const o = (a = n.scalar) !== null && a !== void 0 ? a : v.INT32;
  if (n.packed) {
    if (!r.size)
      return;
    e.tag(n.number, ue.LengthDelimited).fork();
    for (const s of r)
      zP(e, n.parent.typeName, n.name, o, s);
    e.join();
    return;
  }
  for (const s of r)
    ap(e, n.parent.typeName, n.name, o, n.number, s);
}
function _te(e, t, n, r, a) {
  var o;
  switch (e.tag(n.number, ue.LengthDelimited).fork(), ap(e, n.parent.typeName, n.name, n.mapKey, 1, r), n.mapKind) {
    case "scalar":
    case "enum":
      ap(e, n.parent.typeName, n.name, (o = n.scalar) !== null && o !== void 0 ? o : v.INT32, 2, a);
      break;
    case "message":
      rp(e.tag(2, ue.LengthDelimited).fork(), t, a).join();
      break;
  }
  e.join();
}
function zP(e, t, n, r, a) {
  try {
    switch (r) {
      case v.STRING:
        e.string(a);
        break;
      case v.BOOL:
        e.bool(a);
        break;
      case v.DOUBLE:
        e.double(a);
        break;
      case v.FLOAT:
        e.float(a);
        break;
      case v.INT32:
        e.int32(a);
        break;
      case v.INT64:
        e.int64(a);
        break;
      case v.UINT64:
        e.uint64(a);
        break;
      case v.FIXED64:
        e.fixed64(a);
        break;
      case v.BYTES:
        e.bytes(a);
        break;
      case v.FIXED32:
        e.fixed32(a);
        break;
      case v.SFIXED32:
        e.sfixed32(a);
        break;
      case v.SFIXED64:
        e.sfixed64(a);
        break;
      case v.SINT64:
        e.sint64(a);
        break;
      case v.UINT32:
        e.uint32(a);
        break;
      case v.SINT32:
        e.sint32(a);
        break;
    }
  } catch (o) {
    throw o instanceof Error ? new Error(`cannot encode field ${t}.${n} to binary: ${o.message}`) : o;
  }
}
function Ote(e) {
  switch (e) {
    case v.BYTES:
    case v.STRING:
      return ue.LengthDelimited;
    case v.DOUBLE:
    case v.FIXED64:
    case v.SFIXED64:
      return ue.Bit64;
    case v.FIXED32:
    case v.SFIXED32:
    case v.FLOAT:
      return ue.Bit32;
    default:
      return ue.Varint;
  }
}
function Ste(e, t, n) {
  let r = !1;
  return n || (n = Er(vte), r = !0), n.value = JP(e, t), n.typeUrl = Ate(t.$typeName), r ? n : void 0;
}
function Dte(e, t) {
  if (e.typeUrl === "")
    return !1;
  const n = typeof t == "string" ? t : t.typeName, r = qP(e.typeUrl);
  return n === r;
}
function kte(e, t) {
  if (e.typeUrl === "")
    return;
  const n = t.kind == "message" ? t : t.getMessage(qP(e.typeUrl));
  if (!(!n || !Dte(e, n)))
    return Ub(n, e.value);
}
function Ate(e) {
  return `type.googleapis.com/${e}`;
}
function qP(e) {
  const t = e.lastIndexOf("/"), n = t >= 0 ? e.substring(t + 1) : e;
  if (!n.length)
    throw new Error(`invalid type url: ${e}`);
  return n;
}
const Sv = /* @__PURE__ */ WP("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), Lte = /* @__PURE__ */ uf(Sv, 0), QP = /* @__PURE__ */ uf(Sv, 1), Fte = /* @__PURE__ */ uf(Sv, 2);
var nN;
(function(e) {
  e[e.NULL_VALUE = 0] = "NULL_VALUE";
})(nN || (nN = {}));
function Ute(e, t) {
  e6(t, e);
  const n = $te(e.$unknown, t), [r, a, o] = Rb(t);
  for (const s of n)
    XP(r, new hv(s.data), a, s.wireType, {
      readUnknownFields: !0
    });
  return o();
}
function Rte(e, t, n) {
  var r;
  e6(t, e);
  const a = ((r = e.$unknown) !== null && r !== void 0 ? r : []).filter((l) => l.no !== t.number), [o, s] = Rb(t, n), i = new SP();
  ZP(i, { writeUnknownFields: !0 }, o, s);
  const u = new hv(i.finish());
  for (; u.pos < u.len; ) {
    const [l, c] = u.tag(), f = u.skip(c, l);
    a.push({ no: l, wireType: c, data: f });
  }
  e.$unknown = a;
}
function $te(e, t) {
  if (e === void 0)
    return [];
  if (t.fieldKind === "enum" || t.fieldKind === "scalar") {
    for (let n = e.length - 1; n >= 0; --n)
      if (e[n].no == t.number)
        return [e[n]];
    return [];
  }
  return e.filter((n) => n.no === t.number);
}
function Rb(e, t) {
  const n = e.typeName, r = Object.assign(Object.assign({}, e), { kind: "field", parent: e.extendee, localName: n }), a = Object.assign(Object.assign({}, e.extendee), { fields: [r], members: [r], oneofs: [] }), o = Er(a, t !== void 0 ? { [n]: t } : void 0);
  return [
    Hn(a, o),
    r,
    () => {
      const s = o[n];
      if (s === void 0) {
        const i = e.message;
        return sf(i) ? Bs(i.fields[0].scalar, i.fields[0].longAsString) : Er(i);
      }
      return s;
    }
  ];
}
function e6(e, t) {
  if (e.extendee.typeName != t.$typeName)
    throw new Error(`extension ${e.typeName} can only be applied to message ${e.extendee.typeName}`);
}
const Pte = 3, Vte = 2, v2 = {
  alwaysEmitImplicit: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1
};
function xte(e) {
  return e ? Object.assign(Object.assign({}, v2), e) : v2;
}
function Yte(e, t, n) {
  return lf(Hn(e, t), xte(n));
}
function jte(e, t, n) {
  var r;
  const a = Yte(e, t, n);
  return JSON.stringify(a, null, (r = n?.prettySpaces) !== null && r !== void 0 ? r : 0);
}
function lf(e, t) {
  var n;
  const r = Cte(e, t);
  if (r !== void 0)
    return r;
  const a = {};
  for (const o of e.sortedFields) {
    if (!e.isSet(o)) {
      if (o.presence == Pte)
        throw new Error(`cannot encode ${o} to JSON: required field not set`);
      if (!t.alwaysEmitImplicit || o.presence !== Vte)
        continue;
    }
    const s = T2(o, e.get(o), t);
    s !== void 0 && (a[Mte(o, t)] = s);
  }
  if (t.registry) {
    const o = /* @__PURE__ */ new Set();
    for (const { no: s } of (n = e.getUnknown()) !== null && n !== void 0 ? n : [])
      if (!o.has(s)) {
        o.add(s);
        const i = t.registry.getExtensionFor(e.desc, s);
        if (!i)
          continue;
        const u = Ute(e.message, i), [l, c] = Rb(i, u), f = T2(c, l.get(c), t);
        f !== void 0 && (a[i.jsonName] = f);
      }
  }
  return a;
}
function T2(e, t, n) {
  switch (e.fieldKind) {
    case "scalar":
      return $b(e, t);
    case "message":
      return lf(t, n);
    case "enum":
      return Dv(e.enum, t, n.enumAsInteger);
    case "list":
      return Gte(t, n);
    case "map":
      return Bte(t, n);
  }
}
function Bte(e, t) {
  const n = e.field(), r = {};
  switch (n.mapKind) {
    case "scalar":
      for (const [a, o] of e)
        r[a] = $b(n, o);
      break;
    case "message":
      for (const [a, o] of e)
        r[a] = lf(o, t);
      break;
    case "enum":
      for (const [a, o] of e)
        r[a] = Dv(n.enum, o, t.enumAsInteger);
      break;
  }
  return t.alwaysEmitImplicit || e.size > 0 ? r : void 0;
}
function Gte(e, t) {
  const n = e.field(), r = [];
  switch (n.listKind) {
    case "scalar":
      for (const a of e)
        r.push($b(n, a));
      break;
    case "enum":
      for (const a of e)
        r.push(Dv(n.enum, a, t.enumAsInteger));
      break;
    case "message":
      for (const a of e)
        r.push(lf(a, t));
      break;
  }
  return t.alwaysEmitImplicit || r.length > 0 ? r : void 0;
}
function Dv(e, t, n) {
  var r;
  if (typeof t != "number")
    throw new Error(`cannot encode ${e} to JSON: expected number, got ${xe(t)}`);
  return e.typeName == "google.protobuf.NullValue" ? null : n ? t : (r = e.value[t]?.name) !== null && r !== void 0 ? r : t;
}
function $b(e, t) {
  var n, r, a, o, s, i;
  switch (e.scalar) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case v.INT32:
    case v.SFIXED32:
    case v.SINT32:
    case v.FIXED32:
    case v.UINT32:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(n = Po(e, t)) === null || n === void 0 ? void 0 : n.message}`);
      return t;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case v.FLOAT:
    case v.DOUBLE:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(r = Po(e, t)) === null || r === void 0 ? void 0 : r.message}`);
      return Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    // string:
    case v.STRING:
      if (typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(a = Po(e, t)) === null || a === void 0 ? void 0 : a.message}`);
      return t;
    // bool:
    case v.BOOL:
      if (typeof t != "boolean")
        throw new Error(`cannot encode ${e} to JSON: ${(o = Po(e, t)) === null || o === void 0 ? void 0 : o.message}`);
      return t;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case v.UINT64:
    case v.FIXED64:
    case v.INT64:
    case v.SFIXED64:
    case v.SINT64:
      if (typeof t != "bigint" && typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(s = Po(e, t)) === null || s === void 0 ? void 0 : s.message}`);
      return t.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case v.BYTES:
      if (t instanceof Uint8Array)
        return VP(t);
      throw new Error(`cannot encode ${e} to JSON: ${(i = Po(e, t)) === null || i === void 0 ? void 0 : i.message}`);
  }
}
function Mte(e, t) {
  return t.useProtoFieldName ? e.name : e.jsonName;
}
function Cte(e, t) {
  if (e.desc.typeName.startsWith("google.protobuf."))
    switch (e.desc.typeName) {
      case "google.protobuf.Any":
        return Kte(e.message, t);
      case "google.protobuf.Timestamp":
        return Jte(e.message);
      case "google.protobuf.Duration":
        return Xte(e.message);
      case "google.protobuf.FieldMask":
        return Wte(e.message);
      case "google.protobuf.Struct":
        return t6(e.message);
      case "google.protobuf.Value":
        return kv(e.message);
      case "google.protobuf.ListValue":
        return n6(e.message);
      default:
        if (sf(e.desc)) {
          const n = e.desc.fields[0];
          return $b(n, e.get(n));
        }
        return;
    }
}
function Kte(e, t) {
  if (e.typeUrl === "")
    return {};
  const { registry: n } = t;
  let r, a;
  if (n && (r = kte(e, n), r && (a = n.getMessage(r.$typeName))), !a || !r)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: "${e.typeUrl}" is not in the type registry`);
  let o = lf(Hn(a, r), t);
  return (a.typeName.startsWith("google.protobuf.") || o === null || Array.isArray(o) || typeof o != "object") && (o = { value: o }), o["@type"] = e.typeUrl, o;
}
function Xte(e) {
  const t = Number(e.seconds), n = e.nanos;
  if (t > 315576e6 || t < -315576e6)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: value out of range`);
  if (t > 0 && n < 0 || t < 0 && n > 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos sign must match seconds sign`);
  let r = e.seconds.toString();
  if (n !== 0) {
    let a = Math.abs(n).toString();
    a = "0".repeat(9 - a.length) + a, a.substring(3) === "000000" ? a = a.substring(0, 3) : a.substring(6) === "000" && (a = a.substring(0, 6)), r += "." + a, n < 0 && t == 0 && (r = "-" + r);
  }
  return r + "s";
}
function Wte(e) {
  return e.paths.map((t) => {
    if (t.match(/_[0-9]?_/g) || t.match(/[A-Z]/g))
      throw new Error(`cannot encode message ${e.$typeName} to JSON: lowerCamelCase of path name "` + t + '" is irreversible');
    return Rl(t);
  }).join(",");
}
function t6(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = kv(r);
  return t;
}
function kv(e) {
  switch (e.kind.case) {
    case "nullValue":
      return null;
    case "numberValue":
      if (!Number.isFinite(e.kind.value))
        throw new Error(`${e.$typeName} cannot be NaN or Infinity`);
      return e.kind.value;
    case "boolValue":
      return e.kind.value;
    case "stringValue":
      return e.kind.value;
    case "structValue":
      return t6(e.kind.value);
    case "listValue":
      return n6(e.kind.value);
    default:
      throw new Error(`${e.$typeName} must have a value`);
  }
}
function n6(e) {
  return e.values.map(kv);
}
function Jte(e) {
  const t = Number(e.seconds) * 1e3;
  if (t < Date.parse("0001-01-01T00:00:00Z") || t > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot encode message ${e.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  if (e.nanos < 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be negative`);
  if (e.nanos > 999999999)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be greater than 99999999`);
  let n = "Z";
  if (e.nanos > 0) {
    const r = (e.nanos + 1e9).toString().substring(1);
    r.substring(3) === "000000" ? n = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? n = "." + r.substring(0, 6) + "Z" : n = "." + r + "Z";
  }
  return new Date(t).toISOString().replace(".000Z", n);
}
const I2 = {
  ignoreUnknownFields: !1
};
function Zte(e) {
  return e ? Object.assign(Object.assign({}, I2), e) : I2;
}
function Hte(e, t, n) {
  return r6(e, rne(t, e.typeName), n);
}
function r6(e, t, n) {
  const r = Hn(e);
  try {
    qi(r, t, Zte(n));
  } catch (a) {
    throw Aee(a) ? new Error(`cannot decode ${a.field()} from JSON: ${a.message}`, {
      cause: a
    }) : a;
  }
  return r.message;
}
function qi(e, t, n) {
  var r;
  if (ane(e, t, n))
    return;
  if (t == null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode ${e.desc} from JSON: ${xe(t)}`);
  const a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const s of e.desc.fields)
    o.set(s.name, s).set(s.jsonName, s);
  for (const [s, i] of Object.entries(t)) {
    const u = o.get(s);
    if (u) {
      if (u.oneof) {
        if (i === null && u.fieldKind == "scalar")
          continue;
        const l = a.get(u.oneof);
        if (l !== void 0)
          throw new Bt(u.oneof, `oneof set multiple times by ${l.name} and ${u.name}`);
        a.set(u.oneof, u);
      }
      w2(e, u, i, n);
    } else {
      let l;
      if (s.startsWith("[") && s.endsWith("]") && // biome-ignore lint/suspicious/noAssignInExpressions: no
      (l = (r = n.registry) === null || r === void 0 ? void 0 : r.getExtension(s.substring(1, s.length - 1))) && l.extendee.typeName === e.desc.typeName) {
        const [c, f, d] = Rb(l);
        w2(c, f, i, n), Rte(e.message, l, d());
      }
      if (!l && !n.ignoreUnknownFields)
        throw new Error(`cannot decode ${e.desc} from JSON: key "${s}" is unknown`);
    }
  }
}
function w2(e, t, n, r) {
  switch (t.fieldKind) {
    case "scalar":
      tne(e, t, n);
      break;
    case "enum":
      ene(e, t, n, r);
      break;
    case "message":
      Qte(e, t, n, r);
      break;
    case "list":
      qte(e.get(t), n, r);
      break;
    case "map":
      zte(e.get(t), n, r);
      break;
  }
}
function zte(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (typeof t != "object" || Array.isArray(t))
    throw new Bt(r, "expected object, got " + xe(t));
  for (const [a, o] of Object.entries(t)) {
    if (o === null && !a6(r))
      throw new Bt(r, "map value must not be null");
    let s;
    switch (r.mapKind) {
      case "message":
        const u = Hn(r.message);
        qi(u, o, n), s = u;
        break;
      case "enum":
        if (s = Av(r.enum, o, n.ignoreUnknownFields, !0), s === Pb)
          return;
        break;
      case "scalar":
        s = xb(r, o, !0);
        break;
    }
    const i = nne(r.mapKey, a);
    e.set(i, s);
  }
}
function qte(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (!Array.isArray(t))
    throw new Bt(r, "expected Array, got " + xe(t));
  for (const a of t) {
    if (a === null && !a6(r))
      throw new Bt(r, "list item must not be null");
    switch (r.listKind) {
      case "message":
        const o = Hn(r.message);
        qi(o, a, n), e.add(o);
        break;
      case "enum":
        const s = Av(r.enum, a, n.ignoreUnknownFields, !0);
        s !== Pb && e.add(s);
        break;
      case "scalar":
        e.add(xb(r, a, !0));
        break;
    }
  }
}
function a6(e) {
  var t, n;
  return ((t = e.message) === null || t === void 0 ? void 0 : t.typeName) == "google.protobuf.Value" || ((n = e.enum) === null || n === void 0 ? void 0 : n.typeName) == "google.protobuf.NullValue";
}
function Qte(e, t, n, r) {
  if (n === null && t.message.typeName != "google.protobuf.Value") {
    e.clear(t);
    return;
  }
  const a = e.isSet(t) ? e.get(t) : Hn(t.message);
  qi(a, n, r), e.set(t, a);
}
function ene(e, t, n, r) {
  const a = Av(t.enum, n, r.ignoreUnknownFields, !1);
  a === Vb ? e.clear(t) : a !== Pb && e.set(t, a);
}
function tne(e, t, n) {
  const r = xb(t, n, !1);
  r === Vb ? e.clear(t) : e.set(t, r);
}
const Pb = /* @__PURE__ */ Symbol();
function Av(e, t, n, r) {
  if (t === null)
    return e.typeName == "google.protobuf.NullValue" ? 0 : r ? e.values[0].number : Vb;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const a = e.values.find((o) => o.name === t);
      if (a !== void 0)
        return a.number;
      if (n)
        return Pb;
      break;
  }
  throw new Error(`cannot decode ${e} from JSON: ${xe(t)}`);
}
const Vb = /* @__PURE__ */ Symbol();
function xb(e, t, n) {
  if (t === null)
    return n ? Bs(e.scalar, !1) : Vb;
  switch (e.scalar) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case v.DOUBLE:
    case v.FLOAT:
      if (t === "NaN")
        return NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (typeof t == "number") {
        if (Number.isNaN(t))
          throw new Bt(e, "unexpected NaN number");
        if (!Number.isFinite(t))
          throw new Bt(e, "unexpected infinite number");
        break;
      }
      if (typeof t == "string") {
        if (t === "" || t.trim().length !== t.length)
          break;
        const r = Number(t);
        if (!Number.isFinite(r))
          break;
        return r;
      }
      break;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case v.INT32:
    case v.FIXED32:
    case v.SFIXED32:
    case v.SINT32:
    case v.UINT32:
      return o6(t);
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case v.BYTES:
      if (typeof t == "string") {
        if (t === "")
          return new Uint8Array(0);
        try {
          return Iv(t);
        } catch (r) {
          const a = r instanceof Error ? r.message : String(r);
          throw new Bt(e, a);
        }
      }
      break;
  }
  return t;
}
function nne(e, t) {
  switch (e) {
    case v.BOOL:
      switch (t) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      return t;
    case v.INT32:
    case v.FIXED32:
    case v.UINT32:
    case v.SFIXED32:
    case v.SINT32:
      return o6(t);
    default:
      return t;
  }
}
function o6(e) {
  if (typeof e == "string") {
    if (e === "" || e.trim().length !== e.length)
      return e;
    const t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
function rne(e, t) {
  try {
    return JSON.parse(e);
  } catch (n) {
    const r = n instanceof Error ? n.message : String(n);
    throw new Error(
      `cannot decode message ${t} from JSON: ${r}`,
      // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
      { cause: n }
    );
  }
}
function ane(e, t, n) {
  if (!e.desc.typeName.startsWith("google.protobuf."))
    return !1;
  switch (e.desc.typeName) {
    case "google.protobuf.Any":
      return one(e.message, t, n), !0;
    case "google.protobuf.Timestamp":
      return sne(e.message, t), !0;
    case "google.protobuf.Duration":
      return ine(e.message, t), !0;
    case "google.protobuf.FieldMask":
      return une(e.message, t), !0;
    case "google.protobuf.Struct":
      return s6(e.message, t), !0;
    case "google.protobuf.Value":
      return Lv(e.message, t), !0;
    case "google.protobuf.ListValue":
      return i6(e.message, t), !0;
    default:
      if (sf(e.desc)) {
        const r = e.desc.fields[0];
        return t === null ? e.clear(r) : e.set(r, xb(r, t, !0)), !0;
      }
      return !1;
  }
}
function one(e, t, n) {
  var r;
  if (t === null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: expected object but got ${xe(t)}`);
  if (Object.keys(t).length == 0)
    return;
  const a = t["@type"];
  if (typeof a != "string" || a == "")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is empty`);
  const o = a.includes("/") ? a.substring(a.lastIndexOf("/") + 1) : a;
  if (!o.length)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is invalid`);
  const s = (r = n.registry) === null || r === void 0 ? void 0 : r.getMessage(o);
  if (!s)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${a} is not in the type registry`);
  const i = Hn(s);
  if (o.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(t, "value")) {
    const u = t.value;
    qi(i, u, n);
  } else {
    const u = Object.assign({}, t);
    delete u["@type"], qi(i, u, n);
  }
  Ste(i.desc, i.message, e);
}
function sne(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${xe(t)}`);
  const n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
  if (!n)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  const r = Date.parse(
    // biome-ignore format: want this to read well
    n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z")
  );
  if (Number.isNaN(r))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  e.seconds = H.parse(r / 1e3), e.nanos = 0, n[7] && (e.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9);
}
function ine(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${xe(t)}`);
  const n = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
  if (n === null)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${xe(t)}`);
  const r = Number(n[1]);
  if (r > 315576e6 || r < -315576e6)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${xe(t)}`);
  if (e.seconds = H.parse(r), typeof n[2] != "string")
    return;
  const a = n[2] + "0".repeat(9 - n[2].length);
  e.nanos = parseInt(a), (r < 0 || Object.is(r, -0)) && (e.nanos = -e.nanos);
}
function une(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${xe(t)}`);
  if (t === "")
    return;
  function n(r) {
    if (r.includes("_"))
      throw new Error(`cannot decode message ${e.$typeName} from JSON: path names must be lowerCamelCase`);
    const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase());
    return a[0] === "_" ? a.substring(1) : a;
  }
  e.paths = t.split(",").map(n);
}
function s6(e, t) {
  if (typeof t != "object" || t == null || Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${xe(t)}`);
  for (const [n, r] of Object.entries(t)) {
    const a = Er(QP);
    Lv(a, r), e.fields[n] = a;
  }
}
function Lv(e, t) {
  switch (typeof t) {
    case "number":
      e.kind = { case: "numberValue", value: t };
      break;
    case "string":
      e.kind = { case: "stringValue", value: t };
      break;
    case "boolean":
      e.kind = { case: "boolValue", value: t };
      break;
    case "object":
      if (t === null)
        e.kind = { case: "nullValue", value: nN.NULL_VALUE };
      else if (Array.isArray(t)) {
        const n = Er(Fte);
        i6(n, t), e.kind = { case: "listValue", value: n };
      } else {
        const n = Er(Lte);
        s6(n, t), e.kind = { case: "structValue", value: n };
      }
      break;
    default:
      throw new Error(`cannot decode message ${e.$typeName} from JSON ${xe(t)}`);
  }
  return e;
}
function i6(e, t) {
  if (!Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${xe(t)}`);
  for (const n of t) {
    const r = Er(QP);
    Lv(r, n), e.values.push(r);
  }
}
function rN(e) {
  const t = j[e];
  return typeof t != "string" ? e.toString() : t[0].toLowerCase() + t.substring(1).replace(/[A-Z]/g, (n) => "_" + n.toLowerCase());
}
let gm;
function lne(e) {
  if (!gm) {
    gm = {};
    for (const t of Object.values(j))
      typeof t != "string" && (gm[rN(t)] = t);
  }
  return gm[e];
}
class De extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(t, n = j.Unknown, r, a, o) {
    super(cne(t, n)), this.name = "ConnectError", Object.setPrototypeOf(this, new.target.prototype), this.rawMessage = t, this.code = n, this.metadata = new Headers(r ?? {}), this.details = a ?? [], this.cause = o;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(t, n = j.Unknown) {
    return t instanceof De ? t : t instanceof Error ? t.name == "AbortError" || t.name == "TimeoutError" ? new De(t.message, j.Canceled) : new De(t.message, n, void 0, void 0, t) : new De(String(t), n, void 0, void 0, t);
  }
  static [Symbol.hasInstance](t) {
    return t instanceof Error ? Object.getPrototypeOf(t) === De.prototype ? !0 : t.name === "ConnectError" && "code" in t && typeof t.code == "number" && "metadata" in t && "details" in t && Array.isArray(t.details) && "rawMessage" in t && typeof t.rawMessage == "string" && "cause" in t : !1;
  }
  findDetails(t) {
    const n = t.kind === "message" ? {
      getMessage: (a) => a === t.typeName ? t : void 0
    } : t, r = [];
    for (const a of this.details) {
      if ("desc" in a) {
        n.getMessage(a.desc.typeName) && r.push(Er(a.desc, a.value));
        continue;
      }
      const o = n.getMessage(a.type);
      if (o)
        try {
          r.push(Ub(o, a.value));
        } catch {
        }
    }
    return r;
  }
}
function cne(e, t) {
  return e.length ? `[${rN(t)}] ${e}` : `[${rN(t)}]`;
}
function fne(...e) {
  const t = new Headers();
  for (const n of e)
    n.forEach((r, a) => {
      t.append(a, r);
    });
  return t;
}
const _2 = 1;
function mne(e, t, n = !1) {
  if (t > e) {
    let r = `message size is larger than configured readMaxBytes ${e}`;
    throw n && (r = `message size ${t} is larger than configured readMaxBytes ${e}`), new De(r, j.ResourceExhausted);
  }
}
function dne(e) {
  return new pne(e);
}
class pne {
  constructor(t) {
    this.readMaxBytes = t, this.header = new Uint8Array(5), this.headerView = new DataView(this.header.buffer), this.buf = [];
  }
  get byteLength() {
    return this.buf.reduce((t, n) => t + n.byteLength, 0);
  }
  decode(t) {
    this.buf.push(t);
    const n = [];
    for (; ; ) {
      let r = this.pop();
      if (!r)
        break;
      n.push(r);
    }
    return n;
  }
  // consume an enveloped message
  pop() {
    if (!(!this.env && (this.env = this.head(), !this.env)) && this.cons(this.env.data)) {
      const t = this.env;
      return this.env = void 0, t;
    }
  }
  // consume header
  head() {
    if (!this.cons(this.header))
      return;
    const t = this.headerView.getUint8(0), n = this.headerView.getUint32(1);
    return mne(this.readMaxBytes, n, !0), {
      flags: t,
      data: new Uint8Array(n)
    };
  }
  // consume from buffer, fill target
  cons(t) {
    const n = t.byteLength;
    if (this.byteLength < n)
      return !1;
    let r = 0;
    for (; r < n; ) {
      const a = this.buf.shift();
      a.byteLength > n - r ? (t.set(a.subarray(0, n - r), r), this.buf.unshift(a.subarray(n - r)), r += n - r) : (t.set(a, r), r += a.byteLength);
    }
    return !0;
  }
}
function bne(e) {
  let t;
  const n = dne(4294967295);
  return new ReadableStream({
    start() {
      t = e.getReader();
    },
    async pull(r) {
      let a = !1;
      for (; !a; ) {
        const o = await t.read();
        if (o.done)
          n.byteLength > 0 && r.error(new De("protocol error: incomplete envelope", j.InvalidArgument)), r.close();
        else
          for (const s of n.decode(o.value))
            r.enqueue(s), a = !0;
      }
    }
  });
}
function gne(e, t) {
  const n = new Uint8Array(t.length + 5);
  n.set(t, 5);
  const r = new DataView(n.buffer, n.byteOffset, n.byteLength);
  return r.setUint8(0, e), r.setUint32(1, t.length), n;
}
function hne(...e) {
  const t = new AbortController(), n = e.filter((a) => a !== void 0).concat(t.signal);
  for (const a of n) {
    if (a.aborted) {
      r.apply(a);
      break;
    }
    a.addEventListener("abort", r);
  }
  function r() {
    t.signal.aborted || t.abort(u6(this));
    for (const a of n)
      a.removeEventListener("abort", r);
  }
  return t;
}
function yne(e) {
  const t = new AbortController(), n = () => {
    t.abort(new De("the operation timed out", j.DeadlineExceeded));
  };
  let r;
  return e !== void 0 && (e <= 0 ? n() : r = setTimeout(n, e)), {
    signal: t.signal,
    cleanup: () => clearTimeout(r)
  };
}
function u6(e) {
  if (!e.aborted)
    return;
  if (e.reason !== void 0)
    return e.reason;
  const t = new Error("This operation was aborted");
  return t.name = "AbortError", t;
}
function O2() {
  return {
    get(e) {
      return e.id in this ? this[e.id] : e.defaultValue;
    },
    set(e, t) {
      return this[e.id] = t, this;
    },
    delete(e) {
      return delete this[e.id], this;
    }
  };
}
function S2(e, t) {
  return e.toString().replace(/\/?$/, `/${t.parent.typeName}/${t.name}`);
}
function l6(e, t) {
  return Er(e, t);
}
function Nne(e, t) {
  function n(r) {
    return r.done === !0 ? r : {
      done: r.done,
      value: l6(e, r.value)
    };
  }
  return {
    [Symbol.asyncIterator]() {
      const r = t[Symbol.asyncIterator](), a = {
        next: () => r.next().then(n)
      };
      return r.throw !== void 0 && (a.throw = (o) => r.throw(o).then(n)), r.return !== void 0 && (a.return = (o) => r.return(o).then(n)), a;
    }
  };
}
function c6(e, t) {
  if (!t)
    return e;
  for (const n of t.concat().reverse())
    e = n(e);
  return e;
}
function f6(e) {
  var t;
  const n = Object.assign({}, e);
  return (t = n.ignoreUnknownFields) !== null && t !== void 0 || (n.ignoreUnknownFields = !0), n;
}
function D2(e, t, n, r) {
  const a = t ? k2(e.input, r) : A2(e.input, n);
  return { parse: (t ? k2(e.output, r) : A2(e.output, n)).parse, serialize: a.serialize };
}
function k2(e, t) {
  return {
    parse(n) {
      try {
        return Ub(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new De(`parse binary: ${a}`, j.Internal);
      }
    },
    serialize(n) {
      try {
        return JP(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new De(`serialize binary: ${a}`, j.Internal);
      }
    }
  };
}
function A2(e, t) {
  var n, r;
  const a = (n = t?.textEncoder) !== null && n !== void 0 ? n : new TextEncoder(), o = (r = t?.textDecoder) !== null && r !== void 0 ? r : new TextDecoder(), s = f6(t);
  return {
    parse(i) {
      try {
        const u = o.decode(i);
        return Hte(e, u, s);
      } catch (u) {
        throw De.from(u, j.InvalidArgument);
      }
    },
    serialize(i) {
      try {
        const u = jte(e, i, s);
        return a.encode(u);
      } catch (u) {
        throw De.from(u, j.Internal);
      }
    }
  };
}
const Ene = /^application\/(connect\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i, vne = "application/proto", Tne = "application/json", Ine = "application/connect+proto", wne = "application/connect+json";
function _ne(e) {
  const t = e?.match(Ene);
  if (!t)
    return;
  const n = !!t[1], r = !!t[3];
  return { stream: n, binary: r };
}
function m6(e, t, n) {
  var r;
  if (t && new Headers(t).forEach((i, u) => n.metadata.append(u, i)), typeof e != "object" || e == null || Array.isArray(e))
    throw n;
  let a = n.code;
  "code" in e && typeof e.code == "string" && (a = (r = lne(e.code)) !== null && r !== void 0 ? r : a);
  const o = e.message;
  if (o != null && typeof o != "string")
    throw n;
  const s = new De(o ?? "", a, t);
  if ("details" in e && Array.isArray(e.details))
    for (const i of e.details) {
      if (i === null || typeof i != "object" || Array.isArray(i) || typeof i.type != "string" || typeof i.value != "string")
        throw n;
      try {
        s.details.push({
          type: i.type,
          value: Iv(i.value),
          debug: i.debug
        });
      } catch {
        throw n;
      }
    }
  return s;
}
const L2 = 2;
function One(e) {
  const t = new De("invalid end stream", j.Unknown);
  let n;
  try {
    n = JSON.parse(typeof e == "string" ? e : new TextDecoder().decode(e));
  } catch {
    throw t;
  }
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw t;
  const r = new Headers();
  if ("metadata" in n) {
    if (typeof n.metadata != "object" || n.metadata == null || Array.isArray(n.metadata))
      throw t;
    for (const [o, s] of Object.entries(n.metadata)) {
      if (!Array.isArray(s) || s.some((i) => typeof i != "string"))
        throw t;
      for (const i of s)
        r.append(o, i);
    }
  }
  const a = "error" in n && n.error != null ? m6(n.error, r, t) : void 0;
  return { metadata: r, error: a };
}
const op = "Content-Type", Sne = "Content-Length", F2 = "Content-Encoding", Dne = "Accept-Encoding", kne = "Connect-Timeout-Ms", d6 = "Connect-Protocol-Version", Ane = "User-Agent";
function Lne(e) {
  switch (e) {
    case 400:
      return j.Internal;
    case 401:
      return j.Unauthenticated;
    case 403:
      return j.PermissionDenied;
    case 404:
      return j.Unimplemented;
    case 429:
      return j.Unavailable;
    case 502:
      return j.Unavailable;
    case 503:
      return j.Unavailable;
    case 504:
      return j.Unavailable;
    default:
      return j.Unknown;
  }
}
function U2(e) {
  const t = new Headers(), n = new Headers();
  return e.forEach((r, a) => {
    a.toLowerCase().startsWith("trailer-") ? n.append(a.substring(8), r) : t.append(a, r);
  }), [t, n];
}
const p6 = "1";
function R2(e, t, n, r, a) {
  const o = new Headers(r ?? {});
  return n !== void 0 && o.set(kne, `${n}`), o.set(op, e == "unary" ? t ? vne : Tne : t ? Ine : wne), o.set(d6, p6), o.has(Ane), o;
}
function $2(e, t, n, r) {
  const a = r.get(op), o = _ne(a);
  if (n !== 200) {
    const i = new De(`HTTP ${n}`, Lne(n), r);
    if (e == "unary" && o && !o.binary)
      return { isUnaryError: !0, unaryError: i };
    throw i;
  }
  const s = {
    binary: t,
    stream: e !== "unary"
  };
  if (o?.binary !== s.binary || o.stream !== s.stream)
    throw new De(`unsupported content type ${a}`, o === void 0 ? j.Unknown : j.Internal, r);
  return { isUnaryError: !1 };
}
const P2 = "application/";
function Fne(e, t) {
  return t ? VP(e, "url") : encodeURIComponent(new TextDecoder().decode(e));
}
function Une(e, t, n) {
  let r = `?connect=v${p6}`;
  const a = e.header.get(op);
  a?.indexOf(P2) === 0 && (r += "&encoding=" + encodeURIComponent(a.slice(P2.length)));
  const o = e.header.get(F2);
  o !== null && o !== "identity" && (r += "&compression=" + encodeURIComponent(o), n = !0), n && (r += "&base64=1"), r += "&message=" + Fne(t, n);
  const s = e.url + r, i = new Headers(e.header);
  for (const u of [
    d6,
    op,
    Sne,
    F2,
    Dne
  ])
    i.delete(u);
  return Object.assign(Object.assign({}, e), {
    requestMethod: "GET",
    url: s,
    header: i
  });
}
function Rne(e) {
  const t = c6(e.next, e.interceptors), [n, r, a] = b6(e), o = Object.assign(Object.assign({}, e.req), { message: l6(e.req.method.input, e.req.message), signal: n });
  return t(o).then((s) => (a(), s), r);
}
function $ne(e) {
  const t = c6(e.next, e.interceptors), [n, r, a] = b6(e), o = Object.assign(Object.assign({}, e.req), { message: Nne(e.req.method.input, e.req.message), signal: n });
  let s = !1;
  return n.addEventListener("abort", function() {
    var i, u;
    const l = e.req.message[Symbol.asyncIterator]();
    s || (i = l.throw) === null || i === void 0 || i.call(l, this.reason).catch(() => {
    }), (u = l.return) === null || u === void 0 || u.call(l).catch(() => {
    });
  }), t(o).then((i) => Object.assign(Object.assign({}, i), { message: {
    [Symbol.asyncIterator]() {
      const u = i.message[Symbol.asyncIterator]();
      return {
        next() {
          return u.next().then((l) => (l.done == !0 && (s = !0, a()), l), r);
        }
        // We deliberately omit throw/return.
      };
    }
  } }), r);
}
function b6(e) {
  const { signal: t, cleanup: n } = yne(e.timeoutMs), r = hne(e.signal, t);
  return [
    r.signal,
    function(a) {
      const o = De.from(t.aborted ? u6(t) : a);
      return r.abort(o), n(), Promise.reject(o);
    },
    function() {
      n(), r.abort();
    }
  ];
}
function Pne() {
  try {
    new Headers();
  } catch {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}
var Vl = function(e) {
  return this instanceof Vl ? (this.v = e, this) : new Vl(e);
}, Vne = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof Vl ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
const V2 = {
  redirect: "error"
};
function xne(e) {
  var t;
  Pne();
  const n = (t = e.useBinaryFormat) !== null && t !== void 0 ? t : !1;
  return {
    async unary(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = D2(r, n, e.jsonOptions, e.binaryOptions);
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await Rne({
        interceptors: e.interceptors,
        signal: a,
        timeoutMs: o,
        req: {
          stream: !1,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: S2(e.baseUrl, r),
          header: R2(r.methodKind, n, o, s),
          contextValues: u ?? O2(),
          message: i
        },
        next: async (f) => {
          var d;
          const m = e.useHttpGet === !0 && r.idempotency === tN.NO_SIDE_EFFECTS;
          let p = null;
          m ? f = Une(f, l(f.message), n) : p = l(f.message);
          const b = await ((d = e.fetch) !== null && d !== void 0 ? d : globalThis.fetch)(f.url, Object.assign(Object.assign({}, V2), { method: f.requestMethod, headers: f.header, signal: f.signal, body: p })), { isUnaryError: g, unaryError: S } = $2(r.methodKind, n, b.status, b.headers);
          if (g)
            throw m6(await b.json(), fne(...U2(b.headers)), S);
          const [D, k] = U2(b.headers);
          return {
            stream: !1,
            service: r.parent,
            method: r,
            header: D,
            message: n ? c(new Uint8Array(await b.arrayBuffer())) : r6(r.output, await b.json(), f6(e.jsonOptions)),
            trailer: k
          };
        }
      });
    },
    async stream(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = D2(r, n, e.jsonOptions, e.binaryOptions);
      function f(m, p, b, g) {
        return Vne(this, arguments, function* () {
          const S = bne(m).getReader();
          let D = !1;
          for (; ; ) {
            const k = yield Vl(S.read());
            if (k.done)
              break;
            const { flags: U, data: R } = k.value;
            if ((U & _2) === _2)
              throw new De("protocol error: received unsupported compressed output", j.Internal);
            if ((U & L2) === L2) {
              D = !0;
              const F = One(R);
              if (F.error) {
                const A = F.error;
                throw b.forEach((L, re) => {
                  A.metadata.append(re, L);
                }), A;
              }
              F.metadata.forEach((A, L) => p.set(L, A));
              continue;
            }
            yield yield Vl(c(R));
          }
          if ("throwIfAborted" in g && g.throwIfAborted(), !D)
            throw "missing EndStreamResponse";
        });
      }
      async function d(m) {
        if (r.methodKind != "server_streaming")
          throw "The fetch API does not support streaming request bodies";
        const p = await m[Symbol.asyncIterator]().next();
        if (p.done == !0)
          throw "missing request message";
        return gne(0, l(p.value));
      }
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await $ne({
        interceptors: e.interceptors,
        timeoutMs: o,
        signal: a,
        req: {
          stream: !0,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: S2(e.baseUrl, r),
          header: R2(r.methodKind, n, o, s),
          contextValues: u ?? O2(),
          message: i
        },
        next: async (m) => {
          var p;
          const b = await ((p = e.fetch) !== null && p !== void 0 ? p : globalThis.fetch)(m.url, Object.assign(Object.assign({}, V2), { method: m.requestMethod, headers: m.header, signal: m.signal, body: await d(m.message) }));
          if ($2(r.methodKind, n, b.status, b.headers), b.body === null)
            throw "missing response body";
          const g = new Headers();
          return Object.assign(Object.assign({}, m), { header: b.headers, trailer: g, message: f(b.body, g, b.headers, m.signal) });
        }
      });
    }
  };
}
xne({
  baseUrl: "/api",
  useBinaryFormat: !0,
  fetch: (e, t) => {
    const n = t?.headers ?? {};
    return fetch(e, {
      ...t,
      headers: {
        ...n,
        "qt-widget-id": window.qtWidgetId
      }
    });
  }
});
const gt = /* @__PURE__ */ Symbol(), Yne = !1;
var jne = Array.isArray, Bne = Array.prototype.indexOf, ch = Object.getOwnPropertyDescriptor, Gne = Object.prototype, Mne = Array.prototype, Cne = Object.getPrototypeOf;
function Kne(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function Xne() {
  var e, t, n = new Promise((r, a) => {
    e = r, t = a;
  });
  return { promise: n, resolve: e, reject: t };
}
const ln = 2, Wne = 4, Jne = 1 << 24, wu = 16, cf = 32, ff = 64, Fv = 128, Zr = 512, _t = 1024, vr = 2048, Hr = 4096, rd = 8192, bs = 16384, Zne = 32768, x2 = 1 << 17, g6 = 1 << 18, Gs = 32768, aN = 1 << 21, h6 = 1 << 22, xl = 1 << 23, fh = /* @__PURE__ */ Symbol("$state"), y6 = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function Hne() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function zne() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function qne() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Qne() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function ere(e) {
  return e === this.v;
}
let tre = !1;
function N6() {
  return !0;
}
let Ni = [];
function nre() {
  var e = Ni;
  Ni = [], Kne(e);
}
function rre(e) {
  if (Ni.length === 0) {
    var t = Ni;
    queueMicrotask(() => {
      t === Ni && nre();
    });
  }
  Ni.push(e);
}
function are(e) {
  var t = Gt;
  if (t === null)
    return Ne.f |= xl, e;
  if ((t.f & Zne) === 0) {
    if ((t.f & Fv) === 0)
      throw e;
    t.b.error(e);
  } else
    E6(e, t);
}
function E6(e, t) {
  for (; t !== null; ) {
    if ((t.f & Fv) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e;
}
const hm = /* @__PURE__ */ new Set();
let Ze = null, jn = null, Pr = [], Uv = null, oN = !1;
class Yl {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #e = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #i = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    Pr = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const r of t)
      this.#u(r, n);
    this.is_fork || this.#c(), this.is_deferred() ? (this.#n(n.effects), this.#n(n.render_effects)) : (Ze = null, Y2(n.render_effects), Y2(n.effects), this.#i?.resolve()), jn = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #u(t, n) {
    t.f ^= _t;
    for (var r = t.first; r !== null; ) {
      var a = r.f, o = (a & (cf | ff)) !== 0, s = o && (a & _t) !== 0, i = s || (a & rd) !== 0 || this.skipped_effects.has(r);
      if ((r.f & Fv) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: []
      }), !i && r.fn !== null) {
        o ? r.f ^= _t : (a & Wne) !== 0 ? n.effects.push(r) : df(r) && ((r.f & wu) !== 0 && this.#o.add(r), cp(r));
        var u = r.first;
        if (u !== null) {
          r = u;
          continue;
        }
      }
      var l = r.parent;
      for (r = r.next; r === null && l !== null; )
        l === n.effect && (this.#n(n.effects), this.#n(n.render_effects), n = /** @type {EffectTarget} */
        n.parent), r = l.next, l = l.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #n(t) {
    for (const n of t)
      (n.f & vr) !== 0 ? this.#o.add(n) : (n.f & Hr) !== 0 && this.#s.add(n), this.#l(n.deps), Mt(n, _t);
  }
  /**
   * @param {Value[] | null} deps
   */
  #l(t) {
    if (t !== null)
      for (const n of t)
        (n.f & ln) === 0 || (n.f & Gs) === 0 || (n.f ^= Gs, this.#l(
          /** @type {Derived} */
          n.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.previous.has(t) || this.previous.set(t, n), (t.f & xl) === 0 && (this.current.set(t, t.v), jn?.set(t, t.v));
  }
  activate() {
    Ze = this, this.apply();
  }
  deactivate() {
    Ze === this && (Ze = null, jn = null);
  }
  flush() {
    if (this.activate(), Pr.length > 0) {
      if (ore(), Ze !== null && Ze !== this)
        return;
    } else this.#e === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const t of this.#a) t(this);
    this.#a.clear();
  }
  #c() {
    if (this.#t === 0) {
      for (const t of this.#r) t();
      this.#r.clear();
    }
    this.#e === 0 && this.#f();
  }
  #f() {
    if (hm.size > 1) {
      this.previous.clear();
      var t = jn, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const o of hm) {
        if (o === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [u, l] of this.current) {
          if (o.current.has(u))
            if (n && l !== o.current.get(u))
              o.current.set(u, l);
            else
              continue;
          s.push(u);
        }
        if (s.length === 0)
          continue;
        const i = [...o.current.keys()].filter((u) => !this.current.has(u));
        if (i.length > 0) {
          var a = Pr;
          Pr = [];
          const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            v6(c, i, u, l);
          if (Pr.length > 0) {
            Ze = o, o.apply();
            for (const c of Pr)
              o.#u(c, r);
            o.deactivate();
          }
          Pr = a;
        }
      }
      Ze = null, jn = t;
    }
    this.committed = !0, hm.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(t) {
    this.#e += 1, t && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(t) {
    this.#e -= 1, t && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const t of this.#o)
      this.#s.delete(t), Mt(t, vr), jl(t);
    for (const t of this.#s)
      Mt(t, Hr), jl(t);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(t) {
    this.#r.add(t);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(t) {
    this.#a.add(t);
  }
  settled() {
    return (this.#i ??= Xne()).promise;
  }
  static ensure() {
    if (Ze === null) {
      const t = Ze = new Yl();
      hm.add(Ze), Yl.enqueue(() => {
        Ze === t && t.flush();
      });
    }
    return Ze;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    rre(t);
  }
  apply() {
  }
}
function ore() {
  var e = gs;
  oN = !0;
  try {
    var t = 0;
    for (ip(!0); Pr.length > 0; ) {
      var n = Yl.ensure();
      if (t++ > 1e3) {
        var r, a;
        sre();
      }
      n.process(Pr), co.clear();
    }
  } finally {
    oN = !1, ip(e), Uv = null;
  }
}
function sre() {
  try {
    Hne();
  } catch (e) {
    E6(e, Uv);
  }
}
let ga = null;
function Y2(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (bs | rd)) === 0 && df(r) && (ga = /* @__PURE__ */ new Set(), cp(r), r.deps === null && r.first === null && r.nodes === null && (r.teardown === null && r.ac === null ? A6(r) : r.fn = null), ga?.size > 0)) {
        co.clear();
        for (const a of ga) {
          if ((a.f & (bs | rd)) !== 0) continue;
          const o = [a];
          let s = a.parent;
          for (; s !== null; )
            ga.has(s) && (ga.delete(s), o.push(s)), s = s.parent;
          for (let i = o.length - 1; i >= 0; i--) {
            const u = o[i];
            (u.f & (bs | rd)) === 0 && cp(u);
          }
        }
        ga.clear();
      }
    }
    ga = null;
  }
}
function v6(e, t, n, r) {
  if (!n.has(e) && (n.add(e), e.reactions !== null))
    for (const a of e.reactions) {
      const o = a.f;
      (o & ln) !== 0 ? v6(
        /** @type {Derived} */
        a,
        t,
        n,
        r
      ) : (o & (h6 | wu)) !== 0 && (o & vr) === 0 && T6(a, t, r) && (Mt(a, vr), jl(
        /** @type {Effect} */
        a
      ));
    }
}
function T6(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (e.deps !== null)
    for (const a of e.deps) {
      if (t.includes(a))
        return !0;
      if ((a.f & ln) !== 0 && T6(
        /** @type {Derived} */
        a,
        t,
        n
      ))
        return n.set(
          /** @type {Derived} */
          a,
          !0
        ), !0;
    }
  return n.set(e, !1), !1;
}
function jl(e) {
  for (var t = Uv = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (oN && t === Gt && (n & wu) !== 0 && (n & g6) === 0)
      return;
    if ((n & (ff | cf)) !== 0) {
      if ((n & _t) === 0) return;
      t.f ^= _t;
    }
  }
  Pr.push(t);
}
function I6(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      $v(
        /** @type {Effect} */
        t[n]
      );
  }
}
function ire(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & ln) === 0)
      return (t.f & bs) === 0 ? (
        /** @type {Effect} */
        t
      ) : null;
    t = t.parent;
  }
  return null;
}
function Rv(e) {
  var t, n = Gt;
  up(ire(e));
  try {
    e.f &= ~Gs, I6(e), t = R6(e);
  } finally {
    up(n);
  }
  return t;
}
function w6(e) {
  var t = Rv(e);
  if (e.equals(t) || (Ze?.is_fork || (e.v = t), e.wv = F6()), !mf)
    if (jn !== null)
      (sp() || Ze?.is_fork) && jn.set(e, t);
    else {
      var n = (e.f & Zr) === 0 ? Hr : _t;
      Mt(e, n);
    }
}
let sN = /* @__PURE__ */ new Set();
const co = /* @__PURE__ */ new Map();
let _6 = !1;
function ure(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: ere,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function qa(e, t) {
  const n = ure(e);
  return bre(n), n;
}
function Vo(e, t, n = !1) {
  Ne !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!qo || (Ne.f & x2) !== 0) && N6() && (Ne.f & (ln | wu | h6 | x2)) !== 0 && !Ba?.includes(e) && Qne();
  let r = n ? Ei(t) : t;
  return lre(e, r);
}
function lre(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    mf ? co.set(e, t) : co.set(e, n), e.v = t;
    var r = Yl.ensure();
    r.capture(e, n), (e.f & ln) !== 0 && ((e.f & vr) !== 0 && Rv(
      /** @type {Derived} */
      e
    ), Mt(e, (e.f & Zr) !== 0 ? _t : Hr)), e.wv = F6(), O6(e, vr), Gt !== null && (Gt.f & _t) !== 0 && (Gt.f & (cf | ff)) === 0 && (An === null ? gre([e]) : An.push(e)), !r.is_fork && sN.size > 0 && !_6 && cre();
  }
  return t;
}
function cre() {
  _6 = !1;
  var e = gs;
  ip(!0);
  const t = Array.from(sN);
  try {
    for (const n of t)
      (n.f & _t) !== 0 && Mt(n, Hr), df(n) && cp(n);
  } finally {
    ip(e);
  }
  sN.clear();
}
function mh(e) {
  Vo(e, e.v + 1);
}
function O6(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, a = 0; a < r; a++) {
      var o = n[a], s = o.f, i = (s & vr) === 0;
      if (i && Mt(o, t), (s & ln) !== 0) {
        var u = (
          /** @type {Derived} */
          o
        );
        jn?.delete(u), (s & Gs) === 0 && (s & Zr && (o.f |= Gs), O6(u, Hr));
      } else i && ((s & wu) !== 0 && ga !== null && ga.add(
        /** @type {Effect} */
        o
      ), jl(
        /** @type {Effect} */
        o
      ));
    }
}
function Ei(e) {
  if (typeof e != "object" || e === null || fh in e)
    return e;
  const t = Cne(e);
  if (t !== Gne && t !== Mne)
    return e;
  var n = /* @__PURE__ */ new Map(), r = jne(e), a = /* @__PURE__ */ qa(0), o = hs, s = (i) => {
    if (hs === o)
      return i();
    var u = Ne, l = hs;
    Qi(null), B2(o);
    var c = i();
    return Qi(u), B2(l), c;
  };
  return r && n.set("length", /* @__PURE__ */ qa(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(i, u, l) {
        (!("value" in l) || l.configurable === !1 || l.enumerable === !1 || l.writable === !1) && zne();
        var c = n.get(u);
        return c === void 0 ? c = s(() => {
          var f = /* @__PURE__ */ qa(l.value);
          return n.set(u, f), f;
        }) : Vo(c, l.value, !0), !0;
      },
      deleteProperty(i, u) {
        var l = n.get(u);
        if (l === void 0) {
          if (u in i) {
            const c = s(() => /* @__PURE__ */ qa(gt));
            n.set(u, c), mh(a);
          }
        } else
          Vo(l, gt), mh(a);
        return !0;
      },
      get(i, u, l) {
        if (u === fh)
          return e;
        var c = n.get(u), f = u in i;
        if (c === void 0 && (!f || ch(i, u)?.writable) && (c = s(() => {
          var m = Ei(f ? i[u] : gt), p = /* @__PURE__ */ qa(m);
          return p;
        }), n.set(u, c)), c !== void 0) {
          var d = ym(c);
          return d === gt ? void 0 : d;
        }
        return Reflect.get(i, u, l);
      },
      getOwnPropertyDescriptor(i, u) {
        var l = Reflect.getOwnPropertyDescriptor(i, u);
        if (l && "value" in l) {
          var c = n.get(u);
          c && (l.value = ym(c));
        } else if (l === void 0) {
          var f = n.get(u), d = f?.v;
          if (f !== void 0 && d !== gt)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return l;
      },
      has(i, u) {
        if (u === fh)
          return !0;
        var l = n.get(u), c = l !== void 0 && l.v !== gt || Reflect.has(i, u);
        if (l !== void 0 || Gt !== null && (!c || ch(i, u)?.writable)) {
          l === void 0 && (l = s(() => {
            var d = c ? Ei(i[u]) : gt, m = /* @__PURE__ */ qa(d);
            return m;
          }), n.set(u, l));
          var f = ym(l);
          if (f === gt)
            return !1;
        }
        return c;
      },
      set(i, u, l, c) {
        var f = n.get(u), d = u in i;
        if (r && u === "length")
          for (var m = l; m < /** @type {Source<number>} */
          f.v; m += 1) {
            var p = n.get(m + "");
            p !== void 0 ? Vo(p, gt) : m in i && (p = s(() => /* @__PURE__ */ qa(gt)), n.set(m + "", p));
          }
        if (f === void 0)
          (!d || ch(i, u)?.writable) && (f = s(() => /* @__PURE__ */ qa(void 0)), Vo(f, Ei(l)), n.set(u, f));
        else {
          d = f.v !== gt;
          var b = s(() => Ei(l));
          Vo(f, b);
        }
        var g = Reflect.getOwnPropertyDescriptor(i, u);
        if (g?.set && g.set.call(c, l), !d) {
          if (r && typeof u == "string") {
            var S = (
              /** @type {Source<number>} */
              n.get("length")
            ), D = Number(u);
            Number.isInteger(D) && D >= S.v && Vo(S, D + 1);
          }
          mh(a);
        }
        return !0;
      },
      ownKeys(i) {
        ym(a);
        var u = Reflect.ownKeys(i).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== gt;
        });
        for (var [l, c] of n)
          c.v !== gt && !(l in i) && u.push(l);
        return u;
      },
      setPrototypeOf() {
        qne();
      }
    }
  );
}
var fre;
// @__NO_SIDE_EFFECTS__
function mre(e) {
  return (
    /** @type {TemplateNode | null} */
    fre.call(e)
  );
}
function S6(e) {
  var t = Ne, n = Gt;
  Qi(null), up(null);
  try {
    return e();
  } finally {
    Qi(t), up(n);
  }
}
function sp() {
  return Ne !== null && !qo;
}
function D6(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = mf, r = Ne;
    j2(!0), Qi(null);
    try {
      t.call(null);
    } finally {
      j2(n), Qi(r);
    }
  }
}
function k6(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const a = n.ac;
    a !== null && S6(() => {
      a.abort(y6);
    });
    var r = n.next;
    (n.f & ff) !== 0 ? n.parent = null : $v(n, t), n = r;
  }
}
function dre(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & cf) === 0 && $v(t), t = n;
  }
}
function $v(e, t = !0) {
  var n = !1;
  (t || (e.f & g6) !== 0) && e.nodes !== null && e.nodes.end !== null && (pre(
    e.nodes.start,
    /** @type {TemplateNode} */
    e.nodes.end
  ), n = !0), k6(e, t && !n), lp(e, 0), Mt(e, bs);
  var r = e.nodes && e.nodes.t;
  if (r !== null)
    for (const o of r)
      o.stop();
  D6(e);
  var a = e.parent;
  a !== null && a.first !== null && A6(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes = e.ac = null;
}
function pre(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : /* @__PURE__ */ mre(e);
    e.remove(), e = n;
  }
}
function A6(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
let gs = !1;
function ip(e) {
  gs = e;
}
let mf = !1;
function j2(e) {
  mf = e;
}
let Ne = null, qo = !1;
function Qi(e) {
  Ne = e;
}
let Gt = null;
function up(e) {
  Gt = e;
}
let Ba = null;
function bre(e) {
  Ne !== null && (Ba === null ? Ba = [e] : Ba.push(e));
}
let ot = null, Nn = 0, An = null;
function gre(e) {
  An = e;
}
let L6 = 1, Bl = 0, hs = Bl;
function B2(e) {
  hs = e;
}
function F6() {
  return ++L6;
}
function df(e) {
  var t = e.f;
  if ((t & vr) !== 0)
    return !0;
  if (t & ln && (e.f &= ~Gs), (t & Hr) !== 0) {
    var n = e.deps;
    if (n !== null)
      for (var r = n.length, a = 0; a < r; a++) {
        var o = n[a];
        if (df(
          /** @type {Derived} */
          o
        ) && w6(
          /** @type {Derived} */
          o
        ), o.wv > e.wv)
          return !0;
      }
    (t & Zr) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    jn === null && Mt(e, _t);
  }
  return !1;
}
function U6(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !Ba?.includes(e))
    for (var a = 0; a < r.length; a++) {
      var o = r[a];
      (o.f & ln) !== 0 ? U6(
        /** @type {Derived} */
        o,
        t,
        !1
      ) : t === o && (n ? Mt(o, vr) : (o.f & _t) !== 0 && Mt(o, Hr), jl(
        /** @type {Effect} */
        o
      ));
    }
}
function R6(e) {
  var t = ot, n = Nn, r = An, a = Ne, o = Ba, s = qo, i = hs, u = e.f;
  ot = /** @type {null | Value[]} */
  null, Nn = 0, An = null, Ne = (u & (cf | ff)) === 0 ? e : null, Ba = null, e.ctx, qo = !1, hs = ++Bl, e.ac !== null && (S6(() => {
    e.ac.abort(y6);
  }), e.ac = null);
  try {
    e.f |= aN;
    var l = (
      /** @type {Function} */
      e.fn
    ), c = l(), f = e.deps;
    if (ot !== null) {
      var d;
      if (lp(e, Nn), f !== null && Nn > 0)
        for (f.length = Nn + ot.length, d = 0; d < ot.length; d++)
          f[Nn + d] = ot[d];
      else
        e.deps = f = ot;
      if (sp() && (e.f & Zr) !== 0)
        for (d = Nn; d < f.length; d++)
          (f[d].reactions ??= []).push(e);
    } else f !== null && Nn < f.length && (lp(e, Nn), f.length = Nn);
    if (N6() && An !== null && !qo && f !== null && (e.f & (ln | Hr | vr)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      An.length; d++)
        U6(
          An[d],
          /** @type {Effect} */
          e
        );
    return a !== null && a !== e && (Bl++, An !== null && (r === null ? r = An : r.push(.../** @type {Source[]} */
    An))), (e.f & xl) !== 0 && (e.f ^= xl), c;
  } catch (m) {
    return are(m);
  } finally {
    e.f ^= aN, ot = t, Nn = n, An = r, Ne = a, Ba = o, qo = s, hs = i;
  }
}
function hre(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = Bne.call(n, e);
    if (r !== -1) {
      var a = n.length - 1;
      a === 0 ? n = t.reactions = null : (n[r] = n[a], n.pop());
    }
  }
  n === null && (t.f & ln) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (ot === null || !ot.includes(t)) && (Mt(t, Hr), (t.f & Zr) !== 0 && (t.f ^= Zr, t.f &= ~Gs), I6(
    /** @type {Derived} **/
    t
  ), lp(
    /** @type {Derived} **/
    t,
    0
  ));
}
function lp(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      hre(e, n[r]);
}
function cp(e) {
  var t = e.f;
  if ((t & bs) === 0) {
    Mt(e, _t);
    var n = Gt, r = gs;
    Gt = e, gs = !0;
    try {
      (t & (wu | Jne)) !== 0 ? dre(e) : k6(e), D6(e);
      var a = R6(e);
      e.teardown = typeof a == "function" ? a : null, e.wv = L6;
      var o;
      Yne && tre && (e.f & vr) !== 0 && e.deps;
    } finally {
      gs = r, Gt = n;
    }
  }
}
function ym(e) {
  var t = e.f, n = (t & ln) !== 0;
  if (Ne !== null && !qo) {
    var r = Gt !== null && (Gt.f & bs) !== 0;
    if (!r && !Ba?.includes(e)) {
      var a = Ne.deps;
      if ((Ne.f & aN) !== 0)
        e.rv < Bl && (e.rv = Bl, ot === null && a !== null && a[Nn] === e ? Nn++ : ot === null ? ot = [e] : ot.includes(e) || ot.push(e));
      else {
        (Ne.deps ??= []).push(e);
        var o = e.reactions;
        o === null ? e.reactions = [Ne] : o.includes(Ne) || o.push(Ne);
      }
    }
  }
  if (mf) {
    if (co.has(e))
      return co.get(e);
    if (n) {
      var s = (
        /** @type {Derived} */
        e
      ), i = s.v;
      return ((s.f & _t) === 0 && s.reactions !== null || P6(s)) && (i = Rv(s)), co.set(s, i), i;
    }
  } else n && (!jn?.has(e) || Ze?.is_fork && !sp()) && (s = /** @type {Derived} */
  e, df(s) && w6(s), gs && sp() && (s.f & Zr) === 0 && $6(s));
  if (jn?.has(e))
    return jn.get(e);
  if ((e.f & xl) !== 0)
    throw e.v;
  return e.v;
}
function $6(e) {
  if (e.deps !== null) {
    e.f ^= Zr;
    for (const t of e.deps)
      (t.reactions ??= []).push(e), (t.f & ln) !== 0 && (t.f & Zr) === 0 && $6(
        /** @type {Derived} */
        t
      );
  }
}
function P6(e) {
  if (e.v === gt) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (co.has(t) || (t.f & ln) !== 0 && P6(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
const yre = -7169;
function Mt(e, t) {
  e.f = e.f & yre | t;
}
function V6() {
  return {
    isDark: document.documentElement.classList.contains("night-mode")
  };
}
const Nre = Ei(V6()), Ere = new MutationObserver((e, t) => {
  Nre.isDark = V6().isDark;
});
Ere.observe(document.documentElement, { attributeFilter: ["class"] });
const vre = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(vre);
var B;
(function(e) {
  e[e.Canceled = 1] = "Canceled", e[e.Unknown = 2] = "Unknown", e[e.InvalidArgument = 3] = "InvalidArgument", e[e.DeadlineExceeded = 4] = "DeadlineExceeded", e[e.NotFound = 5] = "NotFound", e[e.AlreadyExists = 6] = "AlreadyExists", e[e.PermissionDenied = 7] = "PermissionDenied", e[e.ResourceExhausted = 8] = "ResourceExhausted", e[e.FailedPrecondition = 9] = "FailedPrecondition", e[e.Aborted = 10] = "Aborted", e[e.OutOfRange = 11] = "OutOfRange", e[e.Unimplemented = 12] = "Unimplemented", e[e.Internal = 13] = "Internal", e[e.Unavailable = 14] = "Unavailable", e[e.DataLoss = 15] = "DataLoss", e[e.Unauthenticated = 16] = "Unauthenticated";
})(B || (B = {}));
function Pv(e, t) {
  return e !== null && typeof e == "object" && "$typeName" in e && typeof e.$typeName == "string" ? t === void 0 ? !0 : t.typeName === e.$typeName : !1;
}
var T;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(T || (T = {}));
function Tre() {
  let e = 0, t = 0;
  for (let r = 0; r < 28; r += 7) {
    let a = this.buf[this.pos++];
    if (e |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  let n = this.buf[this.pos++];
  if (e |= (n & 15) << 28, t = (n & 112) >> 4, (n & 128) == 0)
    return this.assertBounds(), [e, t];
  for (let r = 3; r <= 31; r += 7) {
    let a = this.buf[this.pos++];
    if (t |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  throw new Error("invalid varint");
}
function dh(e, t, n) {
  for (let o = 0; o < 28; o = o + 7) {
    const s = e >>> o, i = !(!(s >>> 7) && t == 0), u = (i ? s | 128 : s) & 255;
    if (n.push(u), !i)
      return;
  }
  const r = e >>> 28 & 15 | (t & 7) << 4, a = t >> 3 != 0;
  if (n.push((a ? r | 128 : r) & 255), !!a) {
    for (let o = 3; o < 31; o = o + 7) {
      const s = t >>> o, i = !!(s >>> 7), u = (i ? s | 128 : s) & 255;
      if (n.push(u), !i)
        return;
    }
    n.push(t >>> 31 & 1);
  }
}
const ad = 4294967296;
function G2(e) {
  const t = e[0] === "-";
  t && (e = e.slice(1));
  const n = 1e6;
  let r = 0, a = 0;
  function o(s, i) {
    const u = Number(e.slice(s, i));
    a *= n, r = r * n + u, r >= ad && (a = a + (r / ad | 0), r = r % ad);
  }
  return o(-24, -18), o(-18, -12), o(-12, -6), o(-6), t ? Y6(r, a) : Vv(r, a);
}
function Ire(e, t) {
  let n = Vv(e, t);
  const r = n.hi & 2147483648;
  r && (n = Y6(n.lo, n.hi));
  const a = x6(n.lo, n.hi);
  return r ? "-" + a : a;
}
function x6(e, t) {
  if ({ lo: e, hi: t } = wre(e, t), t <= 2097151)
    return String(ad * t + e);
  const n = e & 16777215, r = (e >>> 24 | t << 8) & 16777215, a = t >> 16 & 65535;
  let o = n + r * 6777216 + a * 6710656, s = r + a * 8147497, i = a * 2;
  const u = 1e7;
  return o >= u && (s += Math.floor(o / u), o %= u), s >= u && (i += Math.floor(s / u), s %= u), i.toString() + M2(s) + M2(o);
}
function wre(e, t) {
  return { lo: e >>> 0, hi: t >>> 0 };
}
function Vv(e, t) {
  return { lo: e | 0, hi: t | 0 };
}
function Y6(e, t) {
  return t = ~t, e ? e = ~e + 1 : t += 1, Vv(e, t);
}
const M2 = (e) => {
  const t = String(e);
  return "0000000".slice(t.length) + t;
};
function iN(e, t) {
  if (e >= 0) {
    for (; e > 127; )
      t.push(e & 127 | 128), e = e >>> 7;
    t.push(e);
  } else {
    for (let n = 0; n < 9; n++)
      t.push(e & 127 | 128), e = e >> 7;
    t.push(1);
  }
}
function _re() {
  let e = this.buf[this.pos++], t = e & 127;
  if ((e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 7, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 14, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 21, (e & 128) == 0)
    return this.assertBounds(), t;
  e = this.buf[this.pos++], t |= (e & 15) << 28;
  for (let n = 5; (e & 128) !== 0 && n < 10; n++)
    e = this.buf[this.pos++];
  if ((e & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
const z = /* @__PURE__ */ Ore();
function Ore() {
  const e = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof e.getBigInt64 == "function" && typeof e.getBigUint64 == "function" && typeof e.setBigInt64 == "function" && typeof e.setBigUint64 == "function" && (globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const t = BigInt("-9223372036854775808"), n = BigInt("9223372036854775807"), r = BigInt("0"), a = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > n || s < t)
          throw new Error(`invalid int64: ${o}`);
        return s;
      },
      uParse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > a || s < r)
          throw new Error(`invalid uint64: ${o}`);
        return s;
      },
      enc(o) {
        return e.setBigInt64(0, this.parse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      uEnc(o) {
        return e.setBigInt64(0, this.uParse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      dec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigInt64(0, !0);
      },
      uDec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigUint64(0, !0);
      }
    };
  }
  return {
    zero: "0",
    supported: !1,
    parse(t) {
      return typeof t != "string" && (t = t.toString()), C2(t), t;
    },
    uParse(t) {
      return typeof t != "string" && (t = t.toString()), K2(t), t;
    },
    enc(t) {
      return typeof t != "string" && (t = t.toString()), C2(t), G2(t);
    },
    uEnc(t) {
      return typeof t != "string" && (t = t.toString()), K2(t), G2(t);
    },
    dec(t, n) {
      return Ire(t, n);
    },
    uDec(t, n) {
      return x6(t, n);
    }
  };
}
function C2(e) {
  if (!/^-?[0-9]+$/.test(e))
    throw new Error("invalid int64: " + e);
}
function K2(e) {
  if (!/^[0-9]+$/.test(e))
    throw new Error("invalid uint64: " + e);
}
function Ms(e, t) {
  switch (e) {
    case T.STRING:
      return "";
    case T.BOOL:
      return !1;
    case T.DOUBLE:
    case T.FLOAT:
      return 0;
    case T.INT64:
    case T.UINT64:
    case T.SFIXED64:
    case T.FIXED64:
    case T.SINT64:
      return t ? "0" : z.zero;
    case T.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function Sre(e, t) {
  switch (e) {
    case T.BOOL:
      return t === !1;
    case T.STRING:
      return t === "";
    case T.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
const j6 = 2, Fa = /* @__PURE__ */ Symbol.for("reflect unsafe local");
function B6(e, t) {
  const n = e[t.localName].case;
  return n === void 0 ? n : t.fields.find((r) => r.localName === n);
}
function Dre(e, t) {
  const n = t.localName;
  if (t.oneof)
    return e[t.oneof.localName].case === n;
  if (t.presence != j6)
    return e[n] !== void 0 && Object.prototype.hasOwnProperty.call(e, n);
  switch (t.fieldKind) {
    case "list":
      return e[n].length > 0;
    case "map":
      return Object.keys(e[n]).length > 0;
    case "scalar":
      return !Sre(t.scalar, e[n]);
    case "enum":
      return e[n] !== t.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function Gl(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) && e[t] !== void 0;
}
function G6(e, t) {
  if (t.oneof) {
    const n = e[t.oneof.localName];
    return n.case === t.localName ? n.value : void 0;
  }
  return e[t.localName];
}
function M6(e, t, n) {
  t.oneof ? e[t.oneof.localName] = {
    case: t.localName,
    value: n
  } : e[t.localName] = n;
}
function kre(e, t) {
  const n = t.localName;
  if (t.oneof) {
    const r = t.oneof.localName;
    e[r].case === n && (e[r] = { case: void 0 });
  } else if (t.presence != j6)
    delete e[n];
  else
    switch (t.fieldKind) {
      case "map":
        e[n] = {};
        break;
      case "list":
        e[n] = [];
        break;
      case "enum":
        e[n] = t.enum.values[0].number;
        break;
      case "scalar":
        e[n] = Ms(t.scalar, t.longAsString);
        break;
    }
}
function Io(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function xv(e, t) {
  var n, r, a, o;
  if (Io(e) && Fa in e && "add" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.listKind == i.listKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function Yv(e, t) {
  var n, r, a, o;
  if (Io(e) && Fa in e && "has" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.mapKey === i.mapKey && s.mapKind == i.mapKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function jv(e, t) {
  return Io(e) && Fa in e && "desc" in e && Io(e.desc) && e.desc.kind === "message" && (t === void 0 || e.desc.typeName == t.typeName);
}
function Are(e) {
  return C6(e.$typeName);
}
function pf(e) {
  const t = e.fields[0];
  return C6(e.typeName) && t !== void 0 && t.fieldKind == "scalar" && t.name == "value" && t.number == 1;
}
function C6(e) {
  return e.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(e.substring(16));
}
const Lre = 999, Fre = 998, od = 2;
function Tr(e, t) {
  if (Pv(t, e))
    return t;
  const n = Vre(e);
  return t !== void 0 && Ure(e, n, t), n;
}
function Ure(e, t, n) {
  for (const r of e.members) {
    let a = n[r.localName];
    if (a == null)
      continue;
    let o;
    if (r.kind == "oneof") {
      const s = B6(n, r);
      if (!s)
        continue;
      o = s, a = G6(n, s);
    } else
      o = r;
    switch (o.fieldKind) {
      case "message":
        a = Bv(o, a);
        break;
      case "scalar":
        a = K6(o, a);
        break;
      case "list":
        a = $re(o, a);
        break;
      case "map":
        a = Rre(o, a);
        break;
    }
    M6(t, o, a);
  }
  return t;
}
function K6(e, t) {
  return e.scalar == T.BYTES ? Gv(t) : t;
}
function Rre(e, t) {
  if (Io(t)) {
    if (e.scalar == T.BYTES)
      return X2(t, Gv);
    if (e.mapKind == "message")
      return X2(t, (n) => Bv(e, n));
  }
  return t;
}
function $re(e, t) {
  if (Array.isArray(t)) {
    if (e.scalar == T.BYTES)
      return t.map(Gv);
    if (e.listKind == "message")
      return t.map((n) => Bv(e, n));
  }
  return t;
}
function Bv(e, t) {
  if (e.fieldKind == "message" && !e.oneof && pf(e.message))
    return K6(e.message.fields[0], t);
  if (Io(t)) {
    if (e.message.typeName == "google.protobuf.Struct" && e.parent.typeName !== "google.protobuf.Value")
      return t;
    if (!Pv(t, e.message))
      return Tr(e.message, t);
  }
  return t;
}
function Gv(e) {
  return Array.isArray(e) ? new Uint8Array(e) : e;
}
function X2(e, t) {
  const n = {};
  for (const r of Object.entries(e))
    n[r[0]] = t(r[1]);
  return n;
}
const Pre = /* @__PURE__ */ Symbol(), W2 = /* @__PURE__ */ new WeakMap();
function Vre(e) {
  let t;
  if (xre(e)) {
    const n = W2.get(e);
    let r, a;
    if (n)
      ({ prototype: r, members: a } = n);
    else {
      r = {}, a = /* @__PURE__ */ new Set();
      for (const o of e.members)
        o.kind != "oneof" && (o.fieldKind != "scalar" && o.fieldKind != "enum" || o.presence != od && (a.add(o), r[o.localName] = ph(o)));
      W2.set(e, { prototype: r, members: a });
    }
    t = Object.create(r), t.$typeName = e.typeName;
    for (const o of e.members)
      a.has(o) || o.kind == "field" && (o.fieldKind == "message" || (o.fieldKind == "scalar" || o.fieldKind == "enum") && o.presence != od) || (t[o.localName] = ph(o));
  } else {
    t = {
      $typeName: e.typeName
    };
    for (const n of e.members)
      (n.kind == "oneof" || n.presence == od) && (t[n.localName] = ph(n));
  }
  return t;
}
function xre(e) {
  switch (e.file.edition) {
    case Lre:
      return !1;
    case Fre:
      return !0;
    default:
      return e.fields.some((t) => t.presence != od && t.fieldKind != "message" && !t.oneof);
  }
}
function ph(e) {
  if (e.kind == "oneof")
    return { case: void 0 };
  if (e.fieldKind == "list")
    return [];
  if (e.fieldKind == "map")
    return {};
  if (e.fieldKind == "message")
    return Pre;
  const t = e.getDefaultValue();
  return t !== void 0 ? e.fieldKind == "scalar" && e.longAsString ? t.toString() : t : e.fieldKind == "scalar" ? Ms(e.scalar, e.longAsString) : e.enum.values[0].number;
}
const Yre = [
  "FieldValueInvalidError",
  "FieldListRangeError",
  "ForeignFieldError"
];
class Ct extends Error {
  constructor(t, n, r = "FieldValueInvalidError") {
    super(n), this.name = r, this.field = () => t;
  }
}
function jre(e) {
  return e instanceof Error && Yre.includes(e.name) && "field" in e && typeof e.field == "function";
}
const bh = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
function Mv() {
  if (globalThis[bh] == null) {
    const e = new globalThis.TextEncoder(), t = new globalThis.TextDecoder();
    globalThis[bh] = {
      encodeUtf8(n) {
        return e.encode(n);
      },
      decodeUtf8(n) {
        return t.decode(n);
      },
      checkUtf8(n) {
        try {
          return encodeURIComponent(n), !0;
        } catch {
          return !1;
        }
      }
    };
  }
  return globalThis[bh];
}
var le;
(function(e) {
  e[e.Varint = 0] = "Varint", e[e.Bit64 = 1] = "Bit64", e[e.LengthDelimited = 2] = "LengthDelimited", e[e.StartGroup = 3] = "StartGroup", e[e.EndGroup = 4] = "EndGroup", e[e.Bit32 = 5] = "Bit32";
})(le || (le = {}));
const X6 = 34028234663852886e22, W6 = -34028234663852886e22, J6 = 4294967295, Z6 = 2147483647, H6 = -2147483648;
class z6 {
  constructor(t = Mv().encodeUtf8) {
    this.encodeUtf8 = t, this.stack = [], this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []);
    let t = 0;
    for (let a = 0; a < this.chunks.length; a++)
      t += this.chunks[a].length;
    let n = new Uint8Array(t), r = 0;
    for (let a = 0; a < this.chunks.length; a++)
      n.set(this.chunks[a], r), r += this.chunks[a].length;
    return this.chunks = [], n;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), n = this.stack.pop();
    if (!n)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = n.chunks, this.buf = n.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, n) {
    return this.uint32((t << 3 | n) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (J2(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return gh(t), iN(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let n = this.encodeUtf8(t);
    return this.uint32(n.byteLength), this.raw(n);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    Bre(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setFloat32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let n = new Uint8Array(8);
    return new DataView(n.buffer).setFloat64(0, t, !0), this.raw(n);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    J2(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    gh(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setInt32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return gh(t), t = (t << 1 ^ t >> 31) >>> 0, iN(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = z.enc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = z.uEnc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let n = z.enc(t);
    return dh(n.lo, n.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    const n = z.enc(t), r = n.hi >> 31, a = n.lo << 1 ^ r, o = (n.hi << 1 | n.lo >>> 31) ^ r;
    return dh(a, o, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    const n = z.uEnc(t);
    return dh(n.lo, n.hi, this.buf), this;
  }
}
class Cv {
  constructor(t, n = Mv().decodeUtf8) {
    this.decodeUtf8 = n, this.varint64 = Tre, this.uint32 = _re, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), n = t >>> 3, r = t & 7;
    if (n <= 0 || r < 0 || r > 5)
      throw new Error("illegal tag: field no " + n + " wire type " + r);
    return [n, r];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, n) {
    let r = this.pos;
    switch (t) {
      case le.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case le.Bit64:
        this.pos += 4;
      case le.Bit32:
        this.pos += 4;
        break;
      case le.LengthDelimited:
        let a = this.uint32();
        this.pos += a;
        break;
      case le.StartGroup:
        for (; ; ) {
          const [o, s] = this.tag();
          if (s === le.EndGroup) {
            if (n !== void 0 && o !== n)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(s, o);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return z.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return z.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, n] = this.varint64(), r = -(t & 1);
    return t = (t >>> 1 | (n & 1) << 31) ^ r, n = n >>> 1 ^ r, z.dec(t, n);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, n] = this.varint64();
    return t !== 0 || n !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return z.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return z.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), n = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(n, n + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function gh(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid int32: " + typeof e);
  if (!Number.isInteger(e) || e > Z6 || e < H6)
    throw new Error("invalid int32: " + e);
}
function J2(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid uint32: " + typeof e);
  if (!Number.isInteger(e) || e > J6 || e < 0)
    throw new Error("invalid uint32: " + e);
}
function Bre(e) {
  if (typeof e == "string") {
    const t = e;
    if (e = Number(e), Number.isNaN(e) && t !== "NaN")
      throw new Error("invalid float32: " + t);
  } else if (typeof e != "number")
    throw new Error("invalid float32: " + typeof e);
  if (Number.isFinite(e) && (e > X6 || e < W6))
    throw new Error("invalid float32: " + e);
}
function xo(e, t) {
  const n = e.fieldKind == "list" ? xv(t, e) : e.fieldKind == "map" ? Yv(t, e) : Kv(e, t);
  if (n === !0)
    return;
  let r;
  switch (e.fieldKind) {
    case "list":
      r = `expected ${eV(e)}, got ${Ye(t)}`;
      break;
    case "map":
      r = `expected ${tV(e)}, got ${Ye(t)}`;
      break;
    default:
      r = fp(e, t, n);
  }
  return new Ct(e, r);
}
function Z2(e, t, n) {
  const r = Kv(e, n);
  if (r !== !0)
    return new Ct(e, `list item #${t + 1}: ${fp(e, n, r)}`);
}
function Gre(e, t, n) {
  const r = q6(t, e.mapKey);
  if (r !== !0)
    return new Ct(e, `invalid map key: ${fp({ scalar: e.mapKey }, t, r)}`);
  const a = Kv(e, n);
  if (a !== !0)
    return new Ct(e, `map entry ${Ye(t)}: ${fp(e, n, a)}`);
}
function Kv(e, t) {
  return e.scalar !== void 0 ? q6(t, e.scalar) : e.enum !== void 0 ? e.enum.open ? Number.isInteger(t) : e.enum.values.some((n) => n.number === t) : jv(t, e.message);
}
function q6(e, t) {
  switch (t) {
    case T.DOUBLE:
      return typeof e == "number";
    case T.FLOAT:
      return typeof e != "number" ? !1 : Number.isNaN(e) || !Number.isFinite(e) ? !0 : e > X6 || e < W6 ? `${e.toFixed()} out of range` : !0;
    case T.INT32:
    case T.SFIXED32:
    case T.SINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > Z6 || e < H6 ? `${e.toFixed()} out of range` : !0;
    case T.FIXED32:
    case T.UINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > J6 || e < 0 ? `${e.toFixed()} out of range` : !0;
    case T.BOOL:
      return typeof e == "boolean";
    case T.STRING:
      return typeof e != "string" ? !1 : Mv().checkUtf8(e) || "invalid UTF8";
    case T.BYTES:
      return e instanceof Uint8Array;
    case T.INT64:
    case T.SFIXED64:
    case T.SINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return z.parse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
    case T.FIXED64:
    case T.UINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return z.uParse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
  }
}
function fp(e, t, n) {
  return n = typeof n == "string" ? `: ${n}` : `, got ${Ye(t)}`, e.scalar !== void 0 ? `expected ${Mre(e.scalar)}` + n : e.enum !== void 0 ? `expected ${e.enum.toString()}` + n : `expected ${Q6(e.message)}` + n;
}
function Ye(e) {
  switch (typeof e) {
    case "object":
      return e === null ? "null" : e instanceof Uint8Array ? `Uint8Array(${e.length})` : Array.isArray(e) ? `Array(${e.length})` : xv(e) ? eV(e.field()) : Yv(e) ? tV(e.field()) : jv(e) ? Q6(e.desc) : Pv(e) ? `message ${e.$typeName}` : "object";
    case "string":
      return e.length > 30 ? "string" : `"${e.split('"').join('\\"')}"`;
    case "boolean":
      return String(e);
    case "number":
      return String(e);
    case "bigint":
      return String(e) + "n";
    default:
      return typeof e;
  }
}
function Q6(e) {
  return `ReflectMessage (${e.typeName})`;
}
function eV(e) {
  switch (e.listKind) {
    case "message":
      return `ReflectList (${e.message.toString()})`;
    case "enum":
      return `ReflectList (${e.enum.toString()})`;
    case "scalar":
      return `ReflectList (${T[e.scalar]})`;
  }
}
function tV(e) {
  switch (e.mapKind) {
    case "message":
      return `ReflectMap (${T[e.mapKey]}, ${e.message.toString()})`;
    case "enum":
      return `ReflectMap (${T[e.mapKey]}, ${e.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${T[e.mapKey]}, ${T[e.scalar]})`;
  }
}
function Mre(e) {
  switch (e) {
    case T.STRING:
      return "string";
    case T.BOOL:
      return "boolean";
    case T.INT64:
    case T.SINT64:
    case T.SFIXED64:
      return "bigint (int64)";
    case T.UINT64:
    case T.FIXED64:
      return "bigint (uint64)";
    case T.BYTES:
      return "Uint8Array";
    case T.DOUBLE:
      return "number (float64)";
    case T.FLOAT:
      return "number (float32)";
    case T.FIXED32:
    case T.UINT32:
      return "number (uint32)";
    case T.INT32:
    case T.SFIXED32:
    case T.SINT32:
      return "number (int32)";
  }
}
function zn(e, t, n = !0) {
  return new nV(e, t, n);
}
const H2 = /* @__PURE__ */ new WeakMap();
class nV {
  get sortedFields() {
    const t = H2.get(this.desc);
    if (t)
      return t;
    const n = this.desc.fields.concat().sort((r, a) => r.number - a.number);
    return H2.set(this.desc, n), n;
  }
  constructor(t, n, r = !0) {
    this.lists = /* @__PURE__ */ new Map(), this.maps = /* @__PURE__ */ new Map(), this.check = r, this.desc = t, this.message = this[Fa] = n ?? Tr(t), this.fields = t.fields, this.oneofs = t.oneofs, this.members = t.members;
  }
  findNumber(t) {
    return this._fieldsByNumber || (this._fieldsByNumber = new Map(this.desc.fields.map((n) => [n.number, n]))), this._fieldsByNumber.get(t);
  }
  oneofCase(t) {
    return $u(this.message, t), B6(this.message, t);
  }
  isSet(t) {
    return $u(this.message, t), Dre(this.message, t);
  }
  clear(t) {
    $u(this.message, t), kre(this.message, t);
  }
  get(t) {
    $u(this.message, t);
    const n = G6(this.message, t);
    switch (t.fieldKind) {
      case "list":
        let r = this.lists.get(t);
        return (!r || r[Fa] !== n) && this.lists.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          r = new Cre(t, n, this.check)
        ), r;
      case "map":
        let a = this.maps.get(t);
        return (!a || a[Fa] !== n) && this.maps.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = new Kre(t, n, this.check)
        ), a;
      case "message":
        return Wv(t, n, this.check);
      case "scalar":
        return n === void 0 ? Ms(t.scalar, !1) : Jv(t, n);
      case "enum":
        return n ?? t.enum.values[0].number;
    }
  }
  set(t, n) {
    if ($u(this.message, t), this.check) {
      const a = xo(t, n);
      if (a)
        throw a;
    }
    let r;
    t.fieldKind == "message" ? r = Xv(t, n) : Yv(n) || xv(n) ? r = n[Fa] : r = Zv(t, n), M6(this.message, t, r);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(t) {
    this.message.$unknown = t;
  }
}
function $u(e, t) {
  if (t.parent.typeName !== e.$typeName)
    throw new Ct(t, `cannot use ${t.toString()} with message ${e.$typeName}`, "ForeignFieldError");
}
class Cre {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(t, n, r) {
    this._field = t, this._arr = this[Fa] = n, this.check = r;
  }
  get(t) {
    const n = this._arr[t];
    return n === void 0 ? void 0 : hh(this._field, n, this.check);
  }
  set(t, n) {
    if (t < 0 || t >= this._arr.length)
      throw new Ct(this._field, `list item #${t + 1}: out of range`);
    if (this.check) {
      const r = Z2(this._field, t, n);
      if (r)
        throw r;
    }
    this._arr[t] = z2(this._field, n);
  }
  add(t) {
    if (this.check) {
      const n = Z2(this._field, this._arr.length, t);
      if (n)
        throw n;
    }
    this._arr.push(z2(this._field, t));
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const t of this._arr)
      yield hh(this._field, t, this.check);
  }
  *entries() {
    for (let t = 0; t < this._arr.length; t++)
      yield [t, hh(this._field, this._arr[t], this.check)];
  }
}
class Kre {
  constructor(t, n, r = !0) {
    this.obj = this[Fa] = n ?? {}, this.check = r, this._field = t;
  }
  field() {
    return this._field;
  }
  set(t, n) {
    if (this.check) {
      const r = Gre(this._field, t, n);
      if (r)
        throw r;
    }
    return this.obj[Nm(t)] = Xre(this._field, n), this;
  }
  delete(t) {
    const n = Nm(t), r = Object.prototype.hasOwnProperty.call(this.obj, n);
    return r && delete this.obj[n], r;
  }
  clear() {
    for (const t of Object.keys(this.obj))
      delete this.obj[t];
  }
  get(t) {
    let n = this.obj[Nm(t)];
    return n !== void 0 && (n = yh(this._field, n, this.check)), n;
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.obj, Nm(t));
  }
  *keys() {
    for (const t of Object.keys(this.obj))
      yield q2(t, this._field.mapKey);
  }
  *entries() {
    for (const t of Object.entries(this.obj))
      yield [
        q2(t[0], this._field.mapKey),
        yh(this._field, t[1], this.check)
      ];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const t of Object.values(this.obj))
      yield yh(this._field, t, this.check);
  }
  forEach(t, n) {
    for (const r of this.entries())
      t.call(n, r[1], r[0], this);
  }
}
function Xv(e, t) {
  return jv(t) ? Are(t.message) && !e.oneof && e.fieldKind == "message" ? t.message.value : t.desc.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" ? aV(t.message) : t.message : t;
}
function Wv(e, t, n) {
  return t !== void 0 && (pf(e.message) && !e.oneof && e.fieldKind == "message" ? t = {
    $typeName: e.message.typeName,
    value: Jv(e.message.fields[0], t)
  } : e.message.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" && Io(t) && (t = rV(t))), new nV(e.message, t, n);
}
function z2(e, t) {
  return e.listKind == "message" ? Xv(e, t) : Zv(e, t);
}
function hh(e, t, n) {
  return e.listKind == "message" ? Wv(e, t, n) : Jv(e, t);
}
function Xre(e, t) {
  return e.mapKind == "message" ? Xv(e, t) : Zv(e, t);
}
function yh(e, t, n) {
  return e.mapKind == "message" ? Wv(e, t, n) : t;
}
function Nm(e) {
  return typeof e == "string" || typeof e == "number" ? e : String(e);
}
function q2(e, t) {
  switch (t) {
    case T.STRING:
      return e;
    case T.INT32:
    case T.FIXED32:
    case T.UINT32:
    case T.SFIXED32:
    case T.SINT32: {
      const n = Number.parseInt(e);
      if (Number.isFinite(n))
        return n;
      break;
    }
    case T.BOOL:
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      break;
    case T.UINT64:
    case T.FIXED64:
      try {
        return z.uParse(e);
      } catch {
      }
      break;
    default:
      try {
        return z.parse(e);
      } catch {
      }
      break;
  }
  return e;
}
function Jv(e, t) {
  switch (e.scalar) {
    case T.INT64:
    case T.SFIXED64:
    case T.SINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = z.parse(t));
      break;
    case T.FIXED64:
    case T.UINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = z.uParse(t));
      break;
  }
  return t;
}
function Zv(e, t) {
  switch (e.scalar) {
    case T.INT64:
    case T.SFIXED64:
    case T.SINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = z.parse(t));
      break;
    case T.FIXED64:
    case T.UINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = z.uParse(t));
      break;
  }
  return t;
}
function rV(e) {
  const t = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (Io(e))
    for (const [n, r] of Object.entries(e))
      t.fields[n] = sV(r);
  return t;
}
function aV(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = oV(r);
  return t;
}
function oV(e) {
  switch (e.kind.case) {
    case "structValue":
      return aV(e.kind.value);
    case "listValue":
      return e.kind.value.values.map(oV);
    case "nullValue":
    case void 0:
      return null;
    default:
      return e.kind.value;
  }
}
function sV(e) {
  const t = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof e) {
    case "number":
      t.kind = { case: "numberValue", value: e };
      break;
    case "string":
      t.kind = { case: "stringValue", value: e };
      break;
    case "boolean":
      t.kind = { case: "boolValue", value: e };
      break;
    case "object":
      if (e === null)
        t.kind = { case: "nullValue", value: 0 };
      else if (Array.isArray(e)) {
        const n = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(e))
          for (const r of e)
            n.values.push(sV(r));
        t.kind = {
          case: "listValue",
          value: n
        };
      } else
        t.kind = {
          case: "structValue",
          value: rV(e)
        };
      break;
  }
  return t;
}
function Hv(e) {
  const t = Wre();
  let n = e.length * 3 / 4;
  e[e.length - 2] == "=" ? n -= 2 : e[e.length - 1] == "=" && (n -= 1);
  let r = new Uint8Array(n), a = 0, o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++) {
    if (s = t[e.charCodeAt(u)], s === void 0)
      switch (e[u]) {
        // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
        case "=":
          o = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string");
      }
    switch (o) {
      case 0:
        i = s, o = 1;
        break;
      case 1:
        r[a++] = i << 2 | (s & 48) >> 4, i = s, o = 2;
        break;
      case 2:
        r[a++] = (i & 15) << 4 | (s & 60) >> 2, i = s, o = 3;
        break;
      case 3:
        r[a++] = (i & 3) << 6 | s, o = 0;
        break;
    }
  }
  if (o == 1)
    throw Error("invalid base64 string");
  return r.subarray(0, a);
}
function iV(e, t = "std") {
  const n = uV(t), r = t == "std";
  let a = "", o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++)
    switch (s = e[u], o) {
      case 0:
        a += n[s >> 2], i = (s & 3) << 4, o = 1;
        break;
      case 1:
        a += n[i | s >> 4], i = (s & 15) << 2, o = 2;
        break;
      case 2:
        a += n[i | s >> 6], a += n[s & 63], o = 0;
        break;
    }
  return o && (a += n[i], r && (a += "=", o == 1 && (a += "="))), a;
}
let Em, Q2, oi;
function uV(e) {
  return Em || (Em = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), Q2 = Em.slice(0, -2).concat("-", "_")), e == "url" ? (
    // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
    Q2
  ) : Em;
}
function Wre() {
  if (!oi) {
    oi = [];
    const e = uV("std");
    for (let t = 0; t < e.length; t++)
      oi[e[t].charCodeAt(0)] = t;
    oi[45] = e.indexOf("+"), oi[95] = e.indexOf("/");
  }
  return oi;
}
function Ml(e) {
  let t = !1;
  const n = [];
  for (let r = 0; r < e.length; r++) {
    let a = e.charAt(r);
    switch (a) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        n.push(a), t = !1;
        break;
      default:
        t && (t = !1, a = a.toUpperCase()), n.push(a);
        break;
    }
  }
  return n.join("");
}
const Jre = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function Cl(e) {
  return Jre.has(e) ? e + "$" : e;
}
function zv(e) {
  for (const t of e.field)
    Gl(t, "jsonName") || (t.jsonName = Ml(t.name));
  e.nestedType.forEach(zv);
}
function Zre(e, t) {
  const n = e.values.find((r) => r.name === t);
  if (!n)
    throw new Error(`cannot parse ${e} default value: ${t}`);
  return n.number;
}
function Hre(e, t) {
  switch (e) {
    case T.STRING:
      return t;
    case T.BYTES: {
      const n = zre(t);
      if (n === !1)
        throw new Error(`cannot parse ${T[e]} default value: ${t}`);
      return n;
    }
    case T.INT64:
    case T.SFIXED64:
    case T.SINT64:
      return z.parse(t);
    case T.UINT64:
    case T.FIXED64:
      return z.uParse(t);
    case T.DOUBLE:
    case T.FLOAT:
      switch (t) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(t);
      }
    case T.BOOL:
      return t === "true";
    case T.INT32:
    case T.UINT32:
    case T.SINT32:
    case T.FIXED32:
    case T.SFIXED32:
      return parseInt(t, 10);
  }
}
function zre(e) {
  const t = [], n = {
    tail: e,
    c: "",
    next() {
      return this.tail.length == 0 ? !1 : (this.c = this.tail[0], this.tail = this.tail.substring(1), !0);
    },
    take(r) {
      if (this.tail.length >= r) {
        const a = this.tail.substring(0, r);
        return this.tail = this.tail.substring(r), a;
      }
      return !1;
    }
  };
  for (; n.next(); )
    switch (n.c) {
      case "\\":
        if (n.next())
          switch (n.c) {
            case "\\":
              t.push(n.c.charCodeAt(0));
              break;
            case "b":
              t.push(8);
              break;
            case "f":
              t.push(12);
              break;
            case "n":
              t.push(10);
              break;
            case "r":
              t.push(13);
              break;
            case "t":
              t.push(9);
              break;
            case "v":
              t.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 8);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "x": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "u": {
              const r = n.c, a = n.take(4);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              const s = new Uint8Array(4);
              new DataView(s.buffer).setInt32(0, o, !0), t.push(s[0], s[1], s[2], s[3]);
              break;
            }
            case "U": {
              const r = n.c, a = n.take(8);
              if (a === !1)
                return !1;
              const o = z.uEnc(r + a), s = new Uint8Array(8), i = new DataView(s.buffer);
              i.setInt32(0, o.lo, !0), i.setInt32(4, o.hi, !0), t.push(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
              break;
            }
          }
        break;
      default:
        t.push(n.c.charCodeAt(0));
    }
  return new Uint8Array(t);
}
function* uN(e) {
  switch (e.kind) {
    case "file":
      for (const t of e.messages)
        yield t, yield* uN(t);
      yield* e.enums, yield* e.services, yield* e.extensions;
      break;
    case "message":
      for (const t of e.nestedMessages)
        yield t, yield* uN(t);
      yield* e.nestedEnums, yield* e.nestedExtensions;
      break;
  }
}
function lV(...e) {
  const t = qre();
  if (!e.length)
    return t;
  if ("$typeName" in e[0] && e[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const n of e[0].file)
      a3(n, t);
    return t;
  }
  if ("$typeName" in e[0]) {
    let n = function(s) {
      const i = [];
      for (const u of s.dependency) {
        if (t.getFile(u) != null || o.has(u))
          continue;
        const l = a(u);
        if (!l)
          throw new Error(`Unable to resolve ${u}, imported by ${s.name}`);
        "kind" in l ? t.addFile(l, !1, !0) : (o.add(l.name), i.push(l));
      }
      return i.concat(...i.map(n));
    };
    const r = e[0], a = e[1], o = /* @__PURE__ */ new Set();
    for (const s of [r, ...n(r)].reverse())
      a3(s, t);
  } else
    for (const n of e)
      for (const r of n.files)
        t.addFile(r);
  return t;
}
function qre() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    kind: "registry",
    types: e,
    extendees: t,
    [Symbol.iterator]() {
      return e.values();
    },
    get files() {
      return n.values();
    },
    addFile(r, a, o) {
      if (n.set(r.proto.name, r), !a)
        for (const s of uN(r))
          this.add(s);
      if (o)
        for (const s of r.dependencies)
          this.addFile(s, a, o);
    },
    add(r) {
      if (r.kind == "extension") {
        let a = t.get(r.extendee.typeName);
        a || t.set(
          r.extendee.typeName,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = /* @__PURE__ */ new Map()
        ), a.set(r.number, r);
      }
      e.set(r.typeName, r);
    },
    get(r) {
      return e.get(r);
    },
    getFile(r) {
      return n.get(r);
    },
    getMessage(r) {
      const a = e.get(r);
      return a?.kind == "message" ? a : void 0;
    },
    getEnum(r) {
      const a = e.get(r);
      return a?.kind == "enum" ? a : void 0;
    },
    getExtension(r) {
      const a = e.get(r);
      return a?.kind == "extension" ? a : void 0;
    },
    getExtensionFor(r, a) {
      var o;
      return (o = t.get(r.typeName)) === null || o === void 0 ? void 0 : o.get(a);
    },
    getService(r) {
      const a = e.get(r);
      return a?.kind == "service" ? a : void 0;
    }
  };
}
const Qre = 998, eae = 999, tae = 9, Kl = 10, Xu = 11, nae = 12, e3 = 14, qv = 3, rae = 2, t3 = 1, aae = 0, n3 = 1, r3 = 2, oae = 3, sae = 1, iae = 2, uae = 1, cV = {
  // EDITION_PROTO2
  998: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 2,
    // CLOSED,
    repeatedFieldEncoding: 2,
    // EXPANDED,
    utf8Validation: 3,
    // NONE,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 2,
    // LEGACY_BEST_EFFORT,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_PROTO3
  999: {
    fieldPresence: 2,
    // IMPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2023
  1e3: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2024
  1001: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 1,
    // STYLE2024,
    defaultSymbolVisibility: 2
    // EXPORT_TOP_LEVEL,
  }
};
function a3(e, t) {
  var n, r;
  const a = {
    kind: "file",
    proto: e,
    deprecated: (r = (n = e.options) === null || n === void 0 ? void 0 : n.deprecated) !== null && r !== void 0 ? r : !1,
    edition: mae(e),
    name: e.name.replace(/\.proto$/, ""),
    dependencies: dae(e, t),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${e.name}`;
    }
  }, o = /* @__PURE__ */ new Map(), s = {
    get(i) {
      return o.get(i);
    },
    add(i) {
      var u;
      ir(((u = i.proto.options) === null || u === void 0 ? void 0 : u.mapEntry) === !0), o.set(i.typeName, i);
    }
  };
  for (const i of e.enumType)
    fV(i, a, void 0, t);
  for (const i of e.messageType)
    mV(i, a, void 0, t, s);
  for (const i of e.service)
    lae(i, a, t);
  lN(a, t);
  for (const i of o.values())
    cN(i, t, s);
  for (const i of a.messages)
    cN(i, t, s), lN(i, t);
  t.addFile(a, !0);
}
function lN(e, t) {
  switch (e.kind) {
    case "file":
      for (const n of e.proto.extension) {
        const r = fN(n, e, t);
        e.extensions.push(r), t.add(r);
      }
      break;
    case "message":
      for (const n of e.proto.extension) {
        const r = fN(n, e, t);
        e.nestedExtensions.push(r), t.add(r);
      }
      for (const n of e.nestedMessages)
        lN(n, t);
      break;
  }
}
function cN(e, t, n) {
  const r = e.proto.oneofDecl.map((o) => fae(o, e)), a = /* @__PURE__ */ new Set();
  for (const o of e.proto.field) {
    const s = gae(o, r), i = fN(o, e, t, s, n);
    e.fields.push(i), e.field[i.localName] = i, s === void 0 ? e.members.push(i) : (s.fields.push(i), a.has(s) || (a.add(s), e.members.push(s)));
  }
  for (const o of r.filter((s) => a.has(s)))
    e.oneofs.push(o);
  for (const o of e.nestedMessages)
    cN(o, t, n);
}
function fV(e, t, n, r) {
  var a, o, s, i, u;
  const l = pae(e.name, e.value), c = {
    kind: "enum",
    proto: e,
    deprecated: (o = (a = e.options) === null || a === void 0 ? void 0 : a.deprecated) !== null && o !== void 0 ? o : !1,
    file: t,
    parent: n,
    open: !0,
    name: e.name,
    typeName: Yb(e, n, t),
    value: {},
    values: [],
    sharedPrefix: l,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  c.open = Eae(c), r.add(c);
  for (const f of e.value) {
    const d = f.name;
    c.values.push(
      // biome-ignore lint/suspicious/noAssignInExpressions: no
      c.value[f.number] = {
        kind: "enum_value",
        proto: f,
        deprecated: (i = (s = f.options) === null || s === void 0 ? void 0 : s.deprecated) !== null && i !== void 0 ? i : !1,
        parent: c,
        name: d,
        localName: Cl(l == null ? d : d.substring(l.length)),
        number: f.number,
        toString() {
          return `enum value ${c.typeName}.${d}`;
        }
      }
    );
  }
  ((u = n?.nestedEnums) !== null && u !== void 0 ? u : t.enums).push(c);
}
function mV(e, t, n, r, a) {
  var o, s, i, u;
  const l = {
    kind: "message",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    file: t,
    parent: n,
    name: e.name,
    typeName: Yb(e, n, t),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  ((i = e.options) === null || i === void 0 ? void 0 : i.mapEntry) === !0 ? a.add(l) : (((u = n?.nestedMessages) !== null && u !== void 0 ? u : t.messages).push(l), r.add(l));
  for (const c of e.enumType)
    fV(c, t, l, r);
  for (const c of e.nestedType)
    mV(c, t, l, r, a);
}
function lae(e, t, n) {
  var r, a;
  const o = {
    kind: "service",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    file: t,
    name: e.name,
    typeName: Yb(e, void 0, t),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  t.services.push(o), n.add(o);
  for (const s of e.method) {
    const i = cae(s, o, n);
    o.methods.push(i), o.method[i.localName] = i;
  }
}
function cae(e, t, n) {
  var r, a, o, s;
  let i;
  e.clientStreaming && e.serverStreaming ? i = "bidi_streaming" : e.clientStreaming ? i = "client_streaming" : e.serverStreaming ? i = "server_streaming" : i = "unary";
  const u = n.getMessage(ha(e.inputType)), l = n.getMessage(ha(e.outputType));
  ir(u, `invalid MethodDescriptorProto: input_type ${e.inputType} not found`), ir(l, `invalid MethodDescriptorProto: output_type ${e.inputType} not found`);
  const c = e.name;
  return {
    kind: "rpc",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    parent: t,
    name: c,
    localName: Cl(c.length ? Cl(c[0].toLowerCase() + c.substring(1)) : c),
    methodKind: i,
    input: u,
    output: l,
    idempotency: (s = (o = e.options) === null || o === void 0 ? void 0 : o.idempotencyLevel) !== null && s !== void 0 ? s : aae,
    toString() {
      return `rpc ${t.typeName}.${c}`;
    }
  };
}
function fae(e, t) {
  return {
    kind: "oneof",
    proto: e,
    deprecated: !1,
    parent: t,
    fields: [],
    name: e.name,
    localName: Cl(Ml(e.name)),
    toString() {
      return `oneof ${t.typeName}.${this.name}`;
    }
  };
}
function fN(e, t, n, r, a) {
  var o, s, i;
  const u = a === void 0, l = {
    kind: "field",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    name: e.name,
    number: e.number,
    scalar: void 0,
    message: void 0,
    enum: void 0,
    presence: hae(e, r, u, t),
    listKind: void 0,
    mapKind: void 0,
    mapKey: void 0,
    delimitedEncoding: void 0,
    packed: void 0,
    longAsString: !1,
    getDefaultValue: void 0
  };
  if (u) {
    const m = t.kind == "file" ? t : t.file, p = t.kind == "file" ? void 0 : t, b = Yb(e, p, m);
    l.kind = "extension", l.file = m, l.parent = p, l.oneof = void 0, l.typeName = b, l.jsonName = `[${b}]`, l.toString = () => `extension ${b}`;
    const g = n.getMessage(ha(e.extendee));
    ir(g, `invalid FieldDescriptorProto: extendee ${e.extendee} not found`), l.extendee = g;
  } else {
    const m = t;
    ir(m.kind == "message"), l.parent = m, l.oneof = r, l.localName = r ? Ml(e.name) : Cl(Ml(e.name)), l.jsonName = e.jsonName, l.toString = () => `field ${m.typeName}.${e.name}`;
  }
  const c = e.label, f = e.type, d = (i = e.options) === null || i === void 0 ? void 0 : i.jstype;
  if (c === qv) {
    const m = f == Xu ? a?.get(ha(e.typeName)) : void 0;
    if (m) {
      l.fieldKind = "map";
      const { key: p, value: b } = Nae(m);
      return l.mapKey = p.scalar, l.mapKind = b.fieldKind, l.message = b.message, l.delimitedEncoding = !1, l.enum = b.enum, l.scalar = b.scalar, l;
    }
    switch (l.fieldKind = "list", f) {
      case Xu:
      case Kl:
        l.listKind = "message", l.message = n.getMessage(ha(e.typeName)), ir(l.message), l.delimitedEncoding = o3(e, t);
        break;
      case e3:
        l.listKind = "enum", l.enum = n.getEnum(ha(e.typeName)), ir(l.enum);
        break;
      default:
        l.listKind = "scalar", l.scalar = f, l.longAsString = d == t3;
        break;
    }
    return l.packed = yae(e, t), l;
  }
  switch (f) {
    case Xu:
    case Kl:
      l.fieldKind = "message", l.message = n.getMessage(ha(e.typeName)), ir(l.message, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.delimitedEncoding = o3(e, t), l.getDefaultValue = () => {
      };
      break;
    case e3: {
      const m = n.getEnum(ha(e.typeName));
      ir(m !== void 0, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.fieldKind = "enum", l.enum = n.getEnum(ha(e.typeName)), l.getDefaultValue = () => Gl(e, "defaultValue") ? Zre(m, e.defaultValue) : void 0;
      break;
    }
    default: {
      l.fieldKind = "scalar", l.scalar = f, l.longAsString = d == t3, l.getDefaultValue = () => Gl(e, "defaultValue") ? Hre(f, e.defaultValue) : void 0;
      break;
    }
  }
  return l;
}
function mae(e) {
  switch (e.syntax) {
    case "":
    case "proto2":
      return Qre;
    case "proto3":
      return eae;
    case "editions":
      if (e.edition in cV)
        return e.edition;
      throw new Error(`${e.name}: unsupported edition`);
    default:
      throw new Error(`${e.name}: unsupported syntax "${e.syntax}"`);
  }
}
function dae(e, t) {
  return e.dependency.map((n) => {
    const r = t.getFile(n);
    if (!r)
      throw new Error(`Cannot find ${n}, imported by ${e.name}`);
    return r;
  });
}
function pae(e, t) {
  const n = bae(e) + "_";
  for (const r of t) {
    if (!r.name.toLowerCase().startsWith(n))
      return;
    const a = r.name.substring(n.length);
    if (a.length == 0 || /^\d/.test(a))
      return;
  }
  return n;
}
function bae(e) {
  return (e.substring(0, 1) + e.substring(1).replace(/[A-Z]/g, (t) => "_" + t)).toLowerCase();
}
function Yb(e, t, n) {
  let r;
  return t ? r = `${t.typeName}.${e.name}` : n.proto.package.length > 0 ? r = `${n.proto.package}.${e.name}` : r = `${e.name}`, r;
}
function ha(e) {
  return e.startsWith(".") ? e.substring(1) : e;
}
function gae(e, t) {
  if (!Gl(e, "oneofIndex") || e.proto3Optional)
    return;
  const n = t[e.oneofIndex];
  return ir(n, `invalid FieldDescriptorProto: oneof #${e.oneofIndex} for field #${e.number} not found`), n;
}
function hae(e, t, n, r) {
  if (e.label == rae)
    return oae;
  if (e.label == qv)
    return r3;
  if (t || e.proto3Optional || n)
    return n3;
  const a = eu("fieldPresence", { proto: e, parent: r });
  return a == r3 && (e.type == Xu || e.type == Kl) ? n3 : a;
}
function yae(e, t) {
  if (e.label != qv)
    return !1;
  switch (e.type) {
    case tae:
    case nae:
    case Kl:
    case Xu:
      return !1;
  }
  const n = e.options;
  return n && Gl(n, "packed") ? n.packed : sae == eu("repeatedFieldEncoding", {
    proto: e,
    parent: t
  });
}
function Nae(e) {
  const t = e.fields.find((r) => r.number === 1), n = e.fields.find((r) => r.number === 2);
  return ir(t && t.fieldKind == "scalar" && t.scalar != T.BYTES && t.scalar != T.FLOAT && t.scalar != T.DOUBLE && n && n.fieldKind != "list" && n.fieldKind != "map"), { key: t, value: n };
}
function Eae(e) {
  var t;
  return uae == eu("enumType", {
    proto: e.proto,
    parent: (t = e.parent) !== null && t !== void 0 ? t : e.file
  });
}
function o3(e, t) {
  return e.type == Kl ? !0 : iae == eu("messageEncoding", {
    proto: e,
    parent: t
  });
}
function eu(e, t) {
  var n, r;
  const a = (n = t.proto.options) === null || n === void 0 ? void 0 : n.features;
  if (a) {
    const o = a[e];
    if (o != 0)
      return o;
  }
  if ("kind" in t) {
    if (t.kind == "message")
      return eu(e, (r = t.parent) !== null && r !== void 0 ? r : t.file);
    const o = cV[t.edition];
    if (!o)
      throw new Error(`feature default for edition ${t.edition} not found`);
    return o[e];
  }
  return eu(e, t.parent);
}
function ir(e, t) {
  if (!e)
    throw new Error(t);
}
function vae(e) {
  const t = Tae(e);
  return t.messageType.forEach(zv), lV(t, () => {
  }).getFile(t.name);
}
function Tae(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    syntax: "",
    edition: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, e), { messageType: e.messageType.map(dV), enumType: e.enumType.map(pV) }));
}
function dV(e) {
  var t, n, r, a, o, s, i, u;
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.DescriptorProto",
    name: e.name,
    field: (n = (t = e.field) === null || t === void 0 ? void 0 : t.map(Iae)) !== null && n !== void 0 ? n : [],
    extension: [],
    nestedType: (a = (r = e.nestedType) === null || r === void 0 ? void 0 : r.map(dV)) !== null && a !== void 0 ? a : [],
    enumType: (s = (o = e.enumType) === null || o === void 0 ? void 0 : o.map(pV)) !== null && s !== void 0 ? s : [],
    extensionRange: (u = (i = e.extensionRange) === null || i === void 0 ? void 0 : i.map((l) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, l))) !== null && u !== void 0 ? u : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function Iae(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: !1
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, e), { options: e.options ? wae(e.options) : void 0 }));
}
function wae(e) {
  var t, n, r;
  return Object.assign(/* @__PURE__ */ Object.create({
    ctype: 0,
    packed: !1,
    jstype: 0,
    lazy: !1,
    unverifiedLazy: !1,
    deprecated: !1,
    weak: !1,
    debugRedact: !1,
    retention: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, e), { targets: (t = e.targets) !== null && t !== void 0 ? t : [], editionDefaults: (r = (n = e.editionDefaults) === null || n === void 0 ? void 0 : n.map((a) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, a))) !== null && r !== void 0 ? r : [], uninterpretedOption: [] }));
}
function pV(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: e.name,
    reservedName: [],
    reservedRange: [],
    value: e.value.map((t) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, t))
  });
}
function bf(e, t, ...n) {
  return n.reduce((r, a) => r.nestedMessages[a], e.messages[t]);
}
const _ae = /* @__PURE__ */ vae({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: !0 } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false", options: { deprecated: !0 } }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1e3 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1e3, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: !0 } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1e3 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_UNSTABLE", number: 9999 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] }), Oae = /* @__PURE__ */ bf(_ae, 1);
var s3;
(function(e) {
  e[e.DECLARATION = 0] = "DECLARATION", e[e.UNVERIFIED = 1] = "UNVERIFIED";
})(s3 || (s3 = {}));
var i3;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.GROUP = 10] = "GROUP", e[e.MESSAGE = 11] = "MESSAGE", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.ENUM = 14] = "ENUM", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(i3 || (i3 = {}));
var u3;
(function(e) {
  e[e.OPTIONAL = 1] = "OPTIONAL", e[e.REPEATED = 3] = "REPEATED", e[e.REQUIRED = 2] = "REQUIRED";
})(u3 || (u3 = {}));
var l3;
(function(e) {
  e[e.SPEED = 1] = "SPEED", e[e.CODE_SIZE = 2] = "CODE_SIZE", e[e.LITE_RUNTIME = 3] = "LITE_RUNTIME";
})(l3 || (l3 = {}));
var c3;
(function(e) {
  e[e.STRING = 0] = "STRING", e[e.CORD = 1] = "CORD", e[e.STRING_PIECE = 2] = "STRING_PIECE";
})(c3 || (c3 = {}));
var f3;
(function(e) {
  e[e.JS_NORMAL = 0] = "JS_NORMAL", e[e.JS_STRING = 1] = "JS_STRING", e[e.JS_NUMBER = 2] = "JS_NUMBER";
})(f3 || (f3 = {}));
var m3;
(function(e) {
  e[e.RETENTION_UNKNOWN = 0] = "RETENTION_UNKNOWN", e[e.RETENTION_RUNTIME = 1] = "RETENTION_RUNTIME", e[e.RETENTION_SOURCE = 2] = "RETENTION_SOURCE";
})(m3 || (m3 = {}));
var d3;
(function(e) {
  e[e.TARGET_TYPE_UNKNOWN = 0] = "TARGET_TYPE_UNKNOWN", e[e.TARGET_TYPE_FILE = 1] = "TARGET_TYPE_FILE", e[e.TARGET_TYPE_EXTENSION_RANGE = 2] = "TARGET_TYPE_EXTENSION_RANGE", e[e.TARGET_TYPE_MESSAGE = 3] = "TARGET_TYPE_MESSAGE", e[e.TARGET_TYPE_FIELD = 4] = "TARGET_TYPE_FIELD", e[e.TARGET_TYPE_ONEOF = 5] = "TARGET_TYPE_ONEOF", e[e.TARGET_TYPE_ENUM = 6] = "TARGET_TYPE_ENUM", e[e.TARGET_TYPE_ENUM_ENTRY = 7] = "TARGET_TYPE_ENUM_ENTRY", e[e.TARGET_TYPE_SERVICE = 8] = "TARGET_TYPE_SERVICE", e[e.TARGET_TYPE_METHOD = 9] = "TARGET_TYPE_METHOD";
})(d3 || (d3 = {}));
var mN;
(function(e) {
  e[e.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e[e.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e[e.IDEMPOTENT = 2] = "IDEMPOTENT";
})(mN || (mN = {}));
var p3;
(function(e) {
  e[e.DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", e[e.EXPORT_ALL = 1] = "EXPORT_ALL", e[e.EXPORT_TOP_LEVEL = 2] = "EXPORT_TOP_LEVEL", e[e.LOCAL_ALL = 3] = "LOCAL_ALL", e[e.STRICT = 4] = "STRICT";
})(p3 || (p3 = {}));
var b3;
(function(e) {
  e[e.FIELD_PRESENCE_UNKNOWN = 0] = "FIELD_PRESENCE_UNKNOWN", e[e.EXPLICIT = 1] = "EXPLICIT", e[e.IMPLICIT = 2] = "IMPLICIT", e[e.LEGACY_REQUIRED = 3] = "LEGACY_REQUIRED";
})(b3 || (b3 = {}));
var g3;
(function(e) {
  e[e.ENUM_TYPE_UNKNOWN = 0] = "ENUM_TYPE_UNKNOWN", e[e.OPEN = 1] = "OPEN", e[e.CLOSED = 2] = "CLOSED";
})(g3 || (g3 = {}));
var h3;
(function(e) {
  e[e.REPEATED_FIELD_ENCODING_UNKNOWN = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN", e[e.PACKED = 1] = "PACKED", e[e.EXPANDED = 2] = "EXPANDED";
})(h3 || (h3 = {}));
var y3;
(function(e) {
  e[e.UTF8_VALIDATION_UNKNOWN = 0] = "UTF8_VALIDATION_UNKNOWN", e[e.VERIFY = 2] = "VERIFY", e[e.NONE = 3] = "NONE";
})(y3 || (y3 = {}));
var N3;
(function(e) {
  e[e.MESSAGE_ENCODING_UNKNOWN = 0] = "MESSAGE_ENCODING_UNKNOWN", e[e.LENGTH_PREFIXED = 1] = "LENGTH_PREFIXED", e[e.DELIMITED = 2] = "DELIMITED";
})(N3 || (N3 = {}));
var E3;
(function(e) {
  e[e.JSON_FORMAT_UNKNOWN = 0] = "JSON_FORMAT_UNKNOWN", e[e.ALLOW = 1] = "ALLOW", e[e.LEGACY_BEST_EFFORT = 2] = "LEGACY_BEST_EFFORT";
})(E3 || (E3 = {}));
var v3;
(function(e) {
  e[e.ENFORCE_NAMING_STYLE_UNKNOWN = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN", e[e.STYLE2024 = 1] = "STYLE2024", e[e.STYLE_LEGACY = 2] = "STYLE_LEGACY";
})(v3 || (v3 = {}));
var T3;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SET = 1] = "SET", e[e.ALIAS = 2] = "ALIAS";
})(T3 || (T3 = {}));
var I3;
(function(e) {
  e[e.EDITION_UNKNOWN = 0] = "EDITION_UNKNOWN", e[e.EDITION_LEGACY = 900] = "EDITION_LEGACY", e[e.EDITION_PROTO2 = 998] = "EDITION_PROTO2", e[e.EDITION_PROTO3 = 999] = "EDITION_PROTO3", e[e.EDITION_2023 = 1e3] = "EDITION_2023", e[e.EDITION_2024 = 1001] = "EDITION_2024", e[e.EDITION_UNSTABLE = 9999] = "EDITION_UNSTABLE", e[e.EDITION_1_TEST_ONLY = 1] = "EDITION_1_TEST_ONLY", e[e.EDITION_2_TEST_ONLY = 2] = "EDITION_2_TEST_ONLY", e[e.EDITION_99997_TEST_ONLY = 99997] = "EDITION_99997_TEST_ONLY", e[e.EDITION_99998_TEST_ONLY = 99998] = "EDITION_99998_TEST_ONLY", e[e.EDITION_99999_TEST_ONLY = 99999] = "EDITION_99999_TEST_ONLY", e[e.EDITION_MAX = 2147483647] = "EDITION_MAX";
})(I3 || (I3 = {}));
var w3;
(function(e) {
  e[e.VISIBILITY_UNSET = 0] = "VISIBILITY_UNSET", e[e.VISIBILITY_LOCAL = 1] = "VISIBILITY_LOCAL", e[e.VISIBILITY_EXPORT = 2] = "VISIBILITY_EXPORT";
})(w3 || (w3 = {}));
const _3 = {
  readUnknownFields: !0
};
function Sae(e) {
  return e ? Object.assign(Object.assign({}, _3), e) : _3;
}
function jb(e, t, n) {
  const r = zn(e, void 0, !1);
  return bV(r, new Cv(t), Sae(n), !1, t.byteLength), r.message;
}
function bV(e, t, n, r, a) {
  var o;
  const s = r ? t.len : t.pos + a;
  let i, u;
  const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
  for (; t.pos < s && ([i, u] = t.tag(), !(r && u == le.EndGroup)); ) {
    const c = e.findNumber(i);
    if (!c) {
      const f = t.skip(u, i);
      n.readUnknownFields && l.push({ no: i, wireType: u, data: f });
      continue;
    }
    gV(e, t, c, u, n);
  }
  if (r && (u != le.EndGroup || i !== a))
    throw new Error("invalid end group tag");
  l.length > 0 && e.setUnknown(l);
}
function gV(e, t, n, r, a) {
  var o;
  switch (n.fieldKind) {
    case "scalar":
      e.set(n, tu(t, n.scalar));
      break;
    case "enum":
      const s = tu(t, T.INT32);
      if (n.enum.open)
        e.set(n, s);
      else if (n.enum.values.some((i) => i.number === s))
        e.set(n, s);
      else if (a.readUnknownFields) {
        const i = [];
        iN(s, i);
        const u = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
        u.push({
          no: n.number,
          wireType: r,
          data: new Uint8Array(i)
        }), e.setUnknown(u);
      }
      break;
    case "message":
      e.set(n, Qv(t, a, n, e.get(n)));
      break;
    case "list":
      kae(t, r, e.get(n), a);
      break;
    case "map":
      Dae(t, e.get(n), a);
      break;
  }
}
function Dae(e, t, n) {
  const r = t.field();
  let a, o;
  const s = e.uint32(), i = e.pos + s;
  for (; e.pos < i; ) {
    const [u] = e.tag();
    switch (u) {
      case 1:
        a = tu(e, r.mapKey);
        break;
      case 2:
        switch (r.mapKind) {
          case "scalar":
            o = tu(e, r.scalar);
            break;
          case "enum":
            o = e.int32();
            break;
          case "message":
            o = Qv(e, n, r);
            break;
        }
        break;
    }
  }
  if (a === void 0 && (a = Ms(r.mapKey, !1)), o === void 0)
    switch (r.mapKind) {
      case "scalar":
        o = Ms(r.scalar, !1);
        break;
      case "enum":
        o = r.enum.values[0].number;
        break;
      case "message":
        o = zn(r.message, void 0, !1);
        break;
    }
  t.set(a, o);
}
function kae(e, t, n, r) {
  var a;
  const o = n.field();
  if (o.listKind === "message") {
    n.add(Qv(e, r, o));
    return;
  }
  const s = (a = o.scalar) !== null && a !== void 0 ? a : T.INT32;
  if (!(t == le.LengthDelimited && s != T.STRING && s != T.BYTES)) {
    n.add(tu(e, s));
    return;
  }
  const i = e.uint32() + e.pos;
  for (; e.pos < i; )
    n.add(tu(e, s));
}
function Qv(e, t, n, r) {
  const a = n.delimitedEncoding, o = r ?? zn(n.message, void 0, !1);
  return bV(o, e, t, a, a ? n.number : e.uint32()), o;
}
function tu(e, t) {
  switch (t) {
    case T.STRING:
      return e.string();
    case T.BOOL:
      return e.bool();
    case T.DOUBLE:
      return e.double();
    case T.FLOAT:
      return e.float();
    case T.INT32:
      return e.int32();
    case T.INT64:
      return e.int64();
    case T.UINT64:
      return e.uint64();
    case T.FIXED64:
      return e.fixed64();
    case T.BYTES:
      return e.bytes();
    case T.FIXED32:
      return e.fixed32();
    case T.SFIXED32:
      return e.sfixed32();
    case T.SFIXED64:
      return e.sfixed64();
    case T.SINT64:
      return e.sint64();
    case T.UINT32:
      return e.uint32();
    case T.SINT32:
      return e.sint32();
  }
}
function hV(e, t) {
  var n;
  const r = jb(Oae, Hv(e));
  return r.messageType.forEach(zv), r.dependency = (n = void 0) !== null && n !== void 0 ? n : [], lV(r, (a) => {
  }).getFile(r.name);
}
const Aae = /* @__PURE__ */ hV("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), Lae = /* @__PURE__ */ bf(Aae, 0), Fae = 3, O3 = {
  writeUnknownFields: !0
};
function Uae(e) {
  return e ? Object.assign(Object.assign({}, O3), e) : O3;
}
function yV(e, t, n) {
  return mp(new z6(), Uae(n), zn(e, t)).finish();
}
function mp(e, t, n) {
  var r;
  for (const a of n.sortedFields) {
    if (!n.isSet(a)) {
      if (a.presence == Fae)
        throw new Error(`cannot encode ${a} to binary: required field not set`);
      continue;
    }
    NV(e, t, n, a);
  }
  if (t.writeUnknownFields)
    for (const { no: a, wireType: o, data: s } of (r = n.getUnknown()) !== null && r !== void 0 ? r : [])
      e.tag(a, o).raw(s);
  return e;
}
function NV(e, t, n, r) {
  var a;
  switch (r.fieldKind) {
    case "scalar":
    case "enum":
      dp(e, n.desc.typeName, r.name, (a = r.scalar) !== null && a !== void 0 ? a : T.INT32, r.number, n.get(r));
      break;
    case "list":
      Rae(e, t, r, n.get(r));
      break;
    case "message":
      EV(e, t, r, n.get(r));
      break;
    case "map":
      for (const [o, s] of n.get(r))
        $ae(e, t, r, o, s);
      break;
  }
}
function dp(e, t, n, r, a, o) {
  vV(e.tag(a, Pae(r)), t, n, r, o);
}
function EV(e, t, n, r) {
  n.delimitedEncoding ? mp(e.tag(n.number, le.StartGroup), t, r).tag(n.number, le.EndGroup) : mp(e.tag(n.number, le.LengthDelimited).fork(), t, r).join();
}
function Rae(e, t, n, r) {
  var a;
  if (n.listKind == "message") {
    for (const s of r)
      EV(e, t, n, s);
    return;
  }
  const o = (a = n.scalar) !== null && a !== void 0 ? a : T.INT32;
  if (n.packed) {
    if (!r.size)
      return;
    e.tag(n.number, le.LengthDelimited).fork();
    for (const s of r)
      vV(e, n.parent.typeName, n.name, o, s);
    e.join();
    return;
  }
  for (const s of r)
    dp(e, n.parent.typeName, n.name, o, n.number, s);
}
function $ae(e, t, n, r, a) {
  var o;
  switch (e.tag(n.number, le.LengthDelimited).fork(), dp(e, n.parent.typeName, n.name, n.mapKey, 1, r), n.mapKind) {
    case "scalar":
    case "enum":
      dp(e, n.parent.typeName, n.name, (o = n.scalar) !== null && o !== void 0 ? o : T.INT32, 2, a);
      break;
    case "message":
      mp(e.tag(2, le.LengthDelimited).fork(), t, a).join();
      break;
  }
  e.join();
}
function vV(e, t, n, r, a) {
  try {
    switch (r) {
      case T.STRING:
        e.string(a);
        break;
      case T.BOOL:
        e.bool(a);
        break;
      case T.DOUBLE:
        e.double(a);
        break;
      case T.FLOAT:
        e.float(a);
        break;
      case T.INT32:
        e.int32(a);
        break;
      case T.INT64:
        e.int64(a);
        break;
      case T.UINT64:
        e.uint64(a);
        break;
      case T.FIXED64:
        e.fixed64(a);
        break;
      case T.BYTES:
        e.bytes(a);
        break;
      case T.FIXED32:
        e.fixed32(a);
        break;
      case T.SFIXED32:
        e.sfixed32(a);
        break;
      case T.SFIXED64:
        e.sfixed64(a);
        break;
      case T.SINT64:
        e.sint64(a);
        break;
      case T.UINT32:
        e.uint32(a);
        break;
      case T.SINT32:
        e.sint32(a);
        break;
    }
  } catch (o) {
    throw o instanceof Error ? new Error(`cannot encode field ${t}.${n} to binary: ${o.message}`) : o;
  }
}
function Pae(e) {
  switch (e) {
    case T.BYTES:
    case T.STRING:
      return le.LengthDelimited;
    case T.DOUBLE:
    case T.FIXED64:
    case T.SFIXED64:
      return le.Bit64;
    case T.FIXED32:
    case T.SFIXED32:
    case T.FLOAT:
      return le.Bit32;
    default:
      return le.Varint;
  }
}
function Vae(e, t, n) {
  let r = !1;
  return n || (n = Tr(Lae), r = !0), n.value = yV(e, t), n.typeUrl = jae(t.$typeName), r ? n : void 0;
}
function xae(e, t) {
  if (e.typeUrl === "")
    return !1;
  const n = typeof t == "string" ? t : t.typeName, r = TV(e.typeUrl);
  return n === r;
}
function Yae(e, t) {
  if (e.typeUrl === "")
    return;
  const n = t.kind == "message" ? t : t.getMessage(TV(e.typeUrl));
  if (!(!n || !xae(e, n)))
    return jb(n, e.value);
}
function jae(e) {
  return `type.googleapis.com/${e}`;
}
function TV(e) {
  const t = e.lastIndexOf("/"), n = t >= 0 ? e.substring(t + 1) : e;
  if (!n.length)
    throw new Error(`invalid type url: ${e}`);
  return n;
}
const e1 = /* @__PURE__ */ hV("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), Bae = /* @__PURE__ */ bf(e1, 0), IV = /* @__PURE__ */ bf(e1, 1), Gae = /* @__PURE__ */ bf(e1, 2);
var dN;
(function(e) {
  e[e.NULL_VALUE = 0] = "NULL_VALUE";
})(dN || (dN = {}));
function Mae(e, t) {
  wV(t, e);
  const n = Kae(e.$unknown, t), [r, a, o] = Bb(t);
  for (const s of n)
    gV(r, new Cv(s.data), a, s.wireType, {
      readUnknownFields: !0
    });
  return o();
}
function Cae(e, t, n) {
  var r;
  wV(t, e);
  const a = ((r = e.$unknown) !== null && r !== void 0 ? r : []).filter((l) => l.no !== t.number), [o, s] = Bb(t, n), i = new z6();
  NV(i, { writeUnknownFields: !0 }, o, s);
  const u = new Cv(i.finish());
  for (; u.pos < u.len; ) {
    const [l, c] = u.tag(), f = u.skip(c, l);
    a.push({ no: l, wireType: c, data: f });
  }
  e.$unknown = a;
}
function Kae(e, t) {
  if (e === void 0)
    return [];
  if (t.fieldKind === "enum" || t.fieldKind === "scalar") {
    for (let n = e.length - 1; n >= 0; --n)
      if (e[n].no == t.number)
        return [e[n]];
    return [];
  }
  return e.filter((n) => n.no === t.number);
}
function Bb(e, t) {
  const n = e.typeName, r = Object.assign(Object.assign({}, e), { kind: "field", parent: e.extendee, localName: n }), a = Object.assign(Object.assign({}, e.extendee), { fields: [r], members: [r], oneofs: [] }), o = Tr(a, t !== void 0 ? { [n]: t } : void 0);
  return [
    zn(a, o),
    r,
    () => {
      const s = o[n];
      if (s === void 0) {
        const i = e.message;
        return pf(i) ? Ms(i.fields[0].scalar, i.fields[0].longAsString) : Tr(i);
      }
      return s;
    }
  ];
}
function wV(e, t) {
  if (e.extendee.typeName != t.$typeName)
    throw new Error(`extension ${e.typeName} can only be applied to message ${e.extendee.typeName}`);
}
const Xae = 3, Wae = 2, S3 = {
  alwaysEmitImplicit: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1
};
function Jae(e) {
  return e ? Object.assign(Object.assign({}, S3), e) : S3;
}
function Zae(e, t, n) {
  return gf(zn(e, t), Jae(n));
}
function Hae(e, t, n) {
  var r;
  const a = Zae(e, t, n);
  return JSON.stringify(a, null, (r = n?.prettySpaces) !== null && r !== void 0 ? r : 0);
}
function gf(e, t) {
  var n;
  const r = eoe(e, t);
  if (r !== void 0)
    return r;
  const a = {};
  for (const o of e.sortedFields) {
    if (!e.isSet(o)) {
      if (o.presence == Xae)
        throw new Error(`cannot encode ${o} to JSON: required field not set`);
      if (!t.alwaysEmitImplicit || o.presence !== Wae)
        continue;
    }
    const s = D3(o, e.get(o), t);
    s !== void 0 && (a[Qae(o, t)] = s);
  }
  if (t.registry) {
    const o = /* @__PURE__ */ new Set();
    for (const { no: s } of (n = e.getUnknown()) !== null && n !== void 0 ? n : [])
      if (!o.has(s)) {
        o.add(s);
        const i = t.registry.getExtensionFor(e.desc, s);
        if (!i)
          continue;
        const u = Mae(e.message, i), [l, c] = Bb(i, u), f = D3(c, l.get(c), t);
        f !== void 0 && (a[i.jsonName] = f);
      }
  }
  return a;
}
function D3(e, t, n) {
  switch (e.fieldKind) {
    case "scalar":
      return Gb(e, t);
    case "message":
      return gf(t, n);
    case "enum":
      return t1(e.enum, t, n.enumAsInteger);
    case "list":
      return qae(t, n);
    case "map":
      return zae(t, n);
  }
}
function zae(e, t) {
  const n = e.field(), r = {};
  switch (n.mapKind) {
    case "scalar":
      for (const [a, o] of e)
        r[a] = Gb(n, o);
      break;
    case "message":
      for (const [a, o] of e)
        r[a] = gf(o, t);
      break;
    case "enum":
      for (const [a, o] of e)
        r[a] = t1(n.enum, o, t.enumAsInteger);
      break;
  }
  return t.alwaysEmitImplicit || e.size > 0 ? r : void 0;
}
function qae(e, t) {
  const n = e.field(), r = [];
  switch (n.listKind) {
    case "scalar":
      for (const a of e)
        r.push(Gb(n, a));
      break;
    case "enum":
      for (const a of e)
        r.push(t1(n.enum, a, t.enumAsInteger));
      break;
    case "message":
      for (const a of e)
        r.push(gf(a, t));
      break;
  }
  return t.alwaysEmitImplicit || r.length > 0 ? r : void 0;
}
function t1(e, t, n) {
  var r;
  if (typeof t != "number")
    throw new Error(`cannot encode ${e} to JSON: expected number, got ${Ye(t)}`);
  return e.typeName == "google.protobuf.NullValue" ? null : n ? t : (r = e.value[t]?.name) !== null && r !== void 0 ? r : t;
}
function Gb(e, t) {
  var n, r, a, o, s, i;
  switch (e.scalar) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case T.INT32:
    case T.SFIXED32:
    case T.SINT32:
    case T.FIXED32:
    case T.UINT32:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(n = xo(e, t)) === null || n === void 0 ? void 0 : n.message}`);
      return t;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case T.FLOAT:
    case T.DOUBLE:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(r = xo(e, t)) === null || r === void 0 ? void 0 : r.message}`);
      return Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    // string:
    case T.STRING:
      if (typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(a = xo(e, t)) === null || a === void 0 ? void 0 : a.message}`);
      return t;
    // bool:
    case T.BOOL:
      if (typeof t != "boolean")
        throw new Error(`cannot encode ${e} to JSON: ${(o = xo(e, t)) === null || o === void 0 ? void 0 : o.message}`);
      return t;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case T.UINT64:
    case T.FIXED64:
    case T.INT64:
    case T.SFIXED64:
    case T.SINT64:
      if (typeof t != "bigint" && typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(s = xo(e, t)) === null || s === void 0 ? void 0 : s.message}`);
      return t.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case T.BYTES:
      if (t instanceof Uint8Array)
        return iV(t);
      throw new Error(`cannot encode ${e} to JSON: ${(i = xo(e, t)) === null || i === void 0 ? void 0 : i.message}`);
  }
}
function Qae(e, t) {
  return t.useProtoFieldName ? e.name : e.jsonName;
}
function eoe(e, t) {
  if (e.desc.typeName.startsWith("google.protobuf."))
    switch (e.desc.typeName) {
      case "google.protobuf.Any":
        return toe(e.message, t);
      case "google.protobuf.Timestamp":
        return aoe(e.message);
      case "google.protobuf.Duration":
        return noe(e.message);
      case "google.protobuf.FieldMask":
        return roe(e.message);
      case "google.protobuf.Struct":
        return _V(e.message);
      case "google.protobuf.Value":
        return n1(e.message);
      case "google.protobuf.ListValue":
        return OV(e.message);
      default:
        if (pf(e.desc)) {
          const n = e.desc.fields[0];
          return Gb(n, e.get(n));
        }
        return;
    }
}
function toe(e, t) {
  if (e.typeUrl === "")
    return {};
  const { registry: n } = t;
  let r, a;
  if (n && (r = Yae(e, n), r && (a = n.getMessage(r.$typeName))), !a || !r)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: "${e.typeUrl}" is not in the type registry`);
  let o = gf(zn(a, r), t);
  return (a.typeName.startsWith("google.protobuf.") || o === null || Array.isArray(o) || typeof o != "object") && (o = { value: o }), o["@type"] = e.typeUrl, o;
}
function noe(e) {
  const t = Number(e.seconds), n = e.nanos;
  if (t > 315576e6 || t < -315576e6)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: value out of range`);
  if (t > 0 && n < 0 || t < 0 && n > 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos sign must match seconds sign`);
  let r = e.seconds.toString();
  if (n !== 0) {
    let a = Math.abs(n).toString();
    a = "0".repeat(9 - a.length) + a, a.substring(3) === "000000" ? a = a.substring(0, 3) : a.substring(6) === "000" && (a = a.substring(0, 6)), r += "." + a, n < 0 && t == 0 && (r = "-" + r);
  }
  return r + "s";
}
function roe(e) {
  return e.paths.map((t) => {
    if (t.match(/_[0-9]?_/g) || t.match(/[A-Z]/g))
      throw new Error(`cannot encode message ${e.$typeName} to JSON: lowerCamelCase of path name "` + t + '" is irreversible');
    return Ml(t);
  }).join(",");
}
function _V(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = n1(r);
  return t;
}
function n1(e) {
  switch (e.kind.case) {
    case "nullValue":
      return null;
    case "numberValue":
      if (!Number.isFinite(e.kind.value))
        throw new Error(`${e.$typeName} cannot be NaN or Infinity`);
      return e.kind.value;
    case "boolValue":
      return e.kind.value;
    case "stringValue":
      return e.kind.value;
    case "structValue":
      return _V(e.kind.value);
    case "listValue":
      return OV(e.kind.value);
    default:
      throw new Error(`${e.$typeName} must have a value`);
  }
}
function OV(e) {
  return e.values.map(n1);
}
function aoe(e) {
  const t = Number(e.seconds) * 1e3;
  if (t < Date.parse("0001-01-01T00:00:00Z") || t > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot encode message ${e.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  if (e.nanos < 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be negative`);
  if (e.nanos > 999999999)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be greater than 99999999`);
  let n = "Z";
  if (e.nanos > 0) {
    const r = (e.nanos + 1e9).toString().substring(1);
    r.substring(3) === "000000" ? n = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? n = "." + r.substring(0, 6) + "Z" : n = "." + r + "Z";
  }
  return new Date(t).toISOString().replace(".000Z", n);
}
const k3 = {
  ignoreUnknownFields: !1
};
function ooe(e) {
  return e ? Object.assign(Object.assign({}, k3), e) : k3;
}
function soe(e, t, n) {
  return SV(e, doe(t, e.typeName), n);
}
function SV(e, t, n) {
  const r = zn(e);
  try {
    nu(r, t, ooe(n));
  } catch (a) {
    throw jre(a) ? new Error(`cannot decode ${a.field()} from JSON: ${a.message}`, {
      cause: a
    }) : a;
  }
  return r.message;
}
function nu(e, t, n) {
  var r;
  if (poe(e, t, n))
    return;
  if (t == null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode ${e.desc} from JSON: ${Ye(t)}`);
  const a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const s of e.desc.fields)
    o.set(s.name, s).set(s.jsonName, s);
  for (const [s, i] of Object.entries(t)) {
    const u = o.get(s);
    if (u) {
      if (u.oneof) {
        if (i === null && u.fieldKind == "scalar")
          continue;
        const l = a.get(u.oneof);
        if (l !== void 0)
          throw new Ct(u.oneof, `oneof set multiple times by ${l.name} and ${u.name}`);
        a.set(u.oneof, u);
      }
      A3(e, u, i, n);
    } else {
      let l;
      if (s.startsWith("[") && s.endsWith("]") && // biome-ignore lint/suspicious/noAssignInExpressions: no
      (l = (r = n.registry) === null || r === void 0 ? void 0 : r.getExtension(s.substring(1, s.length - 1))) && l.extendee.typeName === e.desc.typeName) {
        const [c, f, d] = Bb(l);
        A3(c, f, i, n), Cae(e.message, l, d());
      }
      if (!l && !n.ignoreUnknownFields)
        throw new Error(`cannot decode ${e.desc} from JSON: key "${s}" is unknown`);
    }
  }
}
function A3(e, t, n, r) {
  switch (t.fieldKind) {
    case "scalar":
      foe(e, t, n);
      break;
    case "enum":
      coe(e, t, n, r);
      break;
    case "message":
      loe(e, t, n, r);
      break;
    case "list":
      uoe(e.get(t), n, r);
      break;
    case "map":
      ioe(e.get(t), n, r);
      break;
  }
}
function ioe(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (typeof t != "object" || Array.isArray(t))
    throw new Ct(r, "expected object, got " + Ye(t));
  for (const [a, o] of Object.entries(t)) {
    if (o === null && !DV(r))
      throw new Ct(r, "map value must not be null");
    let s;
    switch (r.mapKind) {
      case "message":
        const u = zn(r.message);
        nu(u, o, n), s = u;
        break;
      case "enum":
        if (s = r1(r.enum, o, n.ignoreUnknownFields, !0), s === Mb)
          return;
        break;
      case "scalar":
        s = Kb(r, o, !0);
        break;
    }
    const i = moe(r.mapKey, a);
    e.set(i, s);
  }
}
function uoe(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (!Array.isArray(t))
    throw new Ct(r, "expected Array, got " + Ye(t));
  for (const a of t) {
    if (a === null && !DV(r))
      throw new Ct(r, "list item must not be null");
    switch (r.listKind) {
      case "message":
        const o = zn(r.message);
        nu(o, a, n), e.add(o);
        break;
      case "enum":
        const s = r1(r.enum, a, n.ignoreUnknownFields, !0);
        s !== Mb && e.add(s);
        break;
      case "scalar":
        e.add(Kb(r, a, !0));
        break;
    }
  }
}
function DV(e) {
  var t, n;
  return ((t = e.message) === null || t === void 0 ? void 0 : t.typeName) == "google.protobuf.Value" || ((n = e.enum) === null || n === void 0 ? void 0 : n.typeName) == "google.protobuf.NullValue";
}
function loe(e, t, n, r) {
  if (n === null && t.message.typeName != "google.protobuf.Value") {
    e.clear(t);
    return;
  }
  const a = e.isSet(t) ? e.get(t) : zn(t.message);
  nu(a, n, r), e.set(t, a);
}
function coe(e, t, n, r) {
  const a = r1(t.enum, n, r.ignoreUnknownFields, !1);
  a === Cb ? e.clear(t) : a !== Mb && e.set(t, a);
}
function foe(e, t, n) {
  const r = Kb(t, n, !1);
  r === Cb ? e.clear(t) : e.set(t, r);
}
const Mb = /* @__PURE__ */ Symbol();
function r1(e, t, n, r) {
  if (t === null)
    return e.typeName == "google.protobuf.NullValue" ? 0 : r ? e.values[0].number : Cb;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const a = e.values.find((o) => o.name === t);
      if (a !== void 0)
        return a.number;
      if (n)
        return Mb;
      break;
  }
  throw new Error(`cannot decode ${e} from JSON: ${Ye(t)}`);
}
const Cb = /* @__PURE__ */ Symbol();
function Kb(e, t, n) {
  if (t === null)
    return n ? Ms(e.scalar, !1) : Cb;
  switch (e.scalar) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case T.DOUBLE:
    case T.FLOAT:
      if (t === "NaN")
        return NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (typeof t == "number") {
        if (Number.isNaN(t))
          throw new Ct(e, "unexpected NaN number");
        if (!Number.isFinite(t))
          throw new Ct(e, "unexpected infinite number");
        break;
      }
      if (typeof t == "string") {
        if (t === "" || t.trim().length !== t.length)
          break;
        const r = Number(t);
        if (!Number.isFinite(r))
          break;
        return r;
      }
      break;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case T.INT32:
    case T.FIXED32:
    case T.SFIXED32:
    case T.SINT32:
    case T.UINT32:
      return kV(t);
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case T.BYTES:
      if (typeof t == "string") {
        if (t === "")
          return new Uint8Array(0);
        try {
          return Hv(t);
        } catch (r) {
          const a = r instanceof Error ? r.message : String(r);
          throw new Ct(e, a);
        }
      }
      break;
  }
  return t;
}
function moe(e, t) {
  switch (e) {
    case T.BOOL:
      switch (t) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      return t;
    case T.INT32:
    case T.FIXED32:
    case T.UINT32:
    case T.SFIXED32:
    case T.SINT32:
      return kV(t);
    default:
      return t;
  }
}
function kV(e) {
  if (typeof e == "string") {
    if (e === "" || e.trim().length !== e.length)
      return e;
    const t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
function doe(e, t) {
  try {
    return JSON.parse(e);
  } catch (n) {
    const r = n instanceof Error ? n.message : String(n);
    throw new Error(
      `cannot decode message ${t} from JSON: ${r}`,
      // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
      { cause: n }
    );
  }
}
function poe(e, t, n) {
  if (!e.desc.typeName.startsWith("google.protobuf."))
    return !1;
  switch (e.desc.typeName) {
    case "google.protobuf.Any":
      return boe(e.message, t, n), !0;
    case "google.protobuf.Timestamp":
      return goe(e.message, t), !0;
    case "google.protobuf.Duration":
      return hoe(e.message, t), !0;
    case "google.protobuf.FieldMask":
      return yoe(e.message, t), !0;
    case "google.protobuf.Struct":
      return AV(e.message, t), !0;
    case "google.protobuf.Value":
      return a1(e.message, t), !0;
    case "google.protobuf.ListValue":
      return LV(e.message, t), !0;
    default:
      if (pf(e.desc)) {
        const r = e.desc.fields[0];
        return t === null ? e.clear(r) : e.set(r, Kb(r, t, !0)), !0;
      }
      return !1;
  }
}
function boe(e, t, n) {
  var r;
  if (t === null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: expected object but got ${Ye(t)}`);
  if (Object.keys(t).length == 0)
    return;
  const a = t["@type"];
  if (typeof a != "string" || a == "")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is empty`);
  const o = a.includes("/") ? a.substring(a.lastIndexOf("/") + 1) : a;
  if (!o.length)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is invalid`);
  const s = (r = n.registry) === null || r === void 0 ? void 0 : r.getMessage(o);
  if (!s)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${a} is not in the type registry`);
  const i = zn(s);
  if (o.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(t, "value")) {
    const u = t.value;
    nu(i, u, n);
  } else {
    const u = Object.assign({}, t);
    delete u["@type"], nu(i, u, n);
  }
  Vae(i.desc, i.message, e);
}
function goe(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ye(t)}`);
  const n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
  if (!n)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  const r = Date.parse(
    // biome-ignore format: want this to read well
    n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z")
  );
  if (Number.isNaN(r))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  e.seconds = z.parse(r / 1e3), e.nanos = 0, n[7] && (e.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9);
}
function hoe(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ye(t)}`);
  const n = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
  if (n === null)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ye(t)}`);
  const r = Number(n[1]);
  if (r > 315576e6 || r < -315576e6)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ye(t)}`);
  if (e.seconds = z.parse(r), typeof n[2] != "string")
    return;
  const a = n[2] + "0".repeat(9 - n[2].length);
  e.nanos = parseInt(a), (r < 0 || Object.is(r, -0)) && (e.nanos = -e.nanos);
}
function yoe(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ye(t)}`);
  if (t === "")
    return;
  function n(r) {
    if (r.includes("_"))
      throw new Error(`cannot decode message ${e.$typeName} from JSON: path names must be lowerCamelCase`);
    const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase());
    return a[0] === "_" ? a.substring(1) : a;
  }
  e.paths = t.split(",").map(n);
}
function AV(e, t) {
  if (typeof t != "object" || t == null || Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Ye(t)}`);
  for (const [n, r] of Object.entries(t)) {
    const a = Tr(IV);
    a1(a, r), e.fields[n] = a;
  }
}
function a1(e, t) {
  switch (typeof t) {
    case "number":
      e.kind = { case: "numberValue", value: t };
      break;
    case "string":
      e.kind = { case: "stringValue", value: t };
      break;
    case "boolean":
      e.kind = { case: "boolValue", value: t };
      break;
    case "object":
      if (t === null)
        e.kind = { case: "nullValue", value: dN.NULL_VALUE };
      else if (Array.isArray(t)) {
        const n = Tr(Gae);
        LV(n, t), e.kind = { case: "listValue", value: n };
      } else {
        const n = Tr(Bae);
        AV(n, t), e.kind = { case: "structValue", value: n };
      }
      break;
    default:
      throw new Error(`cannot decode message ${e.$typeName} from JSON ${Ye(t)}`);
  }
  return e;
}
function LV(e, t) {
  if (!Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Ye(t)}`);
  for (const n of t) {
    const r = Tr(IV);
    a1(r, n), e.values.push(r);
  }
}
function pN(e) {
  const t = B[e];
  return typeof t != "string" ? e.toString() : t[0].toLowerCase() + t.substring(1).replace(/[A-Z]/g, (n) => "_" + n.toLowerCase());
}
let vm;
function Noe(e) {
  if (!vm) {
    vm = {};
    for (const t of Object.values(B))
      typeof t != "string" && (vm[pN(t)] = t);
  }
  return vm[e];
}
class ke extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(t, n = B.Unknown, r, a, o) {
    super(Eoe(t, n)), this.name = "ConnectError", Object.setPrototypeOf(this, new.target.prototype), this.rawMessage = t, this.code = n, this.metadata = new Headers(r ?? {}), this.details = a ?? [], this.cause = o;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(t, n = B.Unknown) {
    return t instanceof ke ? t : t instanceof Error ? t.name == "AbortError" || t.name == "TimeoutError" ? new ke(t.message, B.Canceled) : new ke(t.message, n, void 0, void 0, t) : new ke(String(t), n, void 0, void 0, t);
  }
  static [Symbol.hasInstance](t) {
    return t instanceof Error ? Object.getPrototypeOf(t) === ke.prototype ? !0 : t.name === "ConnectError" && "code" in t && typeof t.code == "number" && "metadata" in t && "details" in t && Array.isArray(t.details) && "rawMessage" in t && typeof t.rawMessage == "string" && "cause" in t : !1;
  }
  findDetails(t) {
    const n = t.kind === "message" ? {
      getMessage: (a) => a === t.typeName ? t : void 0
    } : t, r = [];
    for (const a of this.details) {
      if ("desc" in a) {
        n.getMessage(a.desc.typeName) && r.push(Tr(a.desc, a.value));
        continue;
      }
      const o = n.getMessage(a.type);
      if (o)
        try {
          r.push(jb(o, a.value));
        } catch {
        }
    }
    return r;
  }
}
function Eoe(e, t) {
  return e.length ? `[${pN(t)}] ${e}` : `[${pN(t)}]`;
}
function voe(...e) {
  const t = new Headers();
  for (const n of e)
    n.forEach((r, a) => {
      t.append(a, r);
    });
  return t;
}
const L3 = 1;
function Toe(e, t, n = !1) {
  if (t > e) {
    let r = `message size is larger than configured readMaxBytes ${e}`;
    throw n && (r = `message size ${t} is larger than configured readMaxBytes ${e}`), new ke(r, B.ResourceExhausted);
  }
}
function Ioe(e) {
  return new woe(e);
}
class woe {
  constructor(t) {
    this.readMaxBytes = t, this.header = new Uint8Array(5), this.headerView = new DataView(this.header.buffer), this.buf = [];
  }
  get byteLength() {
    return this.buf.reduce((t, n) => t + n.byteLength, 0);
  }
  decode(t) {
    this.buf.push(t);
    const n = [];
    for (; ; ) {
      let r = this.pop();
      if (!r)
        break;
      n.push(r);
    }
    return n;
  }
  // consume an enveloped message
  pop() {
    if (!(!this.env && (this.env = this.head(), !this.env)) && this.cons(this.env.data)) {
      const t = this.env;
      return this.env = void 0, t;
    }
  }
  // consume header
  head() {
    if (!this.cons(this.header))
      return;
    const t = this.headerView.getUint8(0), n = this.headerView.getUint32(1);
    return Toe(this.readMaxBytes, n, !0), {
      flags: t,
      data: new Uint8Array(n)
    };
  }
  // consume from buffer, fill target
  cons(t) {
    const n = t.byteLength;
    if (this.byteLength < n)
      return !1;
    let r = 0;
    for (; r < n; ) {
      const a = this.buf.shift();
      a.byteLength > n - r ? (t.set(a.subarray(0, n - r), r), this.buf.unshift(a.subarray(n - r)), r += n - r) : (t.set(a, r), r += a.byteLength);
    }
    return !0;
  }
}
function _oe(e) {
  let t;
  const n = Ioe(4294967295);
  return new ReadableStream({
    start() {
      t = e.getReader();
    },
    async pull(r) {
      let a = !1;
      for (; !a; ) {
        const o = await t.read();
        if (o.done)
          n.byteLength > 0 && r.error(new ke("protocol error: incomplete envelope", B.InvalidArgument)), r.close();
        else
          for (const s of n.decode(o.value))
            r.enqueue(s), a = !0;
      }
    }
  });
}
function Ooe(e, t) {
  const n = new Uint8Array(t.length + 5);
  n.set(t, 5);
  const r = new DataView(n.buffer, n.byteOffset, n.byteLength);
  return r.setUint8(0, e), r.setUint32(1, t.length), n;
}
function Soe(...e) {
  const t = new AbortController(), n = e.filter((a) => a !== void 0).concat(t.signal);
  for (const a of n) {
    if (a.aborted) {
      r.apply(a);
      break;
    }
    a.addEventListener("abort", r);
  }
  function r() {
    t.signal.aborted || t.abort(FV(this));
    for (const a of n)
      a.removeEventListener("abort", r);
  }
  return t;
}
function Doe(e) {
  const t = new AbortController(), n = () => {
    t.abort(new ke("the operation timed out", B.DeadlineExceeded));
  };
  let r;
  return e !== void 0 && (e <= 0 ? n() : r = setTimeout(n, e)), {
    signal: t.signal,
    cleanup: () => clearTimeout(r)
  };
}
function FV(e) {
  if (!e.aborted)
    return;
  if (e.reason !== void 0)
    return e.reason;
  const t = new Error("This operation was aborted");
  return t.name = "AbortError", t;
}
function F3() {
  return {
    get(e) {
      return e.id in this ? this[e.id] : e.defaultValue;
    },
    set(e, t) {
      return this[e.id] = t, this;
    },
    delete(e) {
      return delete this[e.id], this;
    }
  };
}
function U3(e, t) {
  return e.toString().replace(/\/?$/, `/${t.parent.typeName}/${t.name}`);
}
function UV(e, t) {
  return Tr(e, t);
}
function koe(e, t) {
  function n(r) {
    return r.done === !0 ? r : {
      done: r.done,
      value: UV(e, r.value)
    };
  }
  return {
    [Symbol.asyncIterator]() {
      const r = t[Symbol.asyncIterator](), a = {
        next: () => r.next().then(n)
      };
      return r.throw !== void 0 && (a.throw = (o) => r.throw(o).then(n)), r.return !== void 0 && (a.return = (o) => r.return(o).then(n)), a;
    }
  };
}
function RV(e, t) {
  if (!t)
    return e;
  for (const n of t.concat().reverse())
    e = n(e);
  return e;
}
function $V(e) {
  var t;
  const n = Object.assign({}, e);
  return (t = n.ignoreUnknownFields) !== null && t !== void 0 || (n.ignoreUnknownFields = !0), n;
}
function R3(e, t, n, r) {
  const a = t ? $3(e.input, r) : P3(e.input, n);
  return { parse: (t ? $3(e.output, r) : P3(e.output, n)).parse, serialize: a.serialize };
}
function $3(e, t) {
  return {
    parse(n) {
      try {
        return jb(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new ke(`parse binary: ${a}`, B.Internal);
      }
    },
    serialize(n) {
      try {
        return yV(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new ke(`serialize binary: ${a}`, B.Internal);
      }
    }
  };
}
function P3(e, t) {
  var n, r;
  const a = (n = t?.textEncoder) !== null && n !== void 0 ? n : new TextEncoder(), o = (r = t?.textDecoder) !== null && r !== void 0 ? r : new TextDecoder(), s = $V(t);
  return {
    parse(i) {
      try {
        const u = o.decode(i);
        return soe(e, u, s);
      } catch (u) {
        throw ke.from(u, B.InvalidArgument);
      }
    },
    serialize(i) {
      try {
        const u = Hae(e, i, s);
        return a.encode(u);
      } catch (u) {
        throw ke.from(u, B.Internal);
      }
    }
  };
}
const Aoe = /^application\/(connect\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i, Loe = "application/proto", Foe = "application/json", Uoe = "application/connect+proto", Roe = "application/connect+json";
function $oe(e) {
  const t = e?.match(Aoe);
  if (!t)
    return;
  const n = !!t[1], r = !!t[3];
  return { stream: n, binary: r };
}
function PV(e, t, n) {
  var r;
  if (t && new Headers(t).forEach((i, u) => n.metadata.append(u, i)), typeof e != "object" || e == null || Array.isArray(e))
    throw n;
  let a = n.code;
  "code" in e && typeof e.code == "string" && (a = (r = Noe(e.code)) !== null && r !== void 0 ? r : a);
  const o = e.message;
  if (o != null && typeof o != "string")
    throw n;
  const s = new ke(o ?? "", a, t);
  if ("details" in e && Array.isArray(e.details))
    for (const i of e.details) {
      if (i === null || typeof i != "object" || Array.isArray(i) || typeof i.type != "string" || typeof i.value != "string")
        throw n;
      try {
        s.details.push({
          type: i.type,
          value: Hv(i.value),
          debug: i.debug
        });
      } catch {
        throw n;
      }
    }
  return s;
}
const V3 = 2;
function Poe(e) {
  const t = new ke("invalid end stream", B.Unknown);
  let n;
  try {
    n = JSON.parse(typeof e == "string" ? e : new TextDecoder().decode(e));
  } catch {
    throw t;
  }
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw t;
  const r = new Headers();
  if ("metadata" in n) {
    if (typeof n.metadata != "object" || n.metadata == null || Array.isArray(n.metadata))
      throw t;
    for (const [o, s] of Object.entries(n.metadata)) {
      if (!Array.isArray(s) || s.some((i) => typeof i != "string"))
        throw t;
      for (const i of s)
        r.append(o, i);
    }
  }
  const a = "error" in n && n.error != null ? PV(n.error, r, t) : void 0;
  return { metadata: r, error: a };
}
const pp = "Content-Type", Voe = "Content-Length", x3 = "Content-Encoding", xoe = "Accept-Encoding", Yoe = "Connect-Timeout-Ms", VV = "Connect-Protocol-Version", joe = "User-Agent";
function Boe(e) {
  switch (e) {
    case 400:
      return B.Internal;
    case 401:
      return B.Unauthenticated;
    case 403:
      return B.PermissionDenied;
    case 404:
      return B.Unimplemented;
    case 429:
      return B.Unavailable;
    case 502:
      return B.Unavailable;
    case 503:
      return B.Unavailable;
    case 504:
      return B.Unavailable;
    default:
      return B.Unknown;
  }
}
function Y3(e) {
  const t = new Headers(), n = new Headers();
  return e.forEach((r, a) => {
    a.toLowerCase().startsWith("trailer-") ? n.append(a.substring(8), r) : t.append(a, r);
  }), [t, n];
}
const xV = "1";
function j3(e, t, n, r, a) {
  const o = new Headers(r ?? {});
  return n !== void 0 && o.set(Yoe, `${n}`), o.set(pp, e == "unary" ? t ? Loe : Foe : t ? Uoe : Roe), o.set(VV, xV), o.has(joe), o;
}
function B3(e, t, n, r) {
  const a = r.get(pp), o = $oe(a);
  if (n !== 200) {
    const i = new ke(`HTTP ${n}`, Boe(n), r);
    if (e == "unary" && o && !o.binary)
      return { isUnaryError: !0, unaryError: i };
    throw i;
  }
  const s = {
    binary: t,
    stream: e !== "unary"
  };
  if (o?.binary !== s.binary || o.stream !== s.stream)
    throw new ke(`unsupported content type ${a}`, o === void 0 ? B.Unknown : B.Internal, r);
  return { isUnaryError: !1 };
}
const G3 = "application/";
function Goe(e, t) {
  return t ? iV(e, "url") : encodeURIComponent(new TextDecoder().decode(e));
}
function Moe(e, t, n) {
  let r = `?connect=v${xV}`;
  const a = e.header.get(pp);
  a?.indexOf(G3) === 0 && (r += "&encoding=" + encodeURIComponent(a.slice(G3.length)));
  const o = e.header.get(x3);
  o !== null && o !== "identity" && (r += "&compression=" + encodeURIComponent(o), n = !0), n && (r += "&base64=1"), r += "&message=" + Goe(t, n);
  const s = e.url + r, i = new Headers(e.header);
  for (const u of [
    VV,
    pp,
    Voe,
    x3,
    xoe
  ])
    i.delete(u);
  return Object.assign(Object.assign({}, e), {
    requestMethod: "GET",
    url: s,
    header: i
  });
}
function Coe(e) {
  const t = RV(e.next, e.interceptors), [n, r, a] = YV(e), o = Object.assign(Object.assign({}, e.req), { message: UV(e.req.method.input, e.req.message), signal: n });
  return t(o).then((s) => (a(), s), r);
}
function Koe(e) {
  const t = RV(e.next, e.interceptors), [n, r, a] = YV(e), o = Object.assign(Object.assign({}, e.req), { message: koe(e.req.method.input, e.req.message), signal: n });
  let s = !1;
  return n.addEventListener("abort", function() {
    var i, u;
    const l = e.req.message[Symbol.asyncIterator]();
    s || (i = l.throw) === null || i === void 0 || i.call(l, this.reason).catch(() => {
    }), (u = l.return) === null || u === void 0 || u.call(l).catch(() => {
    });
  }), t(o).then((i) => Object.assign(Object.assign({}, i), { message: {
    [Symbol.asyncIterator]() {
      const u = i.message[Symbol.asyncIterator]();
      return {
        next() {
          return u.next().then((l) => (l.done == !0 && (s = !0, a()), l), r);
        }
        // We deliberately omit throw/return.
      };
    }
  } }), r);
}
function YV(e) {
  const { signal: t, cleanup: n } = Doe(e.timeoutMs), r = Soe(e.signal, t);
  return [
    r.signal,
    function(a) {
      const o = ke.from(t.aborted ? FV(t) : a);
      return r.abort(o), n(), Promise.reject(o);
    },
    function() {
      n(), r.abort();
    }
  ];
}
function Xoe() {
  try {
    new Headers();
  } catch {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}
var Xl = function(e) {
  return this instanceof Xl ? (this.v = e, this) : new Xl(e);
}, Woe = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof Xl ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
const M3 = {
  redirect: "error"
};
function Joe(e) {
  var t;
  Xoe();
  const n = (t = e.useBinaryFormat) !== null && t !== void 0 ? t : !1;
  return {
    async unary(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = R3(r, n, e.jsonOptions, e.binaryOptions);
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await Coe({
        interceptors: e.interceptors,
        signal: a,
        timeoutMs: o,
        req: {
          stream: !1,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: U3(e.baseUrl, r),
          header: j3(r.methodKind, n, o, s),
          contextValues: u ?? F3(),
          message: i
        },
        next: async (f) => {
          var d;
          const m = e.useHttpGet === !0 && r.idempotency === mN.NO_SIDE_EFFECTS;
          let p = null;
          m ? f = Moe(f, l(f.message), n) : p = l(f.message);
          const b = await ((d = e.fetch) !== null && d !== void 0 ? d : globalThis.fetch)(f.url, Object.assign(Object.assign({}, M3), { method: f.requestMethod, headers: f.header, signal: f.signal, body: p })), { isUnaryError: g, unaryError: S } = B3(r.methodKind, n, b.status, b.headers);
          if (g)
            throw PV(await b.json(), voe(...Y3(b.headers)), S);
          const [D, k] = Y3(b.headers);
          return {
            stream: !1,
            service: r.parent,
            method: r,
            header: D,
            message: n ? c(new Uint8Array(await b.arrayBuffer())) : SV(r.output, await b.json(), $V(e.jsonOptions)),
            trailer: k
          };
        }
      });
    },
    async stream(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = R3(r, n, e.jsonOptions, e.binaryOptions);
      function f(m, p, b, g) {
        return Woe(this, arguments, function* () {
          const S = _oe(m).getReader();
          let D = !1;
          for (; ; ) {
            const k = yield Xl(S.read());
            if (k.done)
              break;
            const { flags: U, data: R } = k.value;
            if ((U & L3) === L3)
              throw new ke("protocol error: received unsupported compressed output", B.Internal);
            if ((U & V3) === V3) {
              D = !0;
              const F = Poe(R);
              if (F.error) {
                const A = F.error;
                throw b.forEach((L, re) => {
                  A.metadata.append(re, L);
                }), A;
              }
              F.metadata.forEach((A, L) => p.set(L, A));
              continue;
            }
            yield yield Xl(c(R));
          }
          if ("throwIfAborted" in g && g.throwIfAborted(), !D)
            throw "missing EndStreamResponse";
        });
      }
      async function d(m) {
        if (r.methodKind != "server_streaming")
          throw "The fetch API does not support streaming request bodies";
        const p = await m[Symbol.asyncIterator]().next();
        if (p.done == !0)
          throw "missing request message";
        return Ooe(0, l(p.value));
      }
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await Koe({
        interceptors: e.interceptors,
        timeoutMs: o,
        signal: a,
        req: {
          stream: !0,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: U3(e.baseUrl, r),
          header: j3(r.methodKind, n, o, s),
          contextValues: u ?? F3(),
          message: i
        },
        next: async (m) => {
          var p;
          const b = await ((p = e.fetch) !== null && p !== void 0 ? p : globalThis.fetch)(m.url, Object.assign(Object.assign({}, M3), { method: m.requestMethod, headers: m.header, signal: m.signal, body: await d(m.message) }));
          if (B3(r.methodKind, n, b.status, b.headers), b.body === null)
            throw "missing response body";
          const g = new Headers();
          return Object.assign(Object.assign({}, m), { header: b.headers, trailer: g, message: f(b.body, g, b.headers, m.signal) });
        }
      });
    }
  };
}
Joe({
  baseUrl: "/api",
  useBinaryFormat: !0,
  fetch: (e, t) => {
    const n = t?.headers ?? {};
    return fetch(e, {
      ...t,
      headers: {
        ...n,
        "qt-widget-id": window.qtWidgetId
      }
    });
  }
});
const ht = /* @__PURE__ */ Symbol(), Zoe = !1;
var Hoe = Array.isArray, zoe = Array.prototype.indexOf, Nh = Object.getOwnPropertyDescriptor, qoe = Object.prototype, Qoe = Array.prototype, ese = Object.getPrototypeOf;
function tse(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function nse() {
  var e, t, n = new Promise((r, a) => {
    e = r, t = a;
  });
  return { promise: n, resolve: e, reject: t };
}
const cn = 2, rse = 4, ase = 1 << 24, _u = 16, hf = 32, yf = 64, o1 = 128, zr = 512, Ot = 1024, Ir = 2048, qr = 4096, sd = 8192, ys = 16384, ose = 32768, C3 = 1 << 17, jV = 1 << 18, Cs = 32768, bN = 1 << 21, BV = 1 << 22, Wl = 1 << 23, Eh = /* @__PURE__ */ Symbol("$state"), GV = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function sse() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function ise() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function use() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function lse() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function cse(e) {
  return e === this.v;
}
let fse = !1;
function MV() {
  return !0;
}
let vi = [];
function mse() {
  var e = vi;
  vi = [], tse(e);
}
function dse(e) {
  if (vi.length === 0) {
    var t = vi;
    queueMicrotask(() => {
      t === vi && mse();
    });
  }
  vi.push(e);
}
function pse(e) {
  var t = Kt;
  if (t === null)
    return Ee.f |= Wl, e;
  if ((t.f & ose) === 0) {
    if ((t.f & o1) === 0)
      throw e;
    t.b.error(e);
  } else
    CV(e, t);
}
function CV(e, t) {
  for (; t !== null; ) {
    if ((t.f & o1) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e;
}
const Tm = /* @__PURE__ */ new Set();
let He = null, Bn = null, Vr = [], s1 = null, gN = !1;
class Jl {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #e = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #i = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    Vr = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const r of t)
      this.#u(r, n);
    this.is_fork || this.#c(), this.is_deferred() ? (this.#n(n.effects), this.#n(n.render_effects)) : (He = null, K3(n.render_effects), K3(n.effects), this.#i?.resolve()), Bn = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #u(t, n) {
    t.f ^= Ot;
    for (var r = t.first; r !== null; ) {
      var a = r.f, o = (a & (hf | yf)) !== 0, s = o && (a & Ot) !== 0, i = s || (a & sd) !== 0 || this.skipped_effects.has(r);
      if ((r.f & o1) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: []
      }), !i && r.fn !== null) {
        o ? r.f ^= Ot : (a & rse) !== 0 ? n.effects.push(r) : Ef(r) && ((r.f & _u) !== 0 && this.#o.add(r), Np(r));
        var u = r.first;
        if (u !== null) {
          r = u;
          continue;
        }
      }
      var l = r.parent;
      for (r = r.next; r === null && l !== null; )
        l === n.effect && (this.#n(n.effects), this.#n(n.render_effects), n = /** @type {EffectTarget} */
        n.parent), r = l.next, l = l.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #n(t) {
    for (const n of t)
      (n.f & Ir) !== 0 ? this.#o.add(n) : (n.f & qr) !== 0 && this.#s.add(n), this.#l(n.deps), Xt(n, Ot);
  }
  /**
   * @param {Value[] | null} deps
   */
  #l(t) {
    if (t !== null)
      for (const n of t)
        (n.f & cn) === 0 || (n.f & Cs) === 0 || (n.f ^= Cs, this.#l(
          /** @type {Derived} */
          n.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.previous.has(t) || this.previous.set(t, n), (t.f & Wl) === 0 && (this.current.set(t, t.v), Bn?.set(t, t.v));
  }
  activate() {
    He = this, this.apply();
  }
  deactivate() {
    He === this && (He = null, Bn = null);
  }
  flush() {
    if (this.activate(), Vr.length > 0) {
      if (bse(), He !== null && He !== this)
        return;
    } else this.#e === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const t of this.#a) t(this);
    this.#a.clear();
  }
  #c() {
    if (this.#t === 0) {
      for (const t of this.#r) t();
      this.#r.clear();
    }
    this.#e === 0 && this.#f();
  }
  #f() {
    if (Tm.size > 1) {
      this.previous.clear();
      var t = Bn, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const o of Tm) {
        if (o === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [u, l] of this.current) {
          if (o.current.has(u))
            if (n && l !== o.current.get(u))
              o.current.set(u, l);
            else
              continue;
          s.push(u);
        }
        if (s.length === 0)
          continue;
        const i = [...o.current.keys()].filter((u) => !this.current.has(u));
        if (i.length > 0) {
          var a = Vr;
          Vr = [];
          const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            KV(c, i, u, l);
          if (Vr.length > 0) {
            He = o, o.apply();
            for (const c of Vr)
              o.#u(c, r);
            o.deactivate();
          }
          Vr = a;
        }
      }
      He = null, Bn = t;
    }
    this.committed = !0, Tm.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(t) {
    this.#e += 1, t && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(t) {
    this.#e -= 1, t && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const t of this.#o)
      this.#s.delete(t), Xt(t, Ir), Zl(t);
    for (const t of this.#s)
      Xt(t, qr), Zl(t);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(t) {
    this.#r.add(t);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(t) {
    this.#a.add(t);
  }
  settled() {
    return (this.#i ??= nse()).promise;
  }
  static ensure() {
    if (He === null) {
      const t = He = new Jl();
      Tm.add(He), Jl.enqueue(() => {
        He === t && t.flush();
      });
    }
    return He;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    dse(t);
  }
  apply() {
  }
}
function bse() {
  var e = Ns;
  gN = !0;
  try {
    var t = 0;
    for (gp(!0); Vr.length > 0; ) {
      var n = Jl.ensure();
      if (t++ > 1e3) {
        var r, a;
        gse();
      }
      n.process(Vr), fo.clear();
    }
  } finally {
    gN = !1, gp(e), s1 = null;
  }
}
function gse() {
  try {
    sse();
  } catch (e) {
    CV(e, s1);
  }
}
let ya = null;
function K3(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (ys | sd)) === 0 && Ef(r) && (ya = /* @__PURE__ */ new Set(), Np(r), r.deps === null && r.first === null && r.nodes === null && (r.teardown === null && r.ac === null ? ex(r) : r.fn = null), ya?.size > 0)) {
        fo.clear();
        for (const a of ya) {
          if ((a.f & (ys | sd)) !== 0) continue;
          const o = [a];
          let s = a.parent;
          for (; s !== null; )
            ya.has(s) && (ya.delete(s), o.push(s)), s = s.parent;
          for (let i = o.length - 1; i >= 0; i--) {
            const u = o[i];
            (u.f & (ys | sd)) === 0 && Np(u);
          }
        }
        ya.clear();
      }
    }
    ya = null;
  }
}
function KV(e, t, n, r) {
  if (!n.has(e) && (n.add(e), e.reactions !== null))
    for (const a of e.reactions) {
      const o = a.f;
      (o & cn) !== 0 ? KV(
        /** @type {Derived} */
        a,
        t,
        n,
        r
      ) : (o & (BV | _u)) !== 0 && (o & Ir) === 0 && XV(a, t, r) && (Xt(a, Ir), Zl(
        /** @type {Effect} */
        a
      ));
    }
}
function XV(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (e.deps !== null)
    for (const a of e.deps) {
      if (t.includes(a))
        return !0;
      if ((a.f & cn) !== 0 && XV(
        /** @type {Derived} */
        a,
        t,
        n
      ))
        return n.set(
          /** @type {Derived} */
          a,
          !0
        ), !0;
    }
  return n.set(e, !1), !1;
}
function Zl(e) {
  for (var t = s1 = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (gN && t === Kt && (n & _u) !== 0 && (n & jV) === 0)
      return;
    if ((n & (yf | hf)) !== 0) {
      if ((n & Ot) === 0) return;
      t.f ^= Ot;
    }
  }
  Vr.push(t);
}
function WV(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      u1(
        /** @type {Effect} */
        t[n]
      );
  }
}
function hse(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & cn) === 0)
      return (t.f & ys) === 0 ? (
        /** @type {Effect} */
        t
      ) : null;
    t = t.parent;
  }
  return null;
}
function i1(e) {
  var t, n = Kt;
  hp(hse(e));
  try {
    e.f &= ~Cs, WV(e), t = ax(e);
  } finally {
    hp(n);
  }
  return t;
}
function JV(e) {
  var t = i1(e);
  if (e.equals(t) || (He?.is_fork || (e.v = t), e.wv = nx()), !Nf)
    if (Bn !== null)
      (bp() || He?.is_fork) && Bn.set(e, t);
    else {
      var n = (e.f & zr) === 0 ? qr : Ot;
      Xt(e, n);
    }
}
let hN = /* @__PURE__ */ new Set();
const fo = /* @__PURE__ */ new Map();
let ZV = !1;
function yse(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: cse,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function Qa(e, t) {
  const n = yse(e);
  return _se(n), n;
}
function Yo(e, t, n = !1) {
  Ee !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Qo || (Ee.f & C3) !== 0) && MV() && (Ee.f & (cn | _u | BV | C3)) !== 0 && !Ga?.includes(e) && lse();
  let r = n ? Ti(t) : t;
  return Nse(e, r);
}
function Nse(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    Nf ? fo.set(e, t) : fo.set(e, n), e.v = t;
    var r = Jl.ensure();
    r.capture(e, n), (e.f & cn) !== 0 && ((e.f & Ir) !== 0 && i1(
      /** @type {Derived} */
      e
    ), Xt(e, (e.f & zr) !== 0 ? Ot : qr)), e.wv = nx(), HV(e, Ir), Kt !== null && (Kt.f & Ot) !== 0 && (Kt.f & (hf | yf)) === 0 && (Ln === null ? Ose([e]) : Ln.push(e)), !r.is_fork && hN.size > 0 && !ZV && Ese();
  }
  return t;
}
function Ese() {
  ZV = !1;
  var e = Ns;
  gp(!0);
  const t = Array.from(hN);
  try {
    for (const n of t)
      (n.f & Ot) !== 0 && Xt(n, qr), Ef(n) && Np(n);
  } finally {
    gp(e);
  }
  hN.clear();
}
function vh(e) {
  Yo(e, e.v + 1);
}
function HV(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, a = 0; a < r; a++) {
      var o = n[a], s = o.f, i = (s & Ir) === 0;
      if (i && Xt(o, t), (s & cn) !== 0) {
        var u = (
          /** @type {Derived} */
          o
        );
        Bn?.delete(u), (s & Cs) === 0 && (s & zr && (o.f |= Cs), HV(u, qr));
      } else i && ((s & _u) !== 0 && ya !== null && ya.add(
        /** @type {Effect} */
        o
      ), Zl(
        /** @type {Effect} */
        o
      ));
    }
}
function Ti(e) {
  if (typeof e != "object" || e === null || Eh in e)
    return e;
  const t = ese(e);
  if (t !== qoe && t !== Qoe)
    return e;
  var n = /* @__PURE__ */ new Map(), r = Hoe(e), a = /* @__PURE__ */ Qa(0), o = Es, s = (i) => {
    if (Es === o)
      return i();
    var u = Ee, l = Es;
    ru(null), W3(o);
    var c = i();
    return ru(u), W3(l), c;
  };
  return r && n.set("length", /* @__PURE__ */ Qa(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(i, u, l) {
        (!("value" in l) || l.configurable === !1 || l.enumerable === !1 || l.writable === !1) && ise();
        var c = n.get(u);
        return c === void 0 ? c = s(() => {
          var f = /* @__PURE__ */ Qa(l.value);
          return n.set(u, f), f;
        }) : Yo(c, l.value, !0), !0;
      },
      deleteProperty(i, u) {
        var l = n.get(u);
        if (l === void 0) {
          if (u in i) {
            const c = s(() => /* @__PURE__ */ Qa(ht));
            n.set(u, c), vh(a);
          }
        } else
          Yo(l, ht), vh(a);
        return !0;
      },
      get(i, u, l) {
        if (u === Eh)
          return e;
        var c = n.get(u), f = u in i;
        if (c === void 0 && (!f || Nh(i, u)?.writable) && (c = s(() => {
          var m = Ti(f ? i[u] : ht), p = /* @__PURE__ */ Qa(m);
          return p;
        }), n.set(u, c)), c !== void 0) {
          var d = Im(c);
          return d === ht ? void 0 : d;
        }
        return Reflect.get(i, u, l);
      },
      getOwnPropertyDescriptor(i, u) {
        var l = Reflect.getOwnPropertyDescriptor(i, u);
        if (l && "value" in l) {
          var c = n.get(u);
          c && (l.value = Im(c));
        } else if (l === void 0) {
          var f = n.get(u), d = f?.v;
          if (f !== void 0 && d !== ht)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return l;
      },
      has(i, u) {
        if (u === Eh)
          return !0;
        var l = n.get(u), c = l !== void 0 && l.v !== ht || Reflect.has(i, u);
        if (l !== void 0 || Kt !== null && (!c || Nh(i, u)?.writable)) {
          l === void 0 && (l = s(() => {
            var d = c ? Ti(i[u]) : ht, m = /* @__PURE__ */ Qa(d);
            return m;
          }), n.set(u, l));
          var f = Im(l);
          if (f === ht)
            return !1;
        }
        return c;
      },
      set(i, u, l, c) {
        var f = n.get(u), d = u in i;
        if (r && u === "length")
          for (var m = l; m < /** @type {Source<number>} */
          f.v; m += 1) {
            var p = n.get(m + "");
            p !== void 0 ? Yo(p, ht) : m in i && (p = s(() => /* @__PURE__ */ Qa(ht)), n.set(m + "", p));
          }
        if (f === void 0)
          (!d || Nh(i, u)?.writable) && (f = s(() => /* @__PURE__ */ Qa(void 0)), Yo(f, Ti(l)), n.set(u, f));
        else {
          d = f.v !== ht;
          var b = s(() => Ti(l));
          Yo(f, b);
        }
        var g = Reflect.getOwnPropertyDescriptor(i, u);
        if (g?.set && g.set.call(c, l), !d) {
          if (r && typeof u == "string") {
            var S = (
              /** @type {Source<number>} */
              n.get("length")
            ), D = Number(u);
            Number.isInteger(D) && D >= S.v && Yo(S, D + 1);
          }
          vh(a);
        }
        return !0;
      },
      ownKeys(i) {
        Im(a);
        var u = Reflect.ownKeys(i).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== ht;
        });
        for (var [l, c] of n)
          c.v !== ht && !(l in i) && u.push(l);
        return u;
      },
      setPrototypeOf() {
        use();
      }
    }
  );
}
var vse;
// @__NO_SIDE_EFFECTS__
function Tse(e) {
  return (
    /** @type {TemplateNode | null} */
    vse.call(e)
  );
}
function zV(e) {
  var t = Ee, n = Kt;
  ru(null), hp(null);
  try {
    return e();
  } finally {
    ru(t), hp(n);
  }
}
function bp() {
  return Ee !== null && !Qo;
}
function qV(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = Nf, r = Ee;
    X3(!0), ru(null);
    try {
      t.call(null);
    } finally {
      X3(n), ru(r);
    }
  }
}
function QV(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const a = n.ac;
    a !== null && zV(() => {
      a.abort(GV);
    });
    var r = n.next;
    (n.f & yf) !== 0 ? n.parent = null : u1(n, t), n = r;
  }
}
function Ise(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & hf) === 0 && u1(t), t = n;
  }
}
function u1(e, t = !0) {
  var n = !1;
  (t || (e.f & jV) !== 0) && e.nodes !== null && e.nodes.end !== null && (wse(
    e.nodes.start,
    /** @type {TemplateNode} */
    e.nodes.end
  ), n = !0), QV(e, t && !n), yp(e, 0), Xt(e, ys);
  var r = e.nodes && e.nodes.t;
  if (r !== null)
    for (const o of r)
      o.stop();
  qV(e);
  var a = e.parent;
  a !== null && a.first !== null && ex(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes = e.ac = null;
}
function wse(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : /* @__PURE__ */ Tse(e);
    e.remove(), e = n;
  }
}
function ex(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
let Ns = !1;
function gp(e) {
  Ns = e;
}
let Nf = !1;
function X3(e) {
  Nf = e;
}
let Ee = null, Qo = !1;
function ru(e) {
  Ee = e;
}
let Kt = null;
function hp(e) {
  Kt = e;
}
let Ga = null;
function _se(e) {
  Ee !== null && (Ga === null ? Ga = [e] : Ga.push(e));
}
let st = null, En = 0, Ln = null;
function Ose(e) {
  Ln = e;
}
let tx = 1, Hl = 0, Es = Hl;
function W3(e) {
  Es = e;
}
function nx() {
  return ++tx;
}
function Ef(e) {
  var t = e.f;
  if ((t & Ir) !== 0)
    return !0;
  if (t & cn && (e.f &= ~Cs), (t & qr) !== 0) {
    var n = e.deps;
    if (n !== null)
      for (var r = n.length, a = 0; a < r; a++) {
        var o = n[a];
        if (Ef(
          /** @type {Derived} */
          o
        ) && JV(
          /** @type {Derived} */
          o
        ), o.wv > e.wv)
          return !0;
      }
    (t & zr) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Bn === null && Xt(e, Ot);
  }
  return !1;
}
function rx(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !Ga?.includes(e))
    for (var a = 0; a < r.length; a++) {
      var o = r[a];
      (o.f & cn) !== 0 ? rx(
        /** @type {Derived} */
        o,
        t,
        !1
      ) : t === o && (n ? Xt(o, Ir) : (o.f & Ot) !== 0 && Xt(o, qr), Zl(
        /** @type {Effect} */
        o
      ));
    }
}
function ax(e) {
  var t = st, n = En, r = Ln, a = Ee, o = Ga, s = Qo, i = Es, u = e.f;
  st = /** @type {null | Value[]} */
  null, En = 0, Ln = null, Ee = (u & (hf | yf)) === 0 ? e : null, Ga = null, e.ctx, Qo = !1, Es = ++Hl, e.ac !== null && (zV(() => {
    e.ac.abort(GV);
  }), e.ac = null);
  try {
    e.f |= bN;
    var l = (
      /** @type {Function} */
      e.fn
    ), c = l(), f = e.deps;
    if (st !== null) {
      var d;
      if (yp(e, En), f !== null && En > 0)
        for (f.length = En + st.length, d = 0; d < st.length; d++)
          f[En + d] = st[d];
      else
        e.deps = f = st;
      if (bp() && (e.f & zr) !== 0)
        for (d = En; d < f.length; d++)
          (f[d].reactions ??= []).push(e);
    } else f !== null && En < f.length && (yp(e, En), f.length = En);
    if (MV() && Ln !== null && !Qo && f !== null && (e.f & (cn | qr | Ir)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      Ln.length; d++)
        rx(
          Ln[d],
          /** @type {Effect} */
          e
        );
    return a !== null && a !== e && (Hl++, Ln !== null && (r === null ? r = Ln : r.push(.../** @type {Source[]} */
    Ln))), (e.f & Wl) !== 0 && (e.f ^= Wl), c;
  } catch (m) {
    return pse(m);
  } finally {
    e.f ^= bN, st = t, En = n, Ln = r, Ee = a, Ga = o, Qo = s, Es = i;
  }
}
function Sse(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = zoe.call(n, e);
    if (r !== -1) {
      var a = n.length - 1;
      a === 0 ? n = t.reactions = null : (n[r] = n[a], n.pop());
    }
  }
  n === null && (t.f & cn) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (st === null || !st.includes(t)) && (Xt(t, qr), (t.f & zr) !== 0 && (t.f ^= zr, t.f &= ~Cs), WV(
    /** @type {Derived} **/
    t
  ), yp(
    /** @type {Derived} **/
    t,
    0
  ));
}
function yp(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      Sse(e, n[r]);
}
function Np(e) {
  var t = e.f;
  if ((t & ys) === 0) {
    Xt(e, Ot);
    var n = Kt, r = Ns;
    Kt = e, Ns = !0;
    try {
      (t & (_u | ase)) !== 0 ? Ise(e) : QV(e), qV(e);
      var a = ax(e);
      e.teardown = typeof a == "function" ? a : null, e.wv = tx;
      var o;
      Zoe && fse && (e.f & Ir) !== 0 && e.deps;
    } finally {
      Ns = r, Kt = n;
    }
  }
}
function Im(e) {
  var t = e.f, n = (t & cn) !== 0;
  if (Ee !== null && !Qo) {
    var r = Kt !== null && (Kt.f & ys) !== 0;
    if (!r && !Ga?.includes(e)) {
      var a = Ee.deps;
      if ((Ee.f & bN) !== 0)
        e.rv < Hl && (e.rv = Hl, st === null && a !== null && a[En] === e ? En++ : st === null ? st = [e] : st.includes(e) || st.push(e));
      else {
        (Ee.deps ??= []).push(e);
        var o = e.reactions;
        o === null ? e.reactions = [Ee] : o.includes(Ee) || o.push(Ee);
      }
    }
  }
  if (Nf) {
    if (fo.has(e))
      return fo.get(e);
    if (n) {
      var s = (
        /** @type {Derived} */
        e
      ), i = s.v;
      return ((s.f & Ot) === 0 && s.reactions !== null || sx(s)) && (i = i1(s)), fo.set(s, i), i;
    }
  } else n && (!Bn?.has(e) || He?.is_fork && !bp()) && (s = /** @type {Derived} */
  e, Ef(s) && JV(s), Ns && bp() && (s.f & zr) === 0 && ox(s));
  if (Bn?.has(e))
    return Bn.get(e);
  if ((e.f & Wl) !== 0)
    throw e.v;
  return e.v;
}
function ox(e) {
  if (e.deps !== null) {
    e.f ^= zr;
    for (const t of e.deps)
      (t.reactions ??= []).push(e), (t.f & cn) !== 0 && (t.f & zr) === 0 && ox(
        /** @type {Derived} */
        t
      );
  }
}
function sx(e) {
  if (e.v === ht) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (fo.has(t) || (t.f & cn) !== 0 && sx(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
const Dse = -7169;
function Xt(e, t) {
  e.f = e.f & Dse | t;
}
function ix() {
  return {
    isDark: document.documentElement.classList.contains("night-mode")
  };
}
const kse = Ti(ix()), Ase = new MutationObserver((e, t) => {
  kse.isDark = ix().isDark;
});
Ase.observe(document.documentElement, { attributeFilter: ["class"] });
const Lse = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(Lse);
var G;
(function(e) {
  e[e.Canceled = 1] = "Canceled", e[e.Unknown = 2] = "Unknown", e[e.InvalidArgument = 3] = "InvalidArgument", e[e.DeadlineExceeded = 4] = "DeadlineExceeded", e[e.NotFound = 5] = "NotFound", e[e.AlreadyExists = 6] = "AlreadyExists", e[e.PermissionDenied = 7] = "PermissionDenied", e[e.ResourceExhausted = 8] = "ResourceExhausted", e[e.FailedPrecondition = 9] = "FailedPrecondition", e[e.Aborted = 10] = "Aborted", e[e.OutOfRange = 11] = "OutOfRange", e[e.Unimplemented = 12] = "Unimplemented", e[e.Internal = 13] = "Internal", e[e.Unavailable = 14] = "Unavailable", e[e.DataLoss = 15] = "DataLoss", e[e.Unauthenticated = 16] = "Unauthenticated";
})(G || (G = {}));
function l1(e, t) {
  return e !== null && typeof e == "object" && "$typeName" in e && typeof e.$typeName == "string" ? t === void 0 ? !0 : t.typeName === e.$typeName : !1;
}
var I;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(I || (I = {}));
function Fse() {
  let e = 0, t = 0;
  for (let r = 0; r < 28; r += 7) {
    let a = this.buf[this.pos++];
    if (e |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  let n = this.buf[this.pos++];
  if (e |= (n & 15) << 28, t = (n & 112) >> 4, (n & 128) == 0)
    return this.assertBounds(), [e, t];
  for (let r = 3; r <= 31; r += 7) {
    let a = this.buf[this.pos++];
    if (t |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  throw new Error("invalid varint");
}
function Th(e, t, n) {
  for (let o = 0; o < 28; o = o + 7) {
    const s = e >>> o, i = !(!(s >>> 7) && t == 0), u = (i ? s | 128 : s) & 255;
    if (n.push(u), !i)
      return;
  }
  const r = e >>> 28 & 15 | (t & 7) << 4, a = t >> 3 != 0;
  if (n.push((a ? r | 128 : r) & 255), !!a) {
    for (let o = 3; o < 31; o = o + 7) {
      const s = t >>> o, i = !!(s >>> 7), u = (i ? s | 128 : s) & 255;
      if (n.push(u), !i)
        return;
    }
    n.push(t >>> 31 & 1);
  }
}
const id = 4294967296;
function J3(e) {
  const t = e[0] === "-";
  t && (e = e.slice(1));
  const n = 1e6;
  let r = 0, a = 0;
  function o(s, i) {
    const u = Number(e.slice(s, i));
    a *= n, r = r * n + u, r >= id && (a = a + (r / id | 0), r = r % id);
  }
  return o(-24, -18), o(-18, -12), o(-12, -6), o(-6), t ? lx(r, a) : c1(r, a);
}
function Use(e, t) {
  let n = c1(e, t);
  const r = n.hi & 2147483648;
  r && (n = lx(n.lo, n.hi));
  const a = ux(n.lo, n.hi);
  return r ? "-" + a : a;
}
function ux(e, t) {
  if ({ lo: e, hi: t } = Rse(e, t), t <= 2097151)
    return String(id * t + e);
  const n = e & 16777215, r = (e >>> 24 | t << 8) & 16777215, a = t >> 16 & 65535;
  let o = n + r * 6777216 + a * 6710656, s = r + a * 8147497, i = a * 2;
  const u = 1e7;
  return o >= u && (s += Math.floor(o / u), o %= u), s >= u && (i += Math.floor(s / u), s %= u), i.toString() + Z3(s) + Z3(o);
}
function Rse(e, t) {
  return { lo: e >>> 0, hi: t >>> 0 };
}
function c1(e, t) {
  return { lo: e | 0, hi: t | 0 };
}
function lx(e, t) {
  return t = ~t, e ? e = ~e + 1 : t += 1, c1(e, t);
}
const Z3 = (e) => {
  const t = String(e);
  return "0000000".slice(t.length) + t;
};
function yN(e, t) {
  if (e >= 0) {
    for (; e > 127; )
      t.push(e & 127 | 128), e = e >>> 7;
    t.push(e);
  } else {
    for (let n = 0; n < 9; n++)
      t.push(e & 127 | 128), e = e >> 7;
    t.push(1);
  }
}
function $se() {
  let e = this.buf[this.pos++], t = e & 127;
  if ((e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 7, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 14, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 21, (e & 128) == 0)
    return this.assertBounds(), t;
  e = this.buf[this.pos++], t |= (e & 15) << 28;
  for (let n = 5; (e & 128) !== 0 && n < 10; n++)
    e = this.buf[this.pos++];
  if ((e & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
const q = /* @__PURE__ */ Pse();
function Pse() {
  const e = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof e.getBigInt64 == "function" && typeof e.getBigUint64 == "function" && typeof e.setBigInt64 == "function" && typeof e.setBigUint64 == "function" && (globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const t = BigInt("-9223372036854775808"), n = BigInt("9223372036854775807"), r = BigInt("0"), a = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > n || s < t)
          throw new Error(`invalid int64: ${o}`);
        return s;
      },
      uParse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > a || s < r)
          throw new Error(`invalid uint64: ${o}`);
        return s;
      },
      enc(o) {
        return e.setBigInt64(0, this.parse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      uEnc(o) {
        return e.setBigInt64(0, this.uParse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      dec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigInt64(0, !0);
      },
      uDec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigUint64(0, !0);
      }
    };
  }
  return {
    zero: "0",
    supported: !1,
    parse(t) {
      return typeof t != "string" && (t = t.toString()), H3(t), t;
    },
    uParse(t) {
      return typeof t != "string" && (t = t.toString()), z3(t), t;
    },
    enc(t) {
      return typeof t != "string" && (t = t.toString()), H3(t), J3(t);
    },
    uEnc(t) {
      return typeof t != "string" && (t = t.toString()), z3(t), J3(t);
    },
    dec(t, n) {
      return Use(t, n);
    },
    uDec(t, n) {
      return ux(t, n);
    }
  };
}
function H3(e) {
  if (!/^-?[0-9]+$/.test(e))
    throw new Error("invalid int64: " + e);
}
function z3(e) {
  if (!/^[0-9]+$/.test(e))
    throw new Error("invalid uint64: " + e);
}
function Ks(e, t) {
  switch (e) {
    case I.STRING:
      return "";
    case I.BOOL:
      return !1;
    case I.DOUBLE:
    case I.FLOAT:
      return 0;
    case I.INT64:
    case I.UINT64:
    case I.SFIXED64:
    case I.FIXED64:
    case I.SINT64:
      return t ? "0" : q.zero;
    case I.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function Vse(e, t) {
  switch (e) {
    case I.BOOL:
      return t === !1;
    case I.STRING:
      return t === "";
    case I.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
const cx = 2, Ua = /* @__PURE__ */ Symbol.for("reflect unsafe local");
function fx(e, t) {
  const n = e[t.localName].case;
  return n === void 0 ? n : t.fields.find((r) => r.localName === n);
}
function xse(e, t) {
  const n = t.localName;
  if (t.oneof)
    return e[t.oneof.localName].case === n;
  if (t.presence != cx)
    return e[n] !== void 0 && Object.prototype.hasOwnProperty.call(e, n);
  switch (t.fieldKind) {
    case "list":
      return e[n].length > 0;
    case "map":
      return Object.keys(e[n]).length > 0;
    case "scalar":
      return !Vse(t.scalar, e[n]);
    case "enum":
      return e[n] !== t.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function zl(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) && e[t] !== void 0;
}
function mx(e, t) {
  if (t.oneof) {
    const n = e[t.oneof.localName];
    return n.case === t.localName ? n.value : void 0;
  }
  return e[t.localName];
}
function dx(e, t, n) {
  t.oneof ? e[t.oneof.localName] = {
    case: t.localName,
    value: n
  } : e[t.localName] = n;
}
function Yse(e, t) {
  const n = t.localName;
  if (t.oneof) {
    const r = t.oneof.localName;
    e[r].case === n && (e[r] = { case: void 0 });
  } else if (t.presence != cx)
    delete e[n];
  else
    switch (t.fieldKind) {
      case "map":
        e[n] = {};
        break;
      case "list":
        e[n] = [];
        break;
      case "enum":
        e[n] = t.enum.values[0].number;
        break;
      case "scalar":
        e[n] = Ks(t.scalar, t.longAsString);
        break;
    }
}
function wo(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function f1(e, t) {
  var n, r, a, o;
  if (wo(e) && Ua in e && "add" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.listKind == i.listKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function m1(e, t) {
  var n, r, a, o;
  if (wo(e) && Ua in e && "has" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.mapKey === i.mapKey && s.mapKind == i.mapKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function d1(e, t) {
  return wo(e) && Ua in e && "desc" in e && wo(e.desc) && e.desc.kind === "message" && (t === void 0 || e.desc.typeName == t.typeName);
}
function jse(e) {
  return px(e.$typeName);
}
function vf(e) {
  const t = e.fields[0];
  return px(e.typeName) && t !== void 0 && t.fieldKind == "scalar" && t.name == "value" && t.number == 1;
}
function px(e) {
  return e.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(e.substring(16));
}
const Bse = 999, Gse = 998, ud = 2;
function wr(e, t) {
  if (l1(t, e))
    return t;
  const n = Wse(e);
  return t !== void 0 && Mse(e, n, t), n;
}
function Mse(e, t, n) {
  for (const r of e.members) {
    let a = n[r.localName];
    if (a == null)
      continue;
    let o;
    if (r.kind == "oneof") {
      const s = fx(n, r);
      if (!s)
        continue;
      o = s, a = mx(n, s);
    } else
      o = r;
    switch (o.fieldKind) {
      case "message":
        a = p1(o, a);
        break;
      case "scalar":
        a = bx(o, a);
        break;
      case "list":
        a = Kse(o, a);
        break;
      case "map":
        a = Cse(o, a);
        break;
    }
    dx(t, o, a);
  }
  return t;
}
function bx(e, t) {
  return e.scalar == I.BYTES ? b1(t) : t;
}
function Cse(e, t) {
  if (wo(t)) {
    if (e.scalar == I.BYTES)
      return q3(t, b1);
    if (e.mapKind == "message")
      return q3(t, (n) => p1(e, n));
  }
  return t;
}
function Kse(e, t) {
  if (Array.isArray(t)) {
    if (e.scalar == I.BYTES)
      return t.map(b1);
    if (e.listKind == "message")
      return t.map((n) => p1(e, n));
  }
  return t;
}
function p1(e, t) {
  if (e.fieldKind == "message" && !e.oneof && vf(e.message))
    return bx(e.message.fields[0], t);
  if (wo(t)) {
    if (e.message.typeName == "google.protobuf.Struct" && e.parent.typeName !== "google.protobuf.Value")
      return t;
    if (!l1(t, e.message))
      return wr(e.message, t);
  }
  return t;
}
function b1(e) {
  return Array.isArray(e) ? new Uint8Array(e) : e;
}
function q3(e, t) {
  const n = {};
  for (const r of Object.entries(e))
    n[r[0]] = t(r[1]);
  return n;
}
const Xse = /* @__PURE__ */ Symbol(), Q3 = /* @__PURE__ */ new WeakMap();
function Wse(e) {
  let t;
  if (Jse(e)) {
    const n = Q3.get(e);
    let r, a;
    if (n)
      ({ prototype: r, members: a } = n);
    else {
      r = {}, a = /* @__PURE__ */ new Set();
      for (const o of e.members)
        o.kind != "oneof" && (o.fieldKind != "scalar" && o.fieldKind != "enum" || o.presence != ud && (a.add(o), r[o.localName] = Ih(o)));
      Q3.set(e, { prototype: r, members: a });
    }
    t = Object.create(r), t.$typeName = e.typeName;
    for (const o of e.members)
      a.has(o) || o.kind == "field" && (o.fieldKind == "message" || (o.fieldKind == "scalar" || o.fieldKind == "enum") && o.presence != ud) || (t[o.localName] = Ih(o));
  } else {
    t = {
      $typeName: e.typeName
    };
    for (const n of e.members)
      (n.kind == "oneof" || n.presence == ud) && (t[n.localName] = Ih(n));
  }
  return t;
}
function Jse(e) {
  switch (e.file.edition) {
    case Bse:
      return !1;
    case Gse:
      return !0;
    default:
      return e.fields.some((t) => t.presence != ud && t.fieldKind != "message" && !t.oneof);
  }
}
function Ih(e) {
  if (e.kind == "oneof")
    return { case: void 0 };
  if (e.fieldKind == "list")
    return [];
  if (e.fieldKind == "map")
    return {};
  if (e.fieldKind == "message")
    return Xse;
  const t = e.getDefaultValue();
  return t !== void 0 ? e.fieldKind == "scalar" && e.longAsString ? t.toString() : t : e.fieldKind == "scalar" ? Ks(e.scalar, e.longAsString) : e.enum.values[0].number;
}
const Zse = [
  "FieldValueInvalidError",
  "FieldListRangeError",
  "ForeignFieldError"
];
class Wt extends Error {
  constructor(t, n, r = "FieldValueInvalidError") {
    super(n), this.name = r, this.field = () => t;
  }
}
function Hse(e) {
  return e instanceof Error && Zse.includes(e.name) && "field" in e && typeof e.field == "function";
}
const wh = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
function g1() {
  if (globalThis[wh] == null) {
    const e = new globalThis.TextEncoder(), t = new globalThis.TextDecoder();
    globalThis[wh] = {
      encodeUtf8(n) {
        return e.encode(n);
      },
      decodeUtf8(n) {
        return t.decode(n);
      },
      checkUtf8(n) {
        try {
          return encodeURIComponent(n), !0;
        } catch {
          return !1;
        }
      }
    };
  }
  return globalThis[wh];
}
var ce;
(function(e) {
  e[e.Varint = 0] = "Varint", e[e.Bit64 = 1] = "Bit64", e[e.LengthDelimited = 2] = "LengthDelimited", e[e.StartGroup = 3] = "StartGroup", e[e.EndGroup = 4] = "EndGroup", e[e.Bit32 = 5] = "Bit32";
})(ce || (ce = {}));
const gx = 34028234663852886e22, hx = -34028234663852886e22, yx = 4294967295, Nx = 2147483647, Ex = -2147483648;
class vx {
  constructor(t = g1().encodeUtf8) {
    this.encodeUtf8 = t, this.stack = [], this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []);
    let t = 0;
    for (let a = 0; a < this.chunks.length; a++)
      t += this.chunks[a].length;
    let n = new Uint8Array(t), r = 0;
    for (let a = 0; a < this.chunks.length; a++)
      n.set(this.chunks[a], r), r += this.chunks[a].length;
    return this.chunks = [], n;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), n = this.stack.pop();
    if (!n)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = n.chunks, this.buf = n.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, n) {
    return this.uint32((t << 3 | n) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (eD(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return _h(t), yN(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let n = this.encodeUtf8(t);
    return this.uint32(n.byteLength), this.raw(n);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    zse(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setFloat32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let n = new Uint8Array(8);
    return new DataView(n.buffer).setFloat64(0, t, !0), this.raw(n);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    eD(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    _h(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setInt32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return _h(t), t = (t << 1 ^ t >> 31) >>> 0, yN(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = q.enc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = q.uEnc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let n = q.enc(t);
    return Th(n.lo, n.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    const n = q.enc(t), r = n.hi >> 31, a = n.lo << 1 ^ r, o = (n.hi << 1 | n.lo >>> 31) ^ r;
    return Th(a, o, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    const n = q.uEnc(t);
    return Th(n.lo, n.hi, this.buf), this;
  }
}
class h1 {
  constructor(t, n = g1().decodeUtf8) {
    this.decodeUtf8 = n, this.varint64 = Fse, this.uint32 = $se, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), n = t >>> 3, r = t & 7;
    if (n <= 0 || r < 0 || r > 5)
      throw new Error("illegal tag: field no " + n + " wire type " + r);
    return [n, r];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, n) {
    let r = this.pos;
    switch (t) {
      case ce.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case ce.Bit64:
        this.pos += 4;
      case ce.Bit32:
        this.pos += 4;
        break;
      case ce.LengthDelimited:
        let a = this.uint32();
        this.pos += a;
        break;
      case ce.StartGroup:
        for (; ; ) {
          const [o, s] = this.tag();
          if (s === ce.EndGroup) {
            if (n !== void 0 && o !== n)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(s, o);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return q.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return q.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, n] = this.varint64(), r = -(t & 1);
    return t = (t >>> 1 | (n & 1) << 31) ^ r, n = n >>> 1 ^ r, q.dec(t, n);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, n] = this.varint64();
    return t !== 0 || n !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return q.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return q.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), n = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(n, n + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function _h(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid int32: " + typeof e);
  if (!Number.isInteger(e) || e > Nx || e < Ex)
    throw new Error("invalid int32: " + e);
}
function eD(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid uint32: " + typeof e);
  if (!Number.isInteger(e) || e > yx || e < 0)
    throw new Error("invalid uint32: " + e);
}
function zse(e) {
  if (typeof e == "string") {
    const t = e;
    if (e = Number(e), Number.isNaN(e) && t !== "NaN")
      throw new Error("invalid float32: " + t);
  } else if (typeof e != "number")
    throw new Error("invalid float32: " + typeof e);
  if (Number.isFinite(e) && (e > gx || e < hx))
    throw new Error("invalid float32: " + e);
}
function jo(e, t) {
  const n = e.fieldKind == "list" ? f1(t, e) : e.fieldKind == "map" ? m1(t, e) : y1(e, t);
  if (n === !0)
    return;
  let r;
  switch (e.fieldKind) {
    case "list":
      r = `expected ${wx(e)}, got ${je(t)}`;
      break;
    case "map":
      r = `expected ${_x(e)}, got ${je(t)}`;
      break;
    default:
      r = Ep(e, t, n);
  }
  return new Wt(e, r);
}
function tD(e, t, n) {
  const r = y1(e, n);
  if (r !== !0)
    return new Wt(e, `list item #${t + 1}: ${Ep(e, n, r)}`);
}
function qse(e, t, n) {
  const r = Tx(t, e.mapKey);
  if (r !== !0)
    return new Wt(e, `invalid map key: ${Ep({ scalar: e.mapKey }, t, r)}`);
  const a = y1(e, n);
  if (a !== !0)
    return new Wt(e, `map entry ${je(t)}: ${Ep(e, n, a)}`);
}
function y1(e, t) {
  return e.scalar !== void 0 ? Tx(t, e.scalar) : e.enum !== void 0 ? e.enum.open ? Number.isInteger(t) : e.enum.values.some((n) => n.number === t) : d1(t, e.message);
}
function Tx(e, t) {
  switch (t) {
    case I.DOUBLE:
      return typeof e == "number";
    case I.FLOAT:
      return typeof e != "number" ? !1 : Number.isNaN(e) || !Number.isFinite(e) ? !0 : e > gx || e < hx ? `${e.toFixed()} out of range` : !0;
    case I.INT32:
    case I.SFIXED32:
    case I.SINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > Nx || e < Ex ? `${e.toFixed()} out of range` : !0;
    case I.FIXED32:
    case I.UINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > yx || e < 0 ? `${e.toFixed()} out of range` : !0;
    case I.BOOL:
      return typeof e == "boolean";
    case I.STRING:
      return typeof e != "string" ? !1 : g1().checkUtf8(e) || "invalid UTF8";
    case I.BYTES:
      return e instanceof Uint8Array;
    case I.INT64:
    case I.SFIXED64:
    case I.SINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return q.parse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
    case I.FIXED64:
    case I.UINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return q.uParse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
  }
}
function Ep(e, t, n) {
  return n = typeof n == "string" ? `: ${n}` : `, got ${je(t)}`, e.scalar !== void 0 ? `expected ${Qse(e.scalar)}` + n : e.enum !== void 0 ? `expected ${e.enum.toString()}` + n : `expected ${Ix(e.message)}` + n;
}
function je(e) {
  switch (typeof e) {
    case "object":
      return e === null ? "null" : e instanceof Uint8Array ? `Uint8Array(${e.length})` : Array.isArray(e) ? `Array(${e.length})` : f1(e) ? wx(e.field()) : m1(e) ? _x(e.field()) : d1(e) ? Ix(e.desc) : l1(e) ? `message ${e.$typeName}` : "object";
    case "string":
      return e.length > 30 ? "string" : `"${e.split('"').join('\\"')}"`;
    case "boolean":
      return String(e);
    case "number":
      return String(e);
    case "bigint":
      return String(e) + "n";
    default:
      return typeof e;
  }
}
function Ix(e) {
  return `ReflectMessage (${e.typeName})`;
}
function wx(e) {
  switch (e.listKind) {
    case "message":
      return `ReflectList (${e.message.toString()})`;
    case "enum":
      return `ReflectList (${e.enum.toString()})`;
    case "scalar":
      return `ReflectList (${I[e.scalar]})`;
  }
}
function _x(e) {
  switch (e.mapKind) {
    case "message":
      return `ReflectMap (${I[e.mapKey]}, ${e.message.toString()})`;
    case "enum":
      return `ReflectMap (${I[e.mapKey]}, ${e.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${I[e.mapKey]}, ${I[e.scalar]})`;
  }
}
function Qse(e) {
  switch (e) {
    case I.STRING:
      return "string";
    case I.BOOL:
      return "boolean";
    case I.INT64:
    case I.SINT64:
    case I.SFIXED64:
      return "bigint (int64)";
    case I.UINT64:
    case I.FIXED64:
      return "bigint (uint64)";
    case I.BYTES:
      return "Uint8Array";
    case I.DOUBLE:
      return "number (float64)";
    case I.FLOAT:
      return "number (float32)";
    case I.FIXED32:
    case I.UINT32:
      return "number (uint32)";
    case I.INT32:
    case I.SFIXED32:
    case I.SINT32:
      return "number (int32)";
  }
}
function qn(e, t, n = !0) {
  return new Ox(e, t, n);
}
const nD = /* @__PURE__ */ new WeakMap();
class Ox {
  get sortedFields() {
    const t = nD.get(this.desc);
    if (t)
      return t;
    const n = this.desc.fields.concat().sort((r, a) => r.number - a.number);
    return nD.set(this.desc, n), n;
  }
  constructor(t, n, r = !0) {
    this.lists = /* @__PURE__ */ new Map(), this.maps = /* @__PURE__ */ new Map(), this.check = r, this.desc = t, this.message = this[Ua] = n ?? wr(t), this.fields = t.fields, this.oneofs = t.oneofs, this.members = t.members;
  }
  findNumber(t) {
    return this._fieldsByNumber || (this._fieldsByNumber = new Map(this.desc.fields.map((n) => [n.number, n]))), this._fieldsByNumber.get(t);
  }
  oneofCase(t) {
    return Pu(this.message, t), fx(this.message, t);
  }
  isSet(t) {
    return Pu(this.message, t), xse(this.message, t);
  }
  clear(t) {
    Pu(this.message, t), Yse(this.message, t);
  }
  get(t) {
    Pu(this.message, t);
    const n = mx(this.message, t);
    switch (t.fieldKind) {
      case "list":
        let r = this.lists.get(t);
        return (!r || r[Ua] !== n) && this.lists.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          r = new eie(t, n, this.check)
        ), r;
      case "map":
        let a = this.maps.get(t);
        return (!a || a[Ua] !== n) && this.maps.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = new tie(t, n, this.check)
        ), a;
      case "message":
        return E1(t, n, this.check);
      case "scalar":
        return n === void 0 ? Ks(t.scalar, !1) : v1(t, n);
      case "enum":
        return n ?? t.enum.values[0].number;
    }
  }
  set(t, n) {
    if (Pu(this.message, t), this.check) {
      const a = jo(t, n);
      if (a)
        throw a;
    }
    let r;
    t.fieldKind == "message" ? r = N1(t, n) : m1(n) || f1(n) ? r = n[Ua] : r = T1(t, n), dx(this.message, t, r);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(t) {
    this.message.$unknown = t;
  }
}
function Pu(e, t) {
  if (t.parent.typeName !== e.$typeName)
    throw new Wt(t, `cannot use ${t.toString()} with message ${e.$typeName}`, "ForeignFieldError");
}
class eie {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(t, n, r) {
    this._field = t, this._arr = this[Ua] = n, this.check = r;
  }
  get(t) {
    const n = this._arr[t];
    return n === void 0 ? void 0 : Oh(this._field, n, this.check);
  }
  set(t, n) {
    if (t < 0 || t >= this._arr.length)
      throw new Wt(this._field, `list item #${t + 1}: out of range`);
    if (this.check) {
      const r = tD(this._field, t, n);
      if (r)
        throw r;
    }
    this._arr[t] = rD(this._field, n);
  }
  add(t) {
    if (this.check) {
      const n = tD(this._field, this._arr.length, t);
      if (n)
        throw n;
    }
    this._arr.push(rD(this._field, t));
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const t of this._arr)
      yield Oh(this._field, t, this.check);
  }
  *entries() {
    for (let t = 0; t < this._arr.length; t++)
      yield [t, Oh(this._field, this._arr[t], this.check)];
  }
}
class tie {
  constructor(t, n, r = !0) {
    this.obj = this[Ua] = n ?? {}, this.check = r, this._field = t;
  }
  field() {
    return this._field;
  }
  set(t, n) {
    if (this.check) {
      const r = qse(this._field, t, n);
      if (r)
        throw r;
    }
    return this.obj[wm(t)] = nie(this._field, n), this;
  }
  delete(t) {
    const n = wm(t), r = Object.prototype.hasOwnProperty.call(this.obj, n);
    return r && delete this.obj[n], r;
  }
  clear() {
    for (const t of Object.keys(this.obj))
      delete this.obj[t];
  }
  get(t) {
    let n = this.obj[wm(t)];
    return n !== void 0 && (n = Sh(this._field, n, this.check)), n;
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.obj, wm(t));
  }
  *keys() {
    for (const t of Object.keys(this.obj))
      yield aD(t, this._field.mapKey);
  }
  *entries() {
    for (const t of Object.entries(this.obj))
      yield [
        aD(t[0], this._field.mapKey),
        Sh(this._field, t[1], this.check)
      ];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const t of Object.values(this.obj))
      yield Sh(this._field, t, this.check);
  }
  forEach(t, n) {
    for (const r of this.entries())
      t.call(n, r[1], r[0], this);
  }
}
function N1(e, t) {
  return d1(t) ? jse(t.message) && !e.oneof && e.fieldKind == "message" ? t.message.value : t.desc.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" ? Dx(t.message) : t.message : t;
}
function E1(e, t, n) {
  return t !== void 0 && (vf(e.message) && !e.oneof && e.fieldKind == "message" ? t = {
    $typeName: e.message.typeName,
    value: v1(e.message.fields[0], t)
  } : e.message.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" && wo(t) && (t = Sx(t))), new Ox(e.message, t, n);
}
function rD(e, t) {
  return e.listKind == "message" ? N1(e, t) : T1(e, t);
}
function Oh(e, t, n) {
  return e.listKind == "message" ? E1(e, t, n) : v1(e, t);
}
function nie(e, t) {
  return e.mapKind == "message" ? N1(e, t) : T1(e, t);
}
function Sh(e, t, n) {
  return e.mapKind == "message" ? E1(e, t, n) : t;
}
function wm(e) {
  return typeof e == "string" || typeof e == "number" ? e : String(e);
}
function aD(e, t) {
  switch (t) {
    case I.STRING:
      return e;
    case I.INT32:
    case I.FIXED32:
    case I.UINT32:
    case I.SFIXED32:
    case I.SINT32: {
      const n = Number.parseInt(e);
      if (Number.isFinite(n))
        return n;
      break;
    }
    case I.BOOL:
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      break;
    case I.UINT64:
    case I.FIXED64:
      try {
        return q.uParse(e);
      } catch {
      }
      break;
    default:
      try {
        return q.parse(e);
      } catch {
      }
      break;
  }
  return e;
}
function v1(e, t) {
  switch (e.scalar) {
    case I.INT64:
    case I.SFIXED64:
    case I.SINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = q.parse(t));
      break;
    case I.FIXED64:
    case I.UINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = q.uParse(t));
      break;
  }
  return t;
}
function T1(e, t) {
  switch (e.scalar) {
    case I.INT64:
    case I.SFIXED64:
    case I.SINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = q.parse(t));
      break;
    case I.FIXED64:
    case I.UINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = q.uParse(t));
      break;
  }
  return t;
}
function Sx(e) {
  const t = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (wo(e))
    for (const [n, r] of Object.entries(e))
      t.fields[n] = Ax(r);
  return t;
}
function Dx(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = kx(r);
  return t;
}
function kx(e) {
  switch (e.kind.case) {
    case "structValue":
      return Dx(e.kind.value);
    case "listValue":
      return e.kind.value.values.map(kx);
    case "nullValue":
    case void 0:
      return null;
    default:
      return e.kind.value;
  }
}
function Ax(e) {
  const t = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof e) {
    case "number":
      t.kind = { case: "numberValue", value: e };
      break;
    case "string":
      t.kind = { case: "stringValue", value: e };
      break;
    case "boolean":
      t.kind = { case: "boolValue", value: e };
      break;
    case "object":
      if (e === null)
        t.kind = { case: "nullValue", value: 0 };
      else if (Array.isArray(e)) {
        const n = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(e))
          for (const r of e)
            n.values.push(Ax(r));
        t.kind = {
          case: "listValue",
          value: n
        };
      } else
        t.kind = {
          case: "structValue",
          value: Sx(e)
        };
      break;
  }
  return t;
}
function I1(e) {
  const t = rie();
  let n = e.length * 3 / 4;
  e[e.length - 2] == "=" ? n -= 2 : e[e.length - 1] == "=" && (n -= 1);
  let r = new Uint8Array(n), a = 0, o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++) {
    if (s = t[e.charCodeAt(u)], s === void 0)
      switch (e[u]) {
        // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
        case "=":
          o = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string");
      }
    switch (o) {
      case 0:
        i = s, o = 1;
        break;
      case 1:
        r[a++] = i << 2 | (s & 48) >> 4, i = s, o = 2;
        break;
      case 2:
        r[a++] = (i & 15) << 4 | (s & 60) >> 2, i = s, o = 3;
        break;
      case 3:
        r[a++] = (i & 3) << 6 | s, o = 0;
        break;
    }
  }
  if (o == 1)
    throw Error("invalid base64 string");
  return r.subarray(0, a);
}
function Lx(e, t = "std") {
  const n = Fx(t), r = t == "std";
  let a = "", o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++)
    switch (s = e[u], o) {
      case 0:
        a += n[s >> 2], i = (s & 3) << 4, o = 1;
        break;
      case 1:
        a += n[i | s >> 4], i = (s & 15) << 2, o = 2;
        break;
      case 2:
        a += n[i | s >> 6], a += n[s & 63], o = 0;
        break;
    }
  return o && (a += n[i], r && (a += "=", o == 1 && (a += "="))), a;
}
let _m, oD, si;
function Fx(e) {
  return _m || (_m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), oD = _m.slice(0, -2).concat("-", "_")), e == "url" ? (
    // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
    oD
  ) : _m;
}
function rie() {
  if (!si) {
    si = [];
    const e = Fx("std");
    for (let t = 0; t < e.length; t++)
      si[e[t].charCodeAt(0)] = t;
    si[45] = e.indexOf("+"), si[95] = e.indexOf("/");
  }
  return si;
}
function ql(e) {
  let t = !1;
  const n = [];
  for (let r = 0; r < e.length; r++) {
    let a = e.charAt(r);
    switch (a) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        n.push(a), t = !1;
        break;
      default:
        t && (t = !1, a = a.toUpperCase()), n.push(a);
        break;
    }
  }
  return n.join("");
}
const aie = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function Ql(e) {
  return aie.has(e) ? e + "$" : e;
}
function w1(e) {
  for (const t of e.field)
    zl(t, "jsonName") || (t.jsonName = ql(t.name));
  e.nestedType.forEach(w1);
}
function oie(e, t) {
  const n = e.values.find((r) => r.name === t);
  if (!n)
    throw new Error(`cannot parse ${e} default value: ${t}`);
  return n.number;
}
function sie(e, t) {
  switch (e) {
    case I.STRING:
      return t;
    case I.BYTES: {
      const n = iie(t);
      if (n === !1)
        throw new Error(`cannot parse ${I[e]} default value: ${t}`);
      return n;
    }
    case I.INT64:
    case I.SFIXED64:
    case I.SINT64:
      return q.parse(t);
    case I.UINT64:
    case I.FIXED64:
      return q.uParse(t);
    case I.DOUBLE:
    case I.FLOAT:
      switch (t) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(t);
      }
    case I.BOOL:
      return t === "true";
    case I.INT32:
    case I.UINT32:
    case I.SINT32:
    case I.FIXED32:
    case I.SFIXED32:
      return parseInt(t, 10);
  }
}
function iie(e) {
  const t = [], n = {
    tail: e,
    c: "",
    next() {
      return this.tail.length == 0 ? !1 : (this.c = this.tail[0], this.tail = this.tail.substring(1), !0);
    },
    take(r) {
      if (this.tail.length >= r) {
        const a = this.tail.substring(0, r);
        return this.tail = this.tail.substring(r), a;
      }
      return !1;
    }
  };
  for (; n.next(); )
    switch (n.c) {
      case "\\":
        if (n.next())
          switch (n.c) {
            case "\\":
              t.push(n.c.charCodeAt(0));
              break;
            case "b":
              t.push(8);
              break;
            case "f":
              t.push(12);
              break;
            case "n":
              t.push(10);
              break;
            case "r":
              t.push(13);
              break;
            case "t":
              t.push(9);
              break;
            case "v":
              t.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 8);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "x": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "u": {
              const r = n.c, a = n.take(4);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              const s = new Uint8Array(4);
              new DataView(s.buffer).setInt32(0, o, !0), t.push(s[0], s[1], s[2], s[3]);
              break;
            }
            case "U": {
              const r = n.c, a = n.take(8);
              if (a === !1)
                return !1;
              const o = q.uEnc(r + a), s = new Uint8Array(8), i = new DataView(s.buffer);
              i.setInt32(0, o.lo, !0), i.setInt32(4, o.hi, !0), t.push(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
              break;
            }
          }
        break;
      default:
        t.push(n.c.charCodeAt(0));
    }
  return new Uint8Array(t);
}
function* NN(e) {
  switch (e.kind) {
    case "file":
      for (const t of e.messages)
        yield t, yield* NN(t);
      yield* e.enums, yield* e.services, yield* e.extensions;
      break;
    case "message":
      for (const t of e.nestedMessages)
        yield t, yield* NN(t);
      yield* e.nestedEnums, yield* e.nestedExtensions;
      break;
  }
}
function Ux(...e) {
  const t = uie();
  if (!e.length)
    return t;
  if ("$typeName" in e[0] && e[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const n of e[0].file)
      cD(n, t);
    return t;
  }
  if ("$typeName" in e[0]) {
    let n = function(s) {
      const i = [];
      for (const u of s.dependency) {
        if (t.getFile(u) != null || o.has(u))
          continue;
        const l = a(u);
        if (!l)
          throw new Error(`Unable to resolve ${u}, imported by ${s.name}`);
        "kind" in l ? t.addFile(l, !1, !0) : (o.add(l.name), i.push(l));
      }
      return i.concat(...i.map(n));
    };
    const r = e[0], a = e[1], o = /* @__PURE__ */ new Set();
    for (const s of [r, ...n(r)].reverse())
      cD(s, t);
  } else
    for (const n of e)
      for (const r of n.files)
        t.addFile(r);
  return t;
}
function uie() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    kind: "registry",
    types: e,
    extendees: t,
    [Symbol.iterator]() {
      return e.values();
    },
    get files() {
      return n.values();
    },
    addFile(r, a, o) {
      if (n.set(r.proto.name, r), !a)
        for (const s of NN(r))
          this.add(s);
      if (o)
        for (const s of r.dependencies)
          this.addFile(s, a, o);
    },
    add(r) {
      if (r.kind == "extension") {
        let a = t.get(r.extendee.typeName);
        a || t.set(
          r.extendee.typeName,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = /* @__PURE__ */ new Map()
        ), a.set(r.number, r);
      }
      e.set(r.typeName, r);
    },
    get(r) {
      return e.get(r);
    },
    getFile(r) {
      return n.get(r);
    },
    getMessage(r) {
      const a = e.get(r);
      return a?.kind == "message" ? a : void 0;
    },
    getEnum(r) {
      const a = e.get(r);
      return a?.kind == "enum" ? a : void 0;
    },
    getExtension(r) {
      const a = e.get(r);
      return a?.kind == "extension" ? a : void 0;
    },
    getExtensionFor(r, a) {
      var o;
      return (o = t.get(r.typeName)) === null || o === void 0 ? void 0 : o.get(a);
    },
    getService(r) {
      const a = e.get(r);
      return a?.kind == "service" ? a : void 0;
    }
  };
}
const lie = 998, cie = 999, fie = 9, ec = 10, Wu = 11, mie = 12, sD = 14, _1 = 3, die = 2, iD = 1, pie = 0, uD = 1, lD = 2, bie = 3, gie = 1, hie = 2, yie = 1, Rx = {
  // EDITION_PROTO2
  998: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 2,
    // CLOSED,
    repeatedFieldEncoding: 2,
    // EXPANDED,
    utf8Validation: 3,
    // NONE,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 2,
    // LEGACY_BEST_EFFORT,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_PROTO3
  999: {
    fieldPresence: 2,
    // IMPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2023
  1e3: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2024
  1001: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 1,
    // STYLE2024,
    defaultSymbolVisibility: 2
    // EXPORT_TOP_LEVEL,
  }
};
function cD(e, t) {
  var n, r;
  const a = {
    kind: "file",
    proto: e,
    deprecated: (r = (n = e.options) === null || n === void 0 ? void 0 : n.deprecated) !== null && r !== void 0 ? r : !1,
    edition: Tie(e),
    name: e.name.replace(/\.proto$/, ""),
    dependencies: Iie(e, t),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${e.name}`;
    }
  }, o = /* @__PURE__ */ new Map(), s = {
    get(i) {
      return o.get(i);
    },
    add(i) {
      var u;
      ur(((u = i.proto.options) === null || u === void 0 ? void 0 : u.mapEntry) === !0), o.set(i.typeName, i);
    }
  };
  for (const i of e.enumType)
    $x(i, a, void 0, t);
  for (const i of e.messageType)
    Px(i, a, void 0, t, s);
  for (const i of e.service)
    Nie(i, a, t);
  EN(a, t);
  for (const i of o.values())
    vN(i, t, s);
  for (const i of a.messages)
    vN(i, t, s), EN(i, t);
  t.addFile(a, !0);
}
function EN(e, t) {
  switch (e.kind) {
    case "file":
      for (const n of e.proto.extension) {
        const r = TN(n, e, t);
        e.extensions.push(r), t.add(r);
      }
      break;
    case "message":
      for (const n of e.proto.extension) {
        const r = TN(n, e, t);
        e.nestedExtensions.push(r), t.add(r);
      }
      for (const n of e.nestedMessages)
        EN(n, t);
      break;
  }
}
function vN(e, t, n) {
  const r = e.proto.oneofDecl.map((o) => vie(o, e)), a = /* @__PURE__ */ new Set();
  for (const o of e.proto.field) {
    const s = Oie(o, r), i = TN(o, e, t, s, n);
    e.fields.push(i), e.field[i.localName] = i, s === void 0 ? e.members.push(i) : (s.fields.push(i), a.has(s) || (a.add(s), e.members.push(s)));
  }
  for (const o of r.filter((s) => a.has(s)))
    e.oneofs.push(o);
  for (const o of e.nestedMessages)
    vN(o, t, n);
}
function $x(e, t, n, r) {
  var a, o, s, i, u;
  const l = wie(e.name, e.value), c = {
    kind: "enum",
    proto: e,
    deprecated: (o = (a = e.options) === null || a === void 0 ? void 0 : a.deprecated) !== null && o !== void 0 ? o : !1,
    file: t,
    parent: n,
    open: !0,
    name: e.name,
    typeName: Xb(e, n, t),
    value: {},
    values: [],
    sharedPrefix: l,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  c.open = Aie(c), r.add(c);
  for (const f of e.value) {
    const d = f.name;
    c.values.push(
      // biome-ignore lint/suspicious/noAssignInExpressions: no
      c.value[f.number] = {
        kind: "enum_value",
        proto: f,
        deprecated: (i = (s = f.options) === null || s === void 0 ? void 0 : s.deprecated) !== null && i !== void 0 ? i : !1,
        parent: c,
        name: d,
        localName: Ql(l == null ? d : d.substring(l.length)),
        number: f.number,
        toString() {
          return `enum value ${c.typeName}.${d}`;
        }
      }
    );
  }
  ((u = n?.nestedEnums) !== null && u !== void 0 ? u : t.enums).push(c);
}
function Px(e, t, n, r, a) {
  var o, s, i, u;
  const l = {
    kind: "message",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    file: t,
    parent: n,
    name: e.name,
    typeName: Xb(e, n, t),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  ((i = e.options) === null || i === void 0 ? void 0 : i.mapEntry) === !0 ? a.add(l) : (((u = n?.nestedMessages) !== null && u !== void 0 ? u : t.messages).push(l), r.add(l));
  for (const c of e.enumType)
    $x(c, t, l, r);
  for (const c of e.nestedType)
    Px(c, t, l, r, a);
}
function Nie(e, t, n) {
  var r, a;
  const o = {
    kind: "service",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    file: t,
    name: e.name,
    typeName: Xb(e, void 0, t),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  t.services.push(o), n.add(o);
  for (const s of e.method) {
    const i = Eie(s, o, n);
    o.methods.push(i), o.method[i.localName] = i;
  }
}
function Eie(e, t, n) {
  var r, a, o, s;
  let i;
  e.clientStreaming && e.serverStreaming ? i = "bidi_streaming" : e.clientStreaming ? i = "client_streaming" : e.serverStreaming ? i = "server_streaming" : i = "unary";
  const u = n.getMessage(Na(e.inputType)), l = n.getMessage(Na(e.outputType));
  ur(u, `invalid MethodDescriptorProto: input_type ${e.inputType} not found`), ur(l, `invalid MethodDescriptorProto: output_type ${e.inputType} not found`);
  const c = e.name;
  return {
    kind: "rpc",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    parent: t,
    name: c,
    localName: Ql(c.length ? Ql(c[0].toLowerCase() + c.substring(1)) : c),
    methodKind: i,
    input: u,
    output: l,
    idempotency: (s = (o = e.options) === null || o === void 0 ? void 0 : o.idempotencyLevel) !== null && s !== void 0 ? s : pie,
    toString() {
      return `rpc ${t.typeName}.${c}`;
    }
  };
}
function vie(e, t) {
  return {
    kind: "oneof",
    proto: e,
    deprecated: !1,
    parent: t,
    fields: [],
    name: e.name,
    localName: Ql(ql(e.name)),
    toString() {
      return `oneof ${t.typeName}.${this.name}`;
    }
  };
}
function TN(e, t, n, r, a) {
  var o, s, i;
  const u = a === void 0, l = {
    kind: "field",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    name: e.name,
    number: e.number,
    scalar: void 0,
    message: void 0,
    enum: void 0,
    presence: Sie(e, r, u, t),
    listKind: void 0,
    mapKind: void 0,
    mapKey: void 0,
    delimitedEncoding: void 0,
    packed: void 0,
    longAsString: !1,
    getDefaultValue: void 0
  };
  if (u) {
    const m = t.kind == "file" ? t : t.file, p = t.kind == "file" ? void 0 : t, b = Xb(e, p, m);
    l.kind = "extension", l.file = m, l.parent = p, l.oneof = void 0, l.typeName = b, l.jsonName = `[${b}]`, l.toString = () => `extension ${b}`;
    const g = n.getMessage(Na(e.extendee));
    ur(g, `invalid FieldDescriptorProto: extendee ${e.extendee} not found`), l.extendee = g;
  } else {
    const m = t;
    ur(m.kind == "message"), l.parent = m, l.oneof = r, l.localName = r ? ql(e.name) : Ql(ql(e.name)), l.jsonName = e.jsonName, l.toString = () => `field ${m.typeName}.${e.name}`;
  }
  const c = e.label, f = e.type, d = (i = e.options) === null || i === void 0 ? void 0 : i.jstype;
  if (c === _1) {
    const m = f == Wu ? a?.get(Na(e.typeName)) : void 0;
    if (m) {
      l.fieldKind = "map";
      const { key: p, value: b } = kie(m);
      return l.mapKey = p.scalar, l.mapKind = b.fieldKind, l.message = b.message, l.delimitedEncoding = !1, l.enum = b.enum, l.scalar = b.scalar, l;
    }
    switch (l.fieldKind = "list", f) {
      case Wu:
      case ec:
        l.listKind = "message", l.message = n.getMessage(Na(e.typeName)), ur(l.message), l.delimitedEncoding = fD(e, t);
        break;
      case sD:
        l.listKind = "enum", l.enum = n.getEnum(Na(e.typeName)), ur(l.enum);
        break;
      default:
        l.listKind = "scalar", l.scalar = f, l.longAsString = d == iD;
        break;
    }
    return l.packed = Die(e, t), l;
  }
  switch (f) {
    case Wu:
    case ec:
      l.fieldKind = "message", l.message = n.getMessage(Na(e.typeName)), ur(l.message, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.delimitedEncoding = fD(e, t), l.getDefaultValue = () => {
      };
      break;
    case sD: {
      const m = n.getEnum(Na(e.typeName));
      ur(m !== void 0, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.fieldKind = "enum", l.enum = n.getEnum(Na(e.typeName)), l.getDefaultValue = () => zl(e, "defaultValue") ? oie(m, e.defaultValue) : void 0;
      break;
    }
    default: {
      l.fieldKind = "scalar", l.scalar = f, l.longAsString = d == iD, l.getDefaultValue = () => zl(e, "defaultValue") ? sie(f, e.defaultValue) : void 0;
      break;
    }
  }
  return l;
}
function Tie(e) {
  switch (e.syntax) {
    case "":
    case "proto2":
      return lie;
    case "proto3":
      return cie;
    case "editions":
      if (e.edition in Rx)
        return e.edition;
      throw new Error(`${e.name}: unsupported edition`);
    default:
      throw new Error(`${e.name}: unsupported syntax "${e.syntax}"`);
  }
}
function Iie(e, t) {
  return e.dependency.map((n) => {
    const r = t.getFile(n);
    if (!r)
      throw new Error(`Cannot find ${n}, imported by ${e.name}`);
    return r;
  });
}
function wie(e, t) {
  const n = _ie(e) + "_";
  for (const r of t) {
    if (!r.name.toLowerCase().startsWith(n))
      return;
    const a = r.name.substring(n.length);
    if (a.length == 0 || /^\d/.test(a))
      return;
  }
  return n;
}
function _ie(e) {
  return (e.substring(0, 1) + e.substring(1).replace(/[A-Z]/g, (t) => "_" + t)).toLowerCase();
}
function Xb(e, t, n) {
  let r;
  return t ? r = `${t.typeName}.${e.name}` : n.proto.package.length > 0 ? r = `${n.proto.package}.${e.name}` : r = `${e.name}`, r;
}
function Na(e) {
  return e.startsWith(".") ? e.substring(1) : e;
}
function Oie(e, t) {
  if (!zl(e, "oneofIndex") || e.proto3Optional)
    return;
  const n = t[e.oneofIndex];
  return ur(n, `invalid FieldDescriptorProto: oneof #${e.oneofIndex} for field #${e.number} not found`), n;
}
function Sie(e, t, n, r) {
  if (e.label == die)
    return bie;
  if (e.label == _1)
    return lD;
  if (t || e.proto3Optional || n)
    return uD;
  const a = au("fieldPresence", { proto: e, parent: r });
  return a == lD && (e.type == Wu || e.type == ec) ? uD : a;
}
function Die(e, t) {
  if (e.label != _1)
    return !1;
  switch (e.type) {
    case fie:
    case mie:
    case ec:
    case Wu:
      return !1;
  }
  const n = e.options;
  return n && zl(n, "packed") ? n.packed : gie == au("repeatedFieldEncoding", {
    proto: e,
    parent: t
  });
}
function kie(e) {
  const t = e.fields.find((r) => r.number === 1), n = e.fields.find((r) => r.number === 2);
  return ur(t && t.fieldKind == "scalar" && t.scalar != I.BYTES && t.scalar != I.FLOAT && t.scalar != I.DOUBLE && n && n.fieldKind != "list" && n.fieldKind != "map"), { key: t, value: n };
}
function Aie(e) {
  var t;
  return yie == au("enumType", {
    proto: e.proto,
    parent: (t = e.parent) !== null && t !== void 0 ? t : e.file
  });
}
function fD(e, t) {
  return e.type == ec ? !0 : hie == au("messageEncoding", {
    proto: e,
    parent: t
  });
}
function au(e, t) {
  var n, r;
  const a = (n = t.proto.options) === null || n === void 0 ? void 0 : n.features;
  if (a) {
    const o = a[e];
    if (o != 0)
      return o;
  }
  if ("kind" in t) {
    if (t.kind == "message")
      return au(e, (r = t.parent) !== null && r !== void 0 ? r : t.file);
    const o = Rx[t.edition];
    if (!o)
      throw new Error(`feature default for edition ${t.edition} not found`);
    return o[e];
  }
  return au(e, t.parent);
}
function ur(e, t) {
  if (!e)
    throw new Error(t);
}
function Lie(e) {
  const t = Fie(e);
  return t.messageType.forEach(w1), Ux(t, () => {
  }).getFile(t.name);
}
function Fie(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    syntax: "",
    edition: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, e), { messageType: e.messageType.map(Vx), enumType: e.enumType.map(xx) }));
}
function Vx(e) {
  var t, n, r, a, o, s, i, u;
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.DescriptorProto",
    name: e.name,
    field: (n = (t = e.field) === null || t === void 0 ? void 0 : t.map(Uie)) !== null && n !== void 0 ? n : [],
    extension: [],
    nestedType: (a = (r = e.nestedType) === null || r === void 0 ? void 0 : r.map(Vx)) !== null && a !== void 0 ? a : [],
    enumType: (s = (o = e.enumType) === null || o === void 0 ? void 0 : o.map(xx)) !== null && s !== void 0 ? s : [],
    extensionRange: (u = (i = e.extensionRange) === null || i === void 0 ? void 0 : i.map((l) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, l))) !== null && u !== void 0 ? u : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function Uie(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: !1
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, e), { options: e.options ? Rie(e.options) : void 0 }));
}
function Rie(e) {
  var t, n, r;
  return Object.assign(/* @__PURE__ */ Object.create({
    ctype: 0,
    packed: !1,
    jstype: 0,
    lazy: !1,
    unverifiedLazy: !1,
    deprecated: !1,
    weak: !1,
    debugRedact: !1,
    retention: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, e), { targets: (t = e.targets) !== null && t !== void 0 ? t : [], editionDefaults: (r = (n = e.editionDefaults) === null || n === void 0 ? void 0 : n.map((a) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, a))) !== null && r !== void 0 ? r : [], uninterpretedOption: [] }));
}
function xx(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: e.name,
    reservedName: [],
    reservedRange: [],
    value: e.value.map((t) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, t))
  });
}
function Tf(e, t, ...n) {
  return n.reduce((r, a) => r.nestedMessages[a], e.messages[t]);
}
const $ie = /* @__PURE__ */ Lie({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: !0 } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false", options: { deprecated: !0 } }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1e3 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1e3, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: !0 } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1e3 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_UNSTABLE", number: 9999 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] }), Pie = /* @__PURE__ */ Tf($ie, 1);
var mD;
(function(e) {
  e[e.DECLARATION = 0] = "DECLARATION", e[e.UNVERIFIED = 1] = "UNVERIFIED";
})(mD || (mD = {}));
var dD;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.GROUP = 10] = "GROUP", e[e.MESSAGE = 11] = "MESSAGE", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.ENUM = 14] = "ENUM", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(dD || (dD = {}));
var pD;
(function(e) {
  e[e.OPTIONAL = 1] = "OPTIONAL", e[e.REPEATED = 3] = "REPEATED", e[e.REQUIRED = 2] = "REQUIRED";
})(pD || (pD = {}));
var bD;
(function(e) {
  e[e.SPEED = 1] = "SPEED", e[e.CODE_SIZE = 2] = "CODE_SIZE", e[e.LITE_RUNTIME = 3] = "LITE_RUNTIME";
})(bD || (bD = {}));
var gD;
(function(e) {
  e[e.STRING = 0] = "STRING", e[e.CORD = 1] = "CORD", e[e.STRING_PIECE = 2] = "STRING_PIECE";
})(gD || (gD = {}));
var hD;
(function(e) {
  e[e.JS_NORMAL = 0] = "JS_NORMAL", e[e.JS_STRING = 1] = "JS_STRING", e[e.JS_NUMBER = 2] = "JS_NUMBER";
})(hD || (hD = {}));
var yD;
(function(e) {
  e[e.RETENTION_UNKNOWN = 0] = "RETENTION_UNKNOWN", e[e.RETENTION_RUNTIME = 1] = "RETENTION_RUNTIME", e[e.RETENTION_SOURCE = 2] = "RETENTION_SOURCE";
})(yD || (yD = {}));
var ND;
(function(e) {
  e[e.TARGET_TYPE_UNKNOWN = 0] = "TARGET_TYPE_UNKNOWN", e[e.TARGET_TYPE_FILE = 1] = "TARGET_TYPE_FILE", e[e.TARGET_TYPE_EXTENSION_RANGE = 2] = "TARGET_TYPE_EXTENSION_RANGE", e[e.TARGET_TYPE_MESSAGE = 3] = "TARGET_TYPE_MESSAGE", e[e.TARGET_TYPE_FIELD = 4] = "TARGET_TYPE_FIELD", e[e.TARGET_TYPE_ONEOF = 5] = "TARGET_TYPE_ONEOF", e[e.TARGET_TYPE_ENUM = 6] = "TARGET_TYPE_ENUM", e[e.TARGET_TYPE_ENUM_ENTRY = 7] = "TARGET_TYPE_ENUM_ENTRY", e[e.TARGET_TYPE_SERVICE = 8] = "TARGET_TYPE_SERVICE", e[e.TARGET_TYPE_METHOD = 9] = "TARGET_TYPE_METHOD";
})(ND || (ND = {}));
var IN;
(function(e) {
  e[e.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e[e.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e[e.IDEMPOTENT = 2] = "IDEMPOTENT";
})(IN || (IN = {}));
var ED;
(function(e) {
  e[e.DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", e[e.EXPORT_ALL = 1] = "EXPORT_ALL", e[e.EXPORT_TOP_LEVEL = 2] = "EXPORT_TOP_LEVEL", e[e.LOCAL_ALL = 3] = "LOCAL_ALL", e[e.STRICT = 4] = "STRICT";
})(ED || (ED = {}));
var vD;
(function(e) {
  e[e.FIELD_PRESENCE_UNKNOWN = 0] = "FIELD_PRESENCE_UNKNOWN", e[e.EXPLICIT = 1] = "EXPLICIT", e[e.IMPLICIT = 2] = "IMPLICIT", e[e.LEGACY_REQUIRED = 3] = "LEGACY_REQUIRED";
})(vD || (vD = {}));
var TD;
(function(e) {
  e[e.ENUM_TYPE_UNKNOWN = 0] = "ENUM_TYPE_UNKNOWN", e[e.OPEN = 1] = "OPEN", e[e.CLOSED = 2] = "CLOSED";
})(TD || (TD = {}));
var ID;
(function(e) {
  e[e.REPEATED_FIELD_ENCODING_UNKNOWN = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN", e[e.PACKED = 1] = "PACKED", e[e.EXPANDED = 2] = "EXPANDED";
})(ID || (ID = {}));
var wD;
(function(e) {
  e[e.UTF8_VALIDATION_UNKNOWN = 0] = "UTF8_VALIDATION_UNKNOWN", e[e.VERIFY = 2] = "VERIFY", e[e.NONE = 3] = "NONE";
})(wD || (wD = {}));
var _D;
(function(e) {
  e[e.MESSAGE_ENCODING_UNKNOWN = 0] = "MESSAGE_ENCODING_UNKNOWN", e[e.LENGTH_PREFIXED = 1] = "LENGTH_PREFIXED", e[e.DELIMITED = 2] = "DELIMITED";
})(_D || (_D = {}));
var OD;
(function(e) {
  e[e.JSON_FORMAT_UNKNOWN = 0] = "JSON_FORMAT_UNKNOWN", e[e.ALLOW = 1] = "ALLOW", e[e.LEGACY_BEST_EFFORT = 2] = "LEGACY_BEST_EFFORT";
})(OD || (OD = {}));
var SD;
(function(e) {
  e[e.ENFORCE_NAMING_STYLE_UNKNOWN = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN", e[e.STYLE2024 = 1] = "STYLE2024", e[e.STYLE_LEGACY = 2] = "STYLE_LEGACY";
})(SD || (SD = {}));
var DD;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SET = 1] = "SET", e[e.ALIAS = 2] = "ALIAS";
})(DD || (DD = {}));
var kD;
(function(e) {
  e[e.EDITION_UNKNOWN = 0] = "EDITION_UNKNOWN", e[e.EDITION_LEGACY = 900] = "EDITION_LEGACY", e[e.EDITION_PROTO2 = 998] = "EDITION_PROTO2", e[e.EDITION_PROTO3 = 999] = "EDITION_PROTO3", e[e.EDITION_2023 = 1e3] = "EDITION_2023", e[e.EDITION_2024 = 1001] = "EDITION_2024", e[e.EDITION_UNSTABLE = 9999] = "EDITION_UNSTABLE", e[e.EDITION_1_TEST_ONLY = 1] = "EDITION_1_TEST_ONLY", e[e.EDITION_2_TEST_ONLY = 2] = "EDITION_2_TEST_ONLY", e[e.EDITION_99997_TEST_ONLY = 99997] = "EDITION_99997_TEST_ONLY", e[e.EDITION_99998_TEST_ONLY = 99998] = "EDITION_99998_TEST_ONLY", e[e.EDITION_99999_TEST_ONLY = 99999] = "EDITION_99999_TEST_ONLY", e[e.EDITION_MAX = 2147483647] = "EDITION_MAX";
})(kD || (kD = {}));
var AD;
(function(e) {
  e[e.VISIBILITY_UNSET = 0] = "VISIBILITY_UNSET", e[e.VISIBILITY_LOCAL = 1] = "VISIBILITY_LOCAL", e[e.VISIBILITY_EXPORT = 2] = "VISIBILITY_EXPORT";
})(AD || (AD = {}));
const LD = {
  readUnknownFields: !0
};
function Vie(e) {
  return e ? Object.assign(Object.assign({}, LD), e) : LD;
}
function Wb(e, t, n) {
  const r = qn(e, void 0, !1);
  return Yx(r, new h1(t), Vie(n), !1, t.byteLength), r.message;
}
function Yx(e, t, n, r, a) {
  var o;
  const s = r ? t.len : t.pos + a;
  let i, u;
  const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
  for (; t.pos < s && ([i, u] = t.tag(), !(r && u == ce.EndGroup)); ) {
    const c = e.findNumber(i);
    if (!c) {
      const f = t.skip(u, i);
      n.readUnknownFields && l.push({ no: i, wireType: u, data: f });
      continue;
    }
    jx(e, t, c, u, n);
  }
  if (r && (u != ce.EndGroup || i !== a))
    throw new Error("invalid end group tag");
  l.length > 0 && e.setUnknown(l);
}
function jx(e, t, n, r, a) {
  var o;
  switch (n.fieldKind) {
    case "scalar":
      e.set(n, ou(t, n.scalar));
      break;
    case "enum":
      const s = ou(t, I.INT32);
      if (n.enum.open)
        e.set(n, s);
      else if (n.enum.values.some((i) => i.number === s))
        e.set(n, s);
      else if (a.readUnknownFields) {
        const i = [];
        yN(s, i);
        const u = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
        u.push({
          no: n.number,
          wireType: r,
          data: new Uint8Array(i)
        }), e.setUnknown(u);
      }
      break;
    case "message":
      e.set(n, O1(t, a, n, e.get(n)));
      break;
    case "list":
      Yie(t, r, e.get(n), a);
      break;
    case "map":
      xie(t, e.get(n), a);
      break;
  }
}
function xie(e, t, n) {
  const r = t.field();
  let a, o;
  const s = e.uint32(), i = e.pos + s;
  for (; e.pos < i; ) {
    const [u] = e.tag();
    switch (u) {
      case 1:
        a = ou(e, r.mapKey);
        break;
      case 2:
        switch (r.mapKind) {
          case "scalar":
            o = ou(e, r.scalar);
            break;
          case "enum":
            o = e.int32();
            break;
          case "message":
            o = O1(e, n, r);
            break;
        }
        break;
    }
  }
  if (a === void 0 && (a = Ks(r.mapKey, !1)), o === void 0)
    switch (r.mapKind) {
      case "scalar":
        o = Ks(r.scalar, !1);
        break;
      case "enum":
        o = r.enum.values[0].number;
        break;
      case "message":
        o = qn(r.message, void 0, !1);
        break;
    }
  t.set(a, o);
}
function Yie(e, t, n, r) {
  var a;
  const o = n.field();
  if (o.listKind === "message") {
    n.add(O1(e, r, o));
    return;
  }
  const s = (a = o.scalar) !== null && a !== void 0 ? a : I.INT32;
  if (!(t == ce.LengthDelimited && s != I.STRING && s != I.BYTES)) {
    n.add(ou(e, s));
    return;
  }
  const i = e.uint32() + e.pos;
  for (; e.pos < i; )
    n.add(ou(e, s));
}
function O1(e, t, n, r) {
  const a = n.delimitedEncoding, o = r ?? qn(n.message, void 0, !1);
  return Yx(o, e, t, a, a ? n.number : e.uint32()), o;
}
function ou(e, t) {
  switch (t) {
    case I.STRING:
      return e.string();
    case I.BOOL:
      return e.bool();
    case I.DOUBLE:
      return e.double();
    case I.FLOAT:
      return e.float();
    case I.INT32:
      return e.int32();
    case I.INT64:
      return e.int64();
    case I.UINT64:
      return e.uint64();
    case I.FIXED64:
      return e.fixed64();
    case I.BYTES:
      return e.bytes();
    case I.FIXED32:
      return e.fixed32();
    case I.SFIXED32:
      return e.sfixed32();
    case I.SFIXED64:
      return e.sfixed64();
    case I.SINT64:
      return e.sint64();
    case I.UINT32:
      return e.uint32();
    case I.SINT32:
      return e.sint32();
  }
}
function Bx(e, t) {
  var n;
  const r = Wb(Pie, I1(e));
  return r.messageType.forEach(w1), r.dependency = (n = void 0) !== null && n !== void 0 ? n : [], Ux(r, (a) => {
  }).getFile(r.name);
}
const jie = /* @__PURE__ */ Bx("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), Bie = /* @__PURE__ */ Tf(jie, 0), Gie = 3, FD = {
  writeUnknownFields: !0
};
function Mie(e) {
  return e ? Object.assign(Object.assign({}, FD), e) : FD;
}
function Gx(e, t, n) {
  return vp(new vx(), Mie(n), qn(e, t)).finish();
}
function vp(e, t, n) {
  var r;
  for (const a of n.sortedFields) {
    if (!n.isSet(a)) {
      if (a.presence == Gie)
        throw new Error(`cannot encode ${a} to binary: required field not set`);
      continue;
    }
    Mx(e, t, n, a);
  }
  if (t.writeUnknownFields)
    for (const { no: a, wireType: o, data: s } of (r = n.getUnknown()) !== null && r !== void 0 ? r : [])
      e.tag(a, o).raw(s);
  return e;
}
function Mx(e, t, n, r) {
  var a;
  switch (r.fieldKind) {
    case "scalar":
    case "enum":
      Tp(e, n.desc.typeName, r.name, (a = r.scalar) !== null && a !== void 0 ? a : I.INT32, r.number, n.get(r));
      break;
    case "list":
      Cie(e, t, r, n.get(r));
      break;
    case "message":
      Cx(e, t, r, n.get(r));
      break;
    case "map":
      for (const [o, s] of n.get(r))
        Kie(e, t, r, o, s);
      break;
  }
}
function Tp(e, t, n, r, a, o) {
  Kx(e.tag(a, Xie(r)), t, n, r, o);
}
function Cx(e, t, n, r) {
  n.delimitedEncoding ? vp(e.tag(n.number, ce.StartGroup), t, r).tag(n.number, ce.EndGroup) : vp(e.tag(n.number, ce.LengthDelimited).fork(), t, r).join();
}
function Cie(e, t, n, r) {
  var a;
  if (n.listKind == "message") {
    for (const s of r)
      Cx(e, t, n, s);
    return;
  }
  const o = (a = n.scalar) !== null && a !== void 0 ? a : I.INT32;
  if (n.packed) {
    if (!r.size)
      return;
    e.tag(n.number, ce.LengthDelimited).fork();
    for (const s of r)
      Kx(e, n.parent.typeName, n.name, o, s);
    e.join();
    return;
  }
  for (const s of r)
    Tp(e, n.parent.typeName, n.name, o, n.number, s);
}
function Kie(e, t, n, r, a) {
  var o;
  switch (e.tag(n.number, ce.LengthDelimited).fork(), Tp(e, n.parent.typeName, n.name, n.mapKey, 1, r), n.mapKind) {
    case "scalar":
    case "enum":
      Tp(e, n.parent.typeName, n.name, (o = n.scalar) !== null && o !== void 0 ? o : I.INT32, 2, a);
      break;
    case "message":
      vp(e.tag(2, ce.LengthDelimited).fork(), t, a).join();
      break;
  }
  e.join();
}
function Kx(e, t, n, r, a) {
  try {
    switch (r) {
      case I.STRING:
        e.string(a);
        break;
      case I.BOOL:
        e.bool(a);
        break;
      case I.DOUBLE:
        e.double(a);
        break;
      case I.FLOAT:
        e.float(a);
        break;
      case I.INT32:
        e.int32(a);
        break;
      case I.INT64:
        e.int64(a);
        break;
      case I.UINT64:
        e.uint64(a);
        break;
      case I.FIXED64:
        e.fixed64(a);
        break;
      case I.BYTES:
        e.bytes(a);
        break;
      case I.FIXED32:
        e.fixed32(a);
        break;
      case I.SFIXED32:
        e.sfixed32(a);
        break;
      case I.SFIXED64:
        e.sfixed64(a);
        break;
      case I.SINT64:
        e.sint64(a);
        break;
      case I.UINT32:
        e.uint32(a);
        break;
      case I.SINT32:
        e.sint32(a);
        break;
    }
  } catch (o) {
    throw o instanceof Error ? new Error(`cannot encode field ${t}.${n} to binary: ${o.message}`) : o;
  }
}
function Xie(e) {
  switch (e) {
    case I.BYTES:
    case I.STRING:
      return ce.LengthDelimited;
    case I.DOUBLE:
    case I.FIXED64:
    case I.SFIXED64:
      return ce.Bit64;
    case I.FIXED32:
    case I.SFIXED32:
    case I.FLOAT:
      return ce.Bit32;
    default:
      return ce.Varint;
  }
}
function Wie(e, t, n) {
  let r = !1;
  return n || (n = wr(Bie), r = !0), n.value = Gx(e, t), n.typeUrl = Hie(t.$typeName), r ? n : void 0;
}
function Jie(e, t) {
  if (e.typeUrl === "")
    return !1;
  const n = typeof t == "string" ? t : t.typeName, r = Xx(e.typeUrl);
  return n === r;
}
function Zie(e, t) {
  if (e.typeUrl === "")
    return;
  const n = t.kind == "message" ? t : t.getMessage(Xx(e.typeUrl));
  if (!(!n || !Jie(e, n)))
    return Wb(n, e.value);
}
function Hie(e) {
  return `type.googleapis.com/${e}`;
}
function Xx(e) {
  const t = e.lastIndexOf("/"), n = t >= 0 ? e.substring(t + 1) : e;
  if (!n.length)
    throw new Error(`invalid type url: ${e}`);
  return n;
}
const S1 = /* @__PURE__ */ Bx("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), zie = /* @__PURE__ */ Tf(S1, 0), Wx = /* @__PURE__ */ Tf(S1, 1), qie = /* @__PURE__ */ Tf(S1, 2);
var wN;
(function(e) {
  e[e.NULL_VALUE = 0] = "NULL_VALUE";
})(wN || (wN = {}));
function Qie(e, t) {
  Jx(t, e);
  const n = tue(e.$unknown, t), [r, a, o] = Jb(t);
  for (const s of n)
    jx(r, new h1(s.data), a, s.wireType, {
      readUnknownFields: !0
    });
  return o();
}
function eue(e, t, n) {
  var r;
  Jx(t, e);
  const a = ((r = e.$unknown) !== null && r !== void 0 ? r : []).filter((l) => l.no !== t.number), [o, s] = Jb(t, n), i = new vx();
  Mx(i, { writeUnknownFields: !0 }, o, s);
  const u = new h1(i.finish());
  for (; u.pos < u.len; ) {
    const [l, c] = u.tag(), f = u.skip(c, l);
    a.push({ no: l, wireType: c, data: f });
  }
  e.$unknown = a;
}
function tue(e, t) {
  if (e === void 0)
    return [];
  if (t.fieldKind === "enum" || t.fieldKind === "scalar") {
    for (let n = e.length - 1; n >= 0; --n)
      if (e[n].no == t.number)
        return [e[n]];
    return [];
  }
  return e.filter((n) => n.no === t.number);
}
function Jb(e, t) {
  const n = e.typeName, r = Object.assign(Object.assign({}, e), { kind: "field", parent: e.extendee, localName: n }), a = Object.assign(Object.assign({}, e.extendee), { fields: [r], members: [r], oneofs: [] }), o = wr(a, t !== void 0 ? { [n]: t } : void 0);
  return [
    qn(a, o),
    r,
    () => {
      const s = o[n];
      if (s === void 0) {
        const i = e.message;
        return vf(i) ? Ks(i.fields[0].scalar, i.fields[0].longAsString) : wr(i);
      }
      return s;
    }
  ];
}
function Jx(e, t) {
  if (e.extendee.typeName != t.$typeName)
    throw new Error(`extension ${e.typeName} can only be applied to message ${e.extendee.typeName}`);
}
const nue = 3, rue = 2, UD = {
  alwaysEmitImplicit: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1
};
function aue(e) {
  return e ? Object.assign(Object.assign({}, UD), e) : UD;
}
function oue(e, t, n) {
  return If(qn(e, t), aue(n));
}
function sue(e, t, n) {
  var r;
  const a = oue(e, t, n);
  return JSON.stringify(a, null, (r = n?.prettySpaces) !== null && r !== void 0 ? r : 0);
}
function If(e, t) {
  var n;
  const r = cue(e, t);
  if (r !== void 0)
    return r;
  const a = {};
  for (const o of e.sortedFields) {
    if (!e.isSet(o)) {
      if (o.presence == nue)
        throw new Error(`cannot encode ${o} to JSON: required field not set`);
      if (!t.alwaysEmitImplicit || o.presence !== rue)
        continue;
    }
    const s = RD(o, e.get(o), t);
    s !== void 0 && (a[lue(o, t)] = s);
  }
  if (t.registry) {
    const o = /* @__PURE__ */ new Set();
    for (const { no: s } of (n = e.getUnknown()) !== null && n !== void 0 ? n : [])
      if (!o.has(s)) {
        o.add(s);
        const i = t.registry.getExtensionFor(e.desc, s);
        if (!i)
          continue;
        const u = Qie(e.message, i), [l, c] = Jb(i, u), f = RD(c, l.get(c), t);
        f !== void 0 && (a[i.jsonName] = f);
      }
  }
  return a;
}
function RD(e, t, n) {
  switch (e.fieldKind) {
    case "scalar":
      return Zb(e, t);
    case "message":
      return If(t, n);
    case "enum":
      return D1(e.enum, t, n.enumAsInteger);
    case "list":
      return uue(t, n);
    case "map":
      return iue(t, n);
  }
}
function iue(e, t) {
  const n = e.field(), r = {};
  switch (n.mapKind) {
    case "scalar":
      for (const [a, o] of e)
        r[a] = Zb(n, o);
      break;
    case "message":
      for (const [a, o] of e)
        r[a] = If(o, t);
      break;
    case "enum":
      for (const [a, o] of e)
        r[a] = D1(n.enum, o, t.enumAsInteger);
      break;
  }
  return t.alwaysEmitImplicit || e.size > 0 ? r : void 0;
}
function uue(e, t) {
  const n = e.field(), r = [];
  switch (n.listKind) {
    case "scalar":
      for (const a of e)
        r.push(Zb(n, a));
      break;
    case "enum":
      for (const a of e)
        r.push(D1(n.enum, a, t.enumAsInteger));
      break;
    case "message":
      for (const a of e)
        r.push(If(a, t));
      break;
  }
  return t.alwaysEmitImplicit || r.length > 0 ? r : void 0;
}
function D1(e, t, n) {
  var r;
  if (typeof t != "number")
    throw new Error(`cannot encode ${e} to JSON: expected number, got ${je(t)}`);
  return e.typeName == "google.protobuf.NullValue" ? null : n ? t : (r = e.value[t]?.name) !== null && r !== void 0 ? r : t;
}
function Zb(e, t) {
  var n, r, a, o, s, i;
  switch (e.scalar) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case I.INT32:
    case I.SFIXED32:
    case I.SINT32:
    case I.FIXED32:
    case I.UINT32:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(n = jo(e, t)) === null || n === void 0 ? void 0 : n.message}`);
      return t;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case I.FLOAT:
    case I.DOUBLE:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(r = jo(e, t)) === null || r === void 0 ? void 0 : r.message}`);
      return Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    // string:
    case I.STRING:
      if (typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(a = jo(e, t)) === null || a === void 0 ? void 0 : a.message}`);
      return t;
    // bool:
    case I.BOOL:
      if (typeof t != "boolean")
        throw new Error(`cannot encode ${e} to JSON: ${(o = jo(e, t)) === null || o === void 0 ? void 0 : o.message}`);
      return t;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case I.UINT64:
    case I.FIXED64:
    case I.INT64:
    case I.SFIXED64:
    case I.SINT64:
      if (typeof t != "bigint" && typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(s = jo(e, t)) === null || s === void 0 ? void 0 : s.message}`);
      return t.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case I.BYTES:
      if (t instanceof Uint8Array)
        return Lx(t);
      throw new Error(`cannot encode ${e} to JSON: ${(i = jo(e, t)) === null || i === void 0 ? void 0 : i.message}`);
  }
}
function lue(e, t) {
  return t.useProtoFieldName ? e.name : e.jsonName;
}
function cue(e, t) {
  if (e.desc.typeName.startsWith("google.protobuf."))
    switch (e.desc.typeName) {
      case "google.protobuf.Any":
        return fue(e.message, t);
      case "google.protobuf.Timestamp":
        return pue(e.message);
      case "google.protobuf.Duration":
        return mue(e.message);
      case "google.protobuf.FieldMask":
        return due(e.message);
      case "google.protobuf.Struct":
        return Zx(e.message);
      case "google.protobuf.Value":
        return k1(e.message);
      case "google.protobuf.ListValue":
        return Hx(e.message);
      default:
        if (vf(e.desc)) {
          const n = e.desc.fields[0];
          return Zb(n, e.get(n));
        }
        return;
    }
}
function fue(e, t) {
  if (e.typeUrl === "")
    return {};
  const { registry: n } = t;
  let r, a;
  if (n && (r = Zie(e, n), r && (a = n.getMessage(r.$typeName))), !a || !r)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: "${e.typeUrl}" is not in the type registry`);
  let o = If(qn(a, r), t);
  return (a.typeName.startsWith("google.protobuf.") || o === null || Array.isArray(o) || typeof o != "object") && (o = { value: o }), o["@type"] = e.typeUrl, o;
}
function mue(e) {
  const t = Number(e.seconds), n = e.nanos;
  if (t > 315576e6 || t < -315576e6)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: value out of range`);
  if (t > 0 && n < 0 || t < 0 && n > 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos sign must match seconds sign`);
  let r = e.seconds.toString();
  if (n !== 0) {
    let a = Math.abs(n).toString();
    a = "0".repeat(9 - a.length) + a, a.substring(3) === "000000" ? a = a.substring(0, 3) : a.substring(6) === "000" && (a = a.substring(0, 6)), r += "." + a, n < 0 && t == 0 && (r = "-" + r);
  }
  return r + "s";
}
function due(e) {
  return e.paths.map((t) => {
    if (t.match(/_[0-9]?_/g) || t.match(/[A-Z]/g))
      throw new Error(`cannot encode message ${e.$typeName} to JSON: lowerCamelCase of path name "` + t + '" is irreversible');
    return ql(t);
  }).join(",");
}
function Zx(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = k1(r);
  return t;
}
function k1(e) {
  switch (e.kind.case) {
    case "nullValue":
      return null;
    case "numberValue":
      if (!Number.isFinite(e.kind.value))
        throw new Error(`${e.$typeName} cannot be NaN or Infinity`);
      return e.kind.value;
    case "boolValue":
      return e.kind.value;
    case "stringValue":
      return e.kind.value;
    case "structValue":
      return Zx(e.kind.value);
    case "listValue":
      return Hx(e.kind.value);
    default:
      throw new Error(`${e.$typeName} must have a value`);
  }
}
function Hx(e) {
  return e.values.map(k1);
}
function pue(e) {
  const t = Number(e.seconds) * 1e3;
  if (t < Date.parse("0001-01-01T00:00:00Z") || t > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot encode message ${e.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  if (e.nanos < 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be negative`);
  if (e.nanos > 999999999)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be greater than 99999999`);
  let n = "Z";
  if (e.nanos > 0) {
    const r = (e.nanos + 1e9).toString().substring(1);
    r.substring(3) === "000000" ? n = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? n = "." + r.substring(0, 6) + "Z" : n = "." + r + "Z";
  }
  return new Date(t).toISOString().replace(".000Z", n);
}
const $D = {
  ignoreUnknownFields: !1
};
function bue(e) {
  return e ? Object.assign(Object.assign({}, $D), e) : $D;
}
function gue(e, t, n) {
  return zx(e, Iue(t, e.typeName), n);
}
function zx(e, t, n) {
  const r = qn(e);
  try {
    su(r, t, bue(n));
  } catch (a) {
    throw Hse(a) ? new Error(`cannot decode ${a.field()} from JSON: ${a.message}`, {
      cause: a
    }) : a;
  }
  return r.message;
}
function su(e, t, n) {
  var r;
  if (wue(e, t, n))
    return;
  if (t == null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode ${e.desc} from JSON: ${je(t)}`);
  const a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const s of e.desc.fields)
    o.set(s.name, s).set(s.jsonName, s);
  for (const [s, i] of Object.entries(t)) {
    const u = o.get(s);
    if (u) {
      if (u.oneof) {
        if (i === null && u.fieldKind == "scalar")
          continue;
        const l = a.get(u.oneof);
        if (l !== void 0)
          throw new Wt(u.oneof, `oneof set multiple times by ${l.name} and ${u.name}`);
        a.set(u.oneof, u);
      }
      PD(e, u, i, n);
    } else {
      let l;
      if (s.startsWith("[") && s.endsWith("]") && // biome-ignore lint/suspicious/noAssignInExpressions: no
      (l = (r = n.registry) === null || r === void 0 ? void 0 : r.getExtension(s.substring(1, s.length - 1))) && l.extendee.typeName === e.desc.typeName) {
        const [c, f, d] = Jb(l);
        PD(c, f, i, n), eue(e.message, l, d());
      }
      if (!l && !n.ignoreUnknownFields)
        throw new Error(`cannot decode ${e.desc} from JSON: key "${s}" is unknown`);
    }
  }
}
function PD(e, t, n, r) {
  switch (t.fieldKind) {
    case "scalar":
      vue(e, t, n);
      break;
    case "enum":
      Eue(e, t, n, r);
      break;
    case "message":
      Nue(e, t, n, r);
      break;
    case "list":
      yue(e.get(t), n, r);
      break;
    case "map":
      hue(e.get(t), n, r);
      break;
  }
}
function hue(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (typeof t != "object" || Array.isArray(t))
    throw new Wt(r, "expected object, got " + je(t));
  for (const [a, o] of Object.entries(t)) {
    if (o === null && !qx(r))
      throw new Wt(r, "map value must not be null");
    let s;
    switch (r.mapKind) {
      case "message":
        const u = qn(r.message);
        su(u, o, n), s = u;
        break;
      case "enum":
        if (s = A1(r.enum, o, n.ignoreUnknownFields, !0), s === Hb)
          return;
        break;
      case "scalar":
        s = qb(r, o, !0);
        break;
    }
    const i = Tue(r.mapKey, a);
    e.set(i, s);
  }
}
function yue(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (!Array.isArray(t))
    throw new Wt(r, "expected Array, got " + je(t));
  for (const a of t) {
    if (a === null && !qx(r))
      throw new Wt(r, "list item must not be null");
    switch (r.listKind) {
      case "message":
        const o = qn(r.message);
        su(o, a, n), e.add(o);
        break;
      case "enum":
        const s = A1(r.enum, a, n.ignoreUnknownFields, !0);
        s !== Hb && e.add(s);
        break;
      case "scalar":
        e.add(qb(r, a, !0));
        break;
    }
  }
}
function qx(e) {
  var t, n;
  return ((t = e.message) === null || t === void 0 ? void 0 : t.typeName) == "google.protobuf.Value" || ((n = e.enum) === null || n === void 0 ? void 0 : n.typeName) == "google.protobuf.NullValue";
}
function Nue(e, t, n, r) {
  if (n === null && t.message.typeName != "google.protobuf.Value") {
    e.clear(t);
    return;
  }
  const a = e.isSet(t) ? e.get(t) : qn(t.message);
  su(a, n, r), e.set(t, a);
}
function Eue(e, t, n, r) {
  const a = A1(t.enum, n, r.ignoreUnknownFields, !1);
  a === zb ? e.clear(t) : a !== Hb && e.set(t, a);
}
function vue(e, t, n) {
  const r = qb(t, n, !1);
  r === zb ? e.clear(t) : e.set(t, r);
}
const Hb = /* @__PURE__ */ Symbol();
function A1(e, t, n, r) {
  if (t === null)
    return e.typeName == "google.protobuf.NullValue" ? 0 : r ? e.values[0].number : zb;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const a = e.values.find((o) => o.name === t);
      if (a !== void 0)
        return a.number;
      if (n)
        return Hb;
      break;
  }
  throw new Error(`cannot decode ${e} from JSON: ${je(t)}`);
}
const zb = /* @__PURE__ */ Symbol();
function qb(e, t, n) {
  if (t === null)
    return n ? Ks(e.scalar, !1) : zb;
  switch (e.scalar) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case I.DOUBLE:
    case I.FLOAT:
      if (t === "NaN")
        return NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (typeof t == "number") {
        if (Number.isNaN(t))
          throw new Wt(e, "unexpected NaN number");
        if (!Number.isFinite(t))
          throw new Wt(e, "unexpected infinite number");
        break;
      }
      if (typeof t == "string") {
        if (t === "" || t.trim().length !== t.length)
          break;
        const r = Number(t);
        if (!Number.isFinite(r))
          break;
        return r;
      }
      break;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case I.INT32:
    case I.FIXED32:
    case I.SFIXED32:
    case I.SINT32:
    case I.UINT32:
      return Qx(t);
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case I.BYTES:
      if (typeof t == "string") {
        if (t === "")
          return new Uint8Array(0);
        try {
          return I1(t);
        } catch (r) {
          const a = r instanceof Error ? r.message : String(r);
          throw new Wt(e, a);
        }
      }
      break;
  }
  return t;
}
function Tue(e, t) {
  switch (e) {
    case I.BOOL:
      switch (t) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      return t;
    case I.INT32:
    case I.FIXED32:
    case I.UINT32:
    case I.SFIXED32:
    case I.SINT32:
      return Qx(t);
    default:
      return t;
  }
}
function Qx(e) {
  if (typeof e == "string") {
    if (e === "" || e.trim().length !== e.length)
      return e;
    const t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
function Iue(e, t) {
  try {
    return JSON.parse(e);
  } catch (n) {
    const r = n instanceof Error ? n.message : String(n);
    throw new Error(
      `cannot decode message ${t} from JSON: ${r}`,
      // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
      { cause: n }
    );
  }
}
function wue(e, t, n) {
  if (!e.desc.typeName.startsWith("google.protobuf."))
    return !1;
  switch (e.desc.typeName) {
    case "google.protobuf.Any":
      return _ue(e.message, t, n), !0;
    case "google.protobuf.Timestamp":
      return Oue(e.message, t), !0;
    case "google.protobuf.Duration":
      return Sue(e.message, t), !0;
    case "google.protobuf.FieldMask":
      return Due(e.message, t), !0;
    case "google.protobuf.Struct":
      return e8(e.message, t), !0;
    case "google.protobuf.Value":
      return L1(e.message, t), !0;
    case "google.protobuf.ListValue":
      return t8(e.message, t), !0;
    default:
      if (vf(e.desc)) {
        const r = e.desc.fields[0];
        return t === null ? e.clear(r) : e.set(r, qb(r, t, !0)), !0;
      }
      return !1;
  }
}
function _ue(e, t, n) {
  var r;
  if (t === null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: expected object but got ${je(t)}`);
  if (Object.keys(t).length == 0)
    return;
  const a = t["@type"];
  if (typeof a != "string" || a == "")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is empty`);
  const o = a.includes("/") ? a.substring(a.lastIndexOf("/") + 1) : a;
  if (!o.length)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is invalid`);
  const s = (r = n.registry) === null || r === void 0 ? void 0 : r.getMessage(o);
  if (!s)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${a} is not in the type registry`);
  const i = qn(s);
  if (o.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(t, "value")) {
    const u = t.value;
    su(i, u, n);
  } else {
    const u = Object.assign({}, t);
    delete u["@type"], su(i, u, n);
  }
  Wie(i.desc, i.message, e);
}
function Oue(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${je(t)}`);
  const n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
  if (!n)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  const r = Date.parse(
    // biome-ignore format: want this to read well
    n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z")
  );
  if (Number.isNaN(r))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  e.seconds = q.parse(r / 1e3), e.nanos = 0, n[7] && (e.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9);
}
function Sue(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${je(t)}`);
  const n = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
  if (n === null)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${je(t)}`);
  const r = Number(n[1]);
  if (r > 315576e6 || r < -315576e6)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${je(t)}`);
  if (e.seconds = q.parse(r), typeof n[2] != "string")
    return;
  const a = n[2] + "0".repeat(9 - n[2].length);
  e.nanos = parseInt(a), (r < 0 || Object.is(r, -0)) && (e.nanos = -e.nanos);
}
function Due(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${je(t)}`);
  if (t === "")
    return;
  function n(r) {
    if (r.includes("_"))
      throw new Error(`cannot decode message ${e.$typeName} from JSON: path names must be lowerCamelCase`);
    const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase());
    return a[0] === "_" ? a.substring(1) : a;
  }
  e.paths = t.split(",").map(n);
}
function e8(e, t) {
  if (typeof t != "object" || t == null || Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${je(t)}`);
  for (const [n, r] of Object.entries(t)) {
    const a = wr(Wx);
    L1(a, r), e.fields[n] = a;
  }
}
function L1(e, t) {
  switch (typeof t) {
    case "number":
      e.kind = { case: "numberValue", value: t };
      break;
    case "string":
      e.kind = { case: "stringValue", value: t };
      break;
    case "boolean":
      e.kind = { case: "boolValue", value: t };
      break;
    case "object":
      if (t === null)
        e.kind = { case: "nullValue", value: wN.NULL_VALUE };
      else if (Array.isArray(t)) {
        const n = wr(qie);
        t8(n, t), e.kind = { case: "listValue", value: n };
      } else {
        const n = wr(zie);
        e8(n, t), e.kind = { case: "structValue", value: n };
      }
      break;
    default:
      throw new Error(`cannot decode message ${e.$typeName} from JSON ${je(t)}`);
  }
  return e;
}
function t8(e, t) {
  if (!Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${je(t)}`);
  for (const n of t) {
    const r = wr(Wx);
    L1(r, n), e.values.push(r);
  }
}
function _N(e) {
  const t = G[e];
  return typeof t != "string" ? e.toString() : t[0].toLowerCase() + t.substring(1).replace(/[A-Z]/g, (n) => "_" + n.toLowerCase());
}
let Om;
function kue(e) {
  if (!Om) {
    Om = {};
    for (const t of Object.values(G))
      typeof t != "string" && (Om[_N(t)] = t);
  }
  return Om[e];
}
class Ae extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(t, n = G.Unknown, r, a, o) {
    super(Aue(t, n)), this.name = "ConnectError", Object.setPrototypeOf(this, new.target.prototype), this.rawMessage = t, this.code = n, this.metadata = new Headers(r ?? {}), this.details = a ?? [], this.cause = o;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(t, n = G.Unknown) {
    return t instanceof Ae ? t : t instanceof Error ? t.name == "AbortError" || t.name == "TimeoutError" ? new Ae(t.message, G.Canceled) : new Ae(t.message, n, void 0, void 0, t) : new Ae(String(t), n, void 0, void 0, t);
  }
  static [Symbol.hasInstance](t) {
    return t instanceof Error ? Object.getPrototypeOf(t) === Ae.prototype ? !0 : t.name === "ConnectError" && "code" in t && typeof t.code == "number" && "metadata" in t && "details" in t && Array.isArray(t.details) && "rawMessage" in t && typeof t.rawMessage == "string" && "cause" in t : !1;
  }
  findDetails(t) {
    const n = t.kind === "message" ? {
      getMessage: (a) => a === t.typeName ? t : void 0
    } : t, r = [];
    for (const a of this.details) {
      if ("desc" in a) {
        n.getMessage(a.desc.typeName) && r.push(wr(a.desc, a.value));
        continue;
      }
      const o = n.getMessage(a.type);
      if (o)
        try {
          r.push(Wb(o, a.value));
        } catch {
        }
    }
    return r;
  }
}
function Aue(e, t) {
  return e.length ? `[${_N(t)}] ${e}` : `[${_N(t)}]`;
}
function Lue(...e) {
  const t = new Headers();
  for (const n of e)
    n.forEach((r, a) => {
      t.append(a, r);
    });
  return t;
}
const VD = 1;
function Fue(e, t, n = !1) {
  if (t > e) {
    let r = `message size is larger than configured readMaxBytes ${e}`;
    throw n && (r = `message size ${t} is larger than configured readMaxBytes ${e}`), new Ae(r, G.ResourceExhausted);
  }
}
function Uue(e) {
  return new Rue(e);
}
class Rue {
  constructor(t) {
    this.readMaxBytes = t, this.header = new Uint8Array(5), this.headerView = new DataView(this.header.buffer), this.buf = [];
  }
  get byteLength() {
    return this.buf.reduce((t, n) => t + n.byteLength, 0);
  }
  decode(t) {
    this.buf.push(t);
    const n = [];
    for (; ; ) {
      let r = this.pop();
      if (!r)
        break;
      n.push(r);
    }
    return n;
  }
  // consume an enveloped message
  pop() {
    if (!(!this.env && (this.env = this.head(), !this.env)) && this.cons(this.env.data)) {
      const t = this.env;
      return this.env = void 0, t;
    }
  }
  // consume header
  head() {
    if (!this.cons(this.header))
      return;
    const t = this.headerView.getUint8(0), n = this.headerView.getUint32(1);
    return Fue(this.readMaxBytes, n, !0), {
      flags: t,
      data: new Uint8Array(n)
    };
  }
  // consume from buffer, fill target
  cons(t) {
    const n = t.byteLength;
    if (this.byteLength < n)
      return !1;
    let r = 0;
    for (; r < n; ) {
      const a = this.buf.shift();
      a.byteLength > n - r ? (t.set(a.subarray(0, n - r), r), this.buf.unshift(a.subarray(n - r)), r += n - r) : (t.set(a, r), r += a.byteLength);
    }
    return !0;
  }
}
function $ue(e) {
  let t;
  const n = Uue(4294967295);
  return new ReadableStream({
    start() {
      t = e.getReader();
    },
    async pull(r) {
      let a = !1;
      for (; !a; ) {
        const o = await t.read();
        if (o.done)
          n.byteLength > 0 && r.error(new Ae("protocol error: incomplete envelope", G.InvalidArgument)), r.close();
        else
          for (const s of n.decode(o.value))
            r.enqueue(s), a = !0;
      }
    }
  });
}
function Pue(e, t) {
  const n = new Uint8Array(t.length + 5);
  n.set(t, 5);
  const r = new DataView(n.buffer, n.byteOffset, n.byteLength);
  return r.setUint8(0, e), r.setUint32(1, t.length), n;
}
function Vue(...e) {
  const t = new AbortController(), n = e.filter((a) => a !== void 0).concat(t.signal);
  for (const a of n) {
    if (a.aborted) {
      r.apply(a);
      break;
    }
    a.addEventListener("abort", r);
  }
  function r() {
    t.signal.aborted || t.abort(n8(this));
    for (const a of n)
      a.removeEventListener("abort", r);
  }
  return t;
}
function xue(e) {
  const t = new AbortController(), n = () => {
    t.abort(new Ae("the operation timed out", G.DeadlineExceeded));
  };
  let r;
  return e !== void 0 && (e <= 0 ? n() : r = setTimeout(n, e)), {
    signal: t.signal,
    cleanup: () => clearTimeout(r)
  };
}
function n8(e) {
  if (!e.aborted)
    return;
  if (e.reason !== void 0)
    return e.reason;
  const t = new Error("This operation was aborted");
  return t.name = "AbortError", t;
}
function xD() {
  return {
    get(e) {
      return e.id in this ? this[e.id] : e.defaultValue;
    },
    set(e, t) {
      return this[e.id] = t, this;
    },
    delete(e) {
      return delete this[e.id], this;
    }
  };
}
function YD(e, t) {
  return e.toString().replace(/\/?$/, `/${t.parent.typeName}/${t.name}`);
}
function r8(e, t) {
  return wr(e, t);
}
function Yue(e, t) {
  function n(r) {
    return r.done === !0 ? r : {
      done: r.done,
      value: r8(e, r.value)
    };
  }
  return {
    [Symbol.asyncIterator]() {
      const r = t[Symbol.asyncIterator](), a = {
        next: () => r.next().then(n)
      };
      return r.throw !== void 0 && (a.throw = (o) => r.throw(o).then(n)), r.return !== void 0 && (a.return = (o) => r.return(o).then(n)), a;
    }
  };
}
function a8(e, t) {
  if (!t)
    return e;
  for (const n of t.concat().reverse())
    e = n(e);
  return e;
}
function o8(e) {
  var t;
  const n = Object.assign({}, e);
  return (t = n.ignoreUnknownFields) !== null && t !== void 0 || (n.ignoreUnknownFields = !0), n;
}
function jD(e, t, n, r) {
  const a = t ? BD(e.input, r) : GD(e.input, n);
  return { parse: (t ? BD(e.output, r) : GD(e.output, n)).parse, serialize: a.serialize };
}
function BD(e, t) {
  return {
    parse(n) {
      try {
        return Wb(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Ae(`parse binary: ${a}`, G.Internal);
      }
    },
    serialize(n) {
      try {
        return Gx(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Ae(`serialize binary: ${a}`, G.Internal);
      }
    }
  };
}
function GD(e, t) {
  var n, r;
  const a = (n = t?.textEncoder) !== null && n !== void 0 ? n : new TextEncoder(), o = (r = t?.textDecoder) !== null && r !== void 0 ? r : new TextDecoder(), s = o8(t);
  return {
    parse(i) {
      try {
        const u = o.decode(i);
        return gue(e, u, s);
      } catch (u) {
        throw Ae.from(u, G.InvalidArgument);
      }
    },
    serialize(i) {
      try {
        const u = sue(e, i, s);
        return a.encode(u);
      } catch (u) {
        throw Ae.from(u, G.Internal);
      }
    }
  };
}
const jue = /^application\/(connect\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i, Bue = "application/proto", Gue = "application/json", Mue = "application/connect+proto", Cue = "application/connect+json";
function Kue(e) {
  const t = e?.match(jue);
  if (!t)
    return;
  const n = !!t[1], r = !!t[3];
  return { stream: n, binary: r };
}
function s8(e, t, n) {
  var r;
  if (t && new Headers(t).forEach((i, u) => n.metadata.append(u, i)), typeof e != "object" || e == null || Array.isArray(e))
    throw n;
  let a = n.code;
  "code" in e && typeof e.code == "string" && (a = (r = kue(e.code)) !== null && r !== void 0 ? r : a);
  const o = e.message;
  if (o != null && typeof o != "string")
    throw n;
  const s = new Ae(o ?? "", a, t);
  if ("details" in e && Array.isArray(e.details))
    for (const i of e.details) {
      if (i === null || typeof i != "object" || Array.isArray(i) || typeof i.type != "string" || typeof i.value != "string")
        throw n;
      try {
        s.details.push({
          type: i.type,
          value: I1(i.value),
          debug: i.debug
        });
      } catch {
        throw n;
      }
    }
  return s;
}
const MD = 2;
function Xue(e) {
  const t = new Ae("invalid end stream", G.Unknown);
  let n;
  try {
    n = JSON.parse(typeof e == "string" ? e : new TextDecoder().decode(e));
  } catch {
    throw t;
  }
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw t;
  const r = new Headers();
  if ("metadata" in n) {
    if (typeof n.metadata != "object" || n.metadata == null || Array.isArray(n.metadata))
      throw t;
    for (const [o, s] of Object.entries(n.metadata)) {
      if (!Array.isArray(s) || s.some((i) => typeof i != "string"))
        throw t;
      for (const i of s)
        r.append(o, i);
    }
  }
  const a = "error" in n && n.error != null ? s8(n.error, r, t) : void 0;
  return { metadata: r, error: a };
}
const Ip = "Content-Type", Wue = "Content-Length", CD = "Content-Encoding", Jue = "Accept-Encoding", Zue = "Connect-Timeout-Ms", i8 = "Connect-Protocol-Version", Hue = "User-Agent";
function zue(e) {
  switch (e) {
    case 400:
      return G.Internal;
    case 401:
      return G.Unauthenticated;
    case 403:
      return G.PermissionDenied;
    case 404:
      return G.Unimplemented;
    case 429:
      return G.Unavailable;
    case 502:
      return G.Unavailable;
    case 503:
      return G.Unavailable;
    case 504:
      return G.Unavailable;
    default:
      return G.Unknown;
  }
}
function KD(e) {
  const t = new Headers(), n = new Headers();
  return e.forEach((r, a) => {
    a.toLowerCase().startsWith("trailer-") ? n.append(a.substring(8), r) : t.append(a, r);
  }), [t, n];
}
const u8 = "1";
function XD(e, t, n, r, a) {
  const o = new Headers(r ?? {});
  return n !== void 0 && o.set(Zue, `${n}`), o.set(Ip, e == "unary" ? t ? Bue : Gue : t ? Mue : Cue), o.set(i8, u8), o.has(Hue), o;
}
function WD(e, t, n, r) {
  const a = r.get(Ip), o = Kue(a);
  if (n !== 200) {
    const i = new Ae(`HTTP ${n}`, zue(n), r);
    if (e == "unary" && o && !o.binary)
      return { isUnaryError: !0, unaryError: i };
    throw i;
  }
  const s = {
    binary: t,
    stream: e !== "unary"
  };
  if (o?.binary !== s.binary || o.stream !== s.stream)
    throw new Ae(`unsupported content type ${a}`, o === void 0 ? G.Unknown : G.Internal, r);
  return { isUnaryError: !1 };
}
const JD = "application/";
function que(e, t) {
  return t ? Lx(e, "url") : encodeURIComponent(new TextDecoder().decode(e));
}
function Que(e, t, n) {
  let r = `?connect=v${u8}`;
  const a = e.header.get(Ip);
  a?.indexOf(JD) === 0 && (r += "&encoding=" + encodeURIComponent(a.slice(JD.length)));
  const o = e.header.get(CD);
  o !== null && o !== "identity" && (r += "&compression=" + encodeURIComponent(o), n = !0), n && (r += "&base64=1"), r += "&message=" + que(t, n);
  const s = e.url + r, i = new Headers(e.header);
  for (const u of [
    i8,
    Ip,
    Wue,
    CD,
    Jue
  ])
    i.delete(u);
  return Object.assign(Object.assign({}, e), {
    requestMethod: "GET",
    url: s,
    header: i
  });
}
function ele(e) {
  const t = a8(e.next, e.interceptors), [n, r, a] = l8(e), o = Object.assign(Object.assign({}, e.req), { message: r8(e.req.method.input, e.req.message), signal: n });
  return t(o).then((s) => (a(), s), r);
}
function tle(e) {
  const t = a8(e.next, e.interceptors), [n, r, a] = l8(e), o = Object.assign(Object.assign({}, e.req), { message: Yue(e.req.method.input, e.req.message), signal: n });
  let s = !1;
  return n.addEventListener("abort", function() {
    var i, u;
    const l = e.req.message[Symbol.asyncIterator]();
    s || (i = l.throw) === null || i === void 0 || i.call(l, this.reason).catch(() => {
    }), (u = l.return) === null || u === void 0 || u.call(l).catch(() => {
    });
  }), t(o).then((i) => Object.assign(Object.assign({}, i), { message: {
    [Symbol.asyncIterator]() {
      const u = i.message[Symbol.asyncIterator]();
      return {
        next() {
          return u.next().then((l) => (l.done == !0 && (s = !0, a()), l), r);
        }
        // We deliberately omit throw/return.
      };
    }
  } }), r);
}
function l8(e) {
  const { signal: t, cleanup: n } = xue(e.timeoutMs), r = Vue(e.signal, t);
  return [
    r.signal,
    function(a) {
      const o = Ae.from(t.aborted ? n8(t) : a);
      return r.abort(o), n(), Promise.reject(o);
    },
    function() {
      n(), r.abort();
    }
  ];
}
function nle() {
  try {
    new Headers();
  } catch {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}
var tc = function(e) {
  return this instanceof tc ? (this.v = e, this) : new tc(e);
}, rle = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof tc ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
const ZD = {
  redirect: "error"
};
function ale(e) {
  var t;
  nle();
  const n = (t = e.useBinaryFormat) !== null && t !== void 0 ? t : !1;
  return {
    async unary(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = jD(r, n, e.jsonOptions, e.binaryOptions);
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await ele({
        interceptors: e.interceptors,
        signal: a,
        timeoutMs: o,
        req: {
          stream: !1,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: YD(e.baseUrl, r),
          header: XD(r.methodKind, n, o, s),
          contextValues: u ?? xD(),
          message: i
        },
        next: async (f) => {
          var d;
          const m = e.useHttpGet === !0 && r.idempotency === IN.NO_SIDE_EFFECTS;
          let p = null;
          m ? f = Que(f, l(f.message), n) : p = l(f.message);
          const b = await ((d = e.fetch) !== null && d !== void 0 ? d : globalThis.fetch)(f.url, Object.assign(Object.assign({}, ZD), { method: f.requestMethod, headers: f.header, signal: f.signal, body: p })), { isUnaryError: g, unaryError: S } = WD(r.methodKind, n, b.status, b.headers);
          if (g)
            throw s8(await b.json(), Lue(...KD(b.headers)), S);
          const [D, k] = KD(b.headers);
          return {
            stream: !1,
            service: r.parent,
            method: r,
            header: D,
            message: n ? c(new Uint8Array(await b.arrayBuffer())) : zx(r.output, await b.json(), o8(e.jsonOptions)),
            trailer: k
          };
        }
      });
    },
    async stream(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = jD(r, n, e.jsonOptions, e.binaryOptions);
      function f(m, p, b, g) {
        return rle(this, arguments, function* () {
          const S = $ue(m).getReader();
          let D = !1;
          for (; ; ) {
            const k = yield tc(S.read());
            if (k.done)
              break;
            const { flags: U, data: R } = k.value;
            if ((U & VD) === VD)
              throw new Ae("protocol error: received unsupported compressed output", G.Internal);
            if ((U & MD) === MD) {
              D = !0;
              const F = Xue(R);
              if (F.error) {
                const A = F.error;
                throw b.forEach((L, re) => {
                  A.metadata.append(re, L);
                }), A;
              }
              F.metadata.forEach((A, L) => p.set(L, A));
              continue;
            }
            yield yield tc(c(R));
          }
          if ("throwIfAborted" in g && g.throwIfAborted(), !D)
            throw "missing EndStreamResponse";
        });
      }
      async function d(m) {
        if (r.methodKind != "server_streaming")
          throw "The fetch API does not support streaming request bodies";
        const p = await m[Symbol.asyncIterator]().next();
        if (p.done == !0)
          throw "missing request message";
        return Pue(0, l(p.value));
      }
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await tle({
        interceptors: e.interceptors,
        timeoutMs: o,
        signal: a,
        req: {
          stream: !0,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: YD(e.baseUrl, r),
          header: XD(r.methodKind, n, o, s),
          contextValues: u ?? xD(),
          message: i
        },
        next: async (m) => {
          var p;
          const b = await ((p = e.fetch) !== null && p !== void 0 ? p : globalThis.fetch)(m.url, Object.assign(Object.assign({}, ZD), { method: m.requestMethod, headers: m.header, signal: m.signal, body: await d(m.message) }));
          if (WD(r.methodKind, n, b.status, b.headers), b.body === null)
            throw "missing response body";
          const g = new Headers();
          return Object.assign(Object.assign({}, m), { header: b.headers, trailer: g, message: f(b.body, g, b.headers, m.signal) });
        }
      });
    }
  };
}
ale({
  baseUrl: "/api",
  useBinaryFormat: !0,
  fetch: (e, t) => {
    const n = t?.headers ?? {};
    return fetch(e, {
      ...t,
      headers: {
        ...n,
        "qt-widget-id": window.qtWidgetId
      }
    });
  }
});
const yt = /* @__PURE__ */ Symbol(), ole = !1;
var sle = Array.isArray, ile = Array.prototype.indexOf, Dh = Object.getOwnPropertyDescriptor, ule = Object.prototype, lle = Array.prototype, cle = Object.getPrototypeOf;
function fle(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function mle() {
  var e, t, n = new Promise((r, a) => {
    e = r, t = a;
  });
  return { promise: n, resolve: e, reject: t };
}
const fn = 2, dle = 4, ple = 1 << 24, Ou = 16, wf = 32, _f = 64, F1 = 128, Qr = 512, St = 1024, _r = 2048, ea = 4096, ld = 8192, vs = 16384, ble = 32768, HD = 1 << 17, c8 = 1 << 18, Xs = 32768, ON = 1 << 21, f8 = 1 << 22, nc = 1 << 23, kh = /* @__PURE__ */ Symbol("$state"), m8 = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function gle() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function hle() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function yle() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Nle() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function Ele(e) {
  return e === this.v;
}
let vle = !1;
function d8() {
  return !0;
}
let Ii = [];
function Tle() {
  var e = Ii;
  Ii = [], fle(e);
}
function Ile(e) {
  if (Ii.length === 0) {
    var t = Ii;
    queueMicrotask(() => {
      t === Ii && Tle();
    });
  }
  Ii.push(e);
}
function wle(e) {
  var t = Jt;
  if (t === null)
    return ve.f |= nc, e;
  if ((t.f & ble) === 0) {
    if ((t.f & F1) === 0)
      throw e;
    t.b.error(e);
  } else
    p8(e, t);
}
function p8(e, t) {
  for (; t !== null; ) {
    if ((t.f & F1) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e;
}
const Sm = /* @__PURE__ */ new Set();
let ze = null, Gn = null, xr = [], U1 = null, SN = !1;
class rc {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #e = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #i = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    xr = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const r of t)
      this.#u(r, n);
    this.is_fork || this.#c(), this.is_deferred() ? (this.#n(n.effects), this.#n(n.render_effects)) : (ze = null, zD(n.render_effects), zD(n.effects), this.#i?.resolve()), Gn = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #u(t, n) {
    t.f ^= St;
    for (var r = t.first; r !== null; ) {
      var a = r.f, o = (a & (wf | _f)) !== 0, s = o && (a & St) !== 0, i = s || (a & ld) !== 0 || this.skipped_effects.has(r);
      if ((r.f & F1) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: []
      }), !i && r.fn !== null) {
        o ? r.f ^= St : (a & dle) !== 0 ? n.effects.push(r) : Sf(r) && ((r.f & Ou) !== 0 && this.#o.add(r), Dp(r));
        var u = r.first;
        if (u !== null) {
          r = u;
          continue;
        }
      }
      var l = r.parent;
      for (r = r.next; r === null && l !== null; )
        l === n.effect && (this.#n(n.effects), this.#n(n.render_effects), n = /** @type {EffectTarget} */
        n.parent), r = l.next, l = l.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #n(t) {
    for (const n of t)
      (n.f & _r) !== 0 ? this.#o.add(n) : (n.f & ea) !== 0 && this.#s.add(n), this.#l(n.deps), Zt(n, St);
  }
  /**
   * @param {Value[] | null} deps
   */
  #l(t) {
    if (t !== null)
      for (const n of t)
        (n.f & fn) === 0 || (n.f & Xs) === 0 || (n.f ^= Xs, this.#l(
          /** @type {Derived} */
          n.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.previous.has(t) || this.previous.set(t, n), (t.f & nc) === 0 && (this.current.set(t, t.v), Gn?.set(t, t.v));
  }
  activate() {
    ze = this, this.apply();
  }
  deactivate() {
    ze === this && (ze = null, Gn = null);
  }
  flush() {
    if (this.activate(), xr.length > 0) {
      if (_le(), ze !== null && ze !== this)
        return;
    } else this.#e === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const t of this.#a) t(this);
    this.#a.clear();
  }
  #c() {
    if (this.#t === 0) {
      for (const t of this.#r) t();
      this.#r.clear();
    }
    this.#e === 0 && this.#f();
  }
  #f() {
    if (Sm.size > 1) {
      this.previous.clear();
      var t = Gn, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const o of Sm) {
        if (o === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [u, l] of this.current) {
          if (o.current.has(u))
            if (n && l !== o.current.get(u))
              o.current.set(u, l);
            else
              continue;
          s.push(u);
        }
        if (s.length === 0)
          continue;
        const i = [...o.current.keys()].filter((u) => !this.current.has(u));
        if (i.length > 0) {
          var a = xr;
          xr = [];
          const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            b8(c, i, u, l);
          if (xr.length > 0) {
            ze = o, o.apply();
            for (const c of xr)
              o.#u(c, r);
            o.deactivate();
          }
          xr = a;
        }
      }
      ze = null, Gn = t;
    }
    this.committed = !0, Sm.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(t) {
    this.#e += 1, t && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(t) {
    this.#e -= 1, t && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const t of this.#o)
      this.#s.delete(t), Zt(t, _r), ac(t);
    for (const t of this.#s)
      Zt(t, ea), ac(t);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(t) {
    this.#r.add(t);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(t) {
    this.#a.add(t);
  }
  settled() {
    return (this.#i ??= mle()).promise;
  }
  static ensure() {
    if (ze === null) {
      const t = ze = new rc();
      Sm.add(ze), rc.enqueue(() => {
        ze === t && t.flush();
      });
    }
    return ze;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    Ile(t);
  }
  apply() {
  }
}
function _le() {
  var e = Ts;
  SN = !0;
  try {
    var t = 0;
    for (_p(!0); xr.length > 0; ) {
      var n = rc.ensure();
      if (t++ > 1e3) {
        var r, a;
        Ole();
      }
      n.process(xr), mo.clear();
    }
  } finally {
    SN = !1, _p(e), U1 = null;
  }
}
function Ole() {
  try {
    gle();
  } catch (e) {
    p8(e, U1);
  }
}
let Ea = null;
function zD(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (vs | ld)) === 0 && Sf(r) && (Ea = /* @__PURE__ */ new Set(), Dp(r), r.deps === null && r.first === null && r.nodes === null && (r.teardown === null && r.ac === null ? w8(r) : r.fn = null), Ea?.size > 0)) {
        mo.clear();
        for (const a of Ea) {
          if ((a.f & (vs | ld)) !== 0) continue;
          const o = [a];
          let s = a.parent;
          for (; s !== null; )
            Ea.has(s) && (Ea.delete(s), o.push(s)), s = s.parent;
          for (let i = o.length - 1; i >= 0; i--) {
            const u = o[i];
            (u.f & (vs | ld)) === 0 && Dp(u);
          }
        }
        Ea.clear();
      }
    }
    Ea = null;
  }
}
function b8(e, t, n, r) {
  if (!n.has(e) && (n.add(e), e.reactions !== null))
    for (const a of e.reactions) {
      const o = a.f;
      (o & fn) !== 0 ? b8(
        /** @type {Derived} */
        a,
        t,
        n,
        r
      ) : (o & (f8 | Ou)) !== 0 && (o & _r) === 0 && g8(a, t, r) && (Zt(a, _r), ac(
        /** @type {Effect} */
        a
      ));
    }
}
function g8(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (e.deps !== null)
    for (const a of e.deps) {
      if (t.includes(a))
        return !0;
      if ((a.f & fn) !== 0 && g8(
        /** @type {Derived} */
        a,
        t,
        n
      ))
        return n.set(
          /** @type {Derived} */
          a,
          !0
        ), !0;
    }
  return n.set(e, !1), !1;
}
function ac(e) {
  for (var t = U1 = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (SN && t === Jt && (n & Ou) !== 0 && (n & c8) === 0)
      return;
    if ((n & (_f | wf)) !== 0) {
      if ((n & St) === 0) return;
      t.f ^= St;
    }
  }
  xr.push(t);
}
function h8(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      $1(
        /** @type {Effect} */
        t[n]
      );
  }
}
function Sle(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & fn) === 0)
      return (t.f & vs) === 0 ? (
        /** @type {Effect} */
        t
      ) : null;
    t = t.parent;
  }
  return null;
}
function R1(e) {
  var t, n = Jt;
  Op(Sle(e));
  try {
    e.f &= ~Xs, h8(e), t = D8(e);
  } finally {
    Op(n);
  }
  return t;
}
function y8(e) {
  var t = R1(e);
  if (e.equals(t) || (ze?.is_fork || (e.v = t), e.wv = O8()), !Of)
    if (Gn !== null)
      (wp() || ze?.is_fork) && Gn.set(e, t);
    else {
      var n = (e.f & Qr) === 0 ? ea : St;
      Zt(e, n);
    }
}
let DN = /* @__PURE__ */ new Set();
const mo = /* @__PURE__ */ new Map();
let N8 = !1;
function Dle(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: Ele,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function eo(e, t) {
  const n = Dle(e);
  return $le(n), n;
}
function Bo(e, t, n = !1) {
  ve !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!es || (ve.f & HD) !== 0) && d8() && (ve.f & (fn | Ou | f8 | HD)) !== 0 && !Ma?.includes(e) && Nle();
  let r = n ? wi(t) : t;
  return kle(e, r);
}
function kle(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    Of ? mo.set(e, t) : mo.set(e, n), e.v = t;
    var r = rc.ensure();
    r.capture(e, n), (e.f & fn) !== 0 && ((e.f & _r) !== 0 && R1(
      /** @type {Derived} */
      e
    ), Zt(e, (e.f & Qr) !== 0 ? St : ea)), e.wv = O8(), E8(e, _r), Jt !== null && (Jt.f & St) !== 0 && (Jt.f & (wf | _f)) === 0 && (Fn === null ? Ple([e]) : Fn.push(e)), !r.is_fork && DN.size > 0 && !N8 && Ale();
  }
  return t;
}
function Ale() {
  N8 = !1;
  var e = Ts;
  _p(!0);
  const t = Array.from(DN);
  try {
    for (const n of t)
      (n.f & St) !== 0 && Zt(n, ea), Sf(n) && Dp(n);
  } finally {
    _p(e);
  }
  DN.clear();
}
function Ah(e) {
  Bo(e, e.v + 1);
}
function E8(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, a = 0; a < r; a++) {
      var o = n[a], s = o.f, i = (s & _r) === 0;
      if (i && Zt(o, t), (s & fn) !== 0) {
        var u = (
          /** @type {Derived} */
          o
        );
        Gn?.delete(u), (s & Xs) === 0 && (s & Qr && (o.f |= Xs), E8(u, ea));
      } else i && ((s & Ou) !== 0 && Ea !== null && Ea.add(
        /** @type {Effect} */
        o
      ), ac(
        /** @type {Effect} */
        o
      ));
    }
}
function wi(e) {
  if (typeof e != "object" || e === null || kh in e)
    return e;
  const t = cle(e);
  if (t !== ule && t !== lle)
    return e;
  var n = /* @__PURE__ */ new Map(), r = sle(e), a = /* @__PURE__ */ eo(0), o = Is, s = (i) => {
    if (Is === o)
      return i();
    var u = ve, l = Is;
    iu(null), QD(o);
    var c = i();
    return iu(u), QD(l), c;
  };
  return r && n.set("length", /* @__PURE__ */ eo(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(i, u, l) {
        (!("value" in l) || l.configurable === !1 || l.enumerable === !1 || l.writable === !1) && hle();
        var c = n.get(u);
        return c === void 0 ? c = s(() => {
          var f = /* @__PURE__ */ eo(l.value);
          return n.set(u, f), f;
        }) : Bo(c, l.value, !0), !0;
      },
      deleteProperty(i, u) {
        var l = n.get(u);
        if (l === void 0) {
          if (u in i) {
            const c = s(() => /* @__PURE__ */ eo(yt));
            n.set(u, c), Ah(a);
          }
        } else
          Bo(l, yt), Ah(a);
        return !0;
      },
      get(i, u, l) {
        if (u === kh)
          return e;
        var c = n.get(u), f = u in i;
        if (c === void 0 && (!f || Dh(i, u)?.writable) && (c = s(() => {
          var m = wi(f ? i[u] : yt), p = /* @__PURE__ */ eo(m);
          return p;
        }), n.set(u, c)), c !== void 0) {
          var d = Dm(c);
          return d === yt ? void 0 : d;
        }
        return Reflect.get(i, u, l);
      },
      getOwnPropertyDescriptor(i, u) {
        var l = Reflect.getOwnPropertyDescriptor(i, u);
        if (l && "value" in l) {
          var c = n.get(u);
          c && (l.value = Dm(c));
        } else if (l === void 0) {
          var f = n.get(u), d = f?.v;
          if (f !== void 0 && d !== yt)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return l;
      },
      has(i, u) {
        if (u === kh)
          return !0;
        var l = n.get(u), c = l !== void 0 && l.v !== yt || Reflect.has(i, u);
        if (l !== void 0 || Jt !== null && (!c || Dh(i, u)?.writable)) {
          l === void 0 && (l = s(() => {
            var d = c ? wi(i[u]) : yt, m = /* @__PURE__ */ eo(d);
            return m;
          }), n.set(u, l));
          var f = Dm(l);
          if (f === yt)
            return !1;
        }
        return c;
      },
      set(i, u, l, c) {
        var f = n.get(u), d = u in i;
        if (r && u === "length")
          for (var m = l; m < /** @type {Source<number>} */
          f.v; m += 1) {
            var p = n.get(m + "");
            p !== void 0 ? Bo(p, yt) : m in i && (p = s(() => /* @__PURE__ */ eo(yt)), n.set(m + "", p));
          }
        if (f === void 0)
          (!d || Dh(i, u)?.writable) && (f = s(() => /* @__PURE__ */ eo(void 0)), Bo(f, wi(l)), n.set(u, f));
        else {
          d = f.v !== yt;
          var b = s(() => wi(l));
          Bo(f, b);
        }
        var g = Reflect.getOwnPropertyDescriptor(i, u);
        if (g?.set && g.set.call(c, l), !d) {
          if (r && typeof u == "string") {
            var S = (
              /** @type {Source<number>} */
              n.get("length")
            ), D = Number(u);
            Number.isInteger(D) && D >= S.v && Bo(S, D + 1);
          }
          Ah(a);
        }
        return !0;
      },
      ownKeys(i) {
        Dm(a);
        var u = Reflect.ownKeys(i).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== yt;
        });
        for (var [l, c] of n)
          c.v !== yt && !(l in i) && u.push(l);
        return u;
      },
      setPrototypeOf() {
        yle();
      }
    }
  );
}
var Lle;
// @__NO_SIDE_EFFECTS__
function Fle(e) {
  return (
    /** @type {TemplateNode | null} */
    Lle.call(e)
  );
}
function v8(e) {
  var t = ve, n = Jt;
  iu(null), Op(null);
  try {
    return e();
  } finally {
    iu(t), Op(n);
  }
}
function wp() {
  return ve !== null && !es;
}
function T8(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = Of, r = ve;
    qD(!0), iu(null);
    try {
      t.call(null);
    } finally {
      qD(n), iu(r);
    }
  }
}
function I8(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const a = n.ac;
    a !== null && v8(() => {
      a.abort(m8);
    });
    var r = n.next;
    (n.f & _f) !== 0 ? n.parent = null : $1(n, t), n = r;
  }
}
function Ule(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & wf) === 0 && $1(t), t = n;
  }
}
function $1(e, t = !0) {
  var n = !1;
  (t || (e.f & c8) !== 0) && e.nodes !== null && e.nodes.end !== null && (Rle(
    e.nodes.start,
    /** @type {TemplateNode} */
    e.nodes.end
  ), n = !0), I8(e, t && !n), Sp(e, 0), Zt(e, vs);
  var r = e.nodes && e.nodes.t;
  if (r !== null)
    for (const o of r)
      o.stop();
  T8(e);
  var a = e.parent;
  a !== null && a.first !== null && w8(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes = e.ac = null;
}
function Rle(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : /* @__PURE__ */ Fle(e);
    e.remove(), e = n;
  }
}
function w8(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
let Ts = !1;
function _p(e) {
  Ts = e;
}
let Of = !1;
function qD(e) {
  Of = e;
}
let ve = null, es = !1;
function iu(e) {
  ve = e;
}
let Jt = null;
function Op(e) {
  Jt = e;
}
let Ma = null;
function $le(e) {
  ve !== null && (Ma === null ? Ma = [e] : Ma.push(e));
}
let it = null, vn = 0, Fn = null;
function Ple(e) {
  Fn = e;
}
let _8 = 1, oc = 0, Is = oc;
function QD(e) {
  Is = e;
}
function O8() {
  return ++_8;
}
function Sf(e) {
  var t = e.f;
  if ((t & _r) !== 0)
    return !0;
  if (t & fn && (e.f &= ~Xs), (t & ea) !== 0) {
    var n = e.deps;
    if (n !== null)
      for (var r = n.length, a = 0; a < r; a++) {
        var o = n[a];
        if (Sf(
          /** @type {Derived} */
          o
        ) && y8(
          /** @type {Derived} */
          o
        ), o.wv > e.wv)
          return !0;
      }
    (t & Qr) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Gn === null && Zt(e, St);
  }
  return !1;
}
function S8(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !Ma?.includes(e))
    for (var a = 0; a < r.length; a++) {
      var o = r[a];
      (o.f & fn) !== 0 ? S8(
        /** @type {Derived} */
        o,
        t,
        !1
      ) : t === o && (n ? Zt(o, _r) : (o.f & St) !== 0 && Zt(o, ea), ac(
        /** @type {Effect} */
        o
      ));
    }
}
function D8(e) {
  var t = it, n = vn, r = Fn, a = ve, o = Ma, s = es, i = Is, u = e.f;
  it = /** @type {null | Value[]} */
  null, vn = 0, Fn = null, ve = (u & (wf | _f)) === 0 ? e : null, Ma = null, e.ctx, es = !1, Is = ++oc, e.ac !== null && (v8(() => {
    e.ac.abort(m8);
  }), e.ac = null);
  try {
    e.f |= ON;
    var l = (
      /** @type {Function} */
      e.fn
    ), c = l(), f = e.deps;
    if (it !== null) {
      var d;
      if (Sp(e, vn), f !== null && vn > 0)
        for (f.length = vn + it.length, d = 0; d < it.length; d++)
          f[vn + d] = it[d];
      else
        e.deps = f = it;
      if (wp() && (e.f & Qr) !== 0)
        for (d = vn; d < f.length; d++)
          (f[d].reactions ??= []).push(e);
    } else f !== null && vn < f.length && (Sp(e, vn), f.length = vn);
    if (d8() && Fn !== null && !es && f !== null && (e.f & (fn | ea | _r)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      Fn.length; d++)
        S8(
          Fn[d],
          /** @type {Effect} */
          e
        );
    return a !== null && a !== e && (oc++, Fn !== null && (r === null ? r = Fn : r.push(.../** @type {Source[]} */
    Fn))), (e.f & nc) !== 0 && (e.f ^= nc), c;
  } catch (m) {
    return wle(m);
  } finally {
    e.f ^= ON, it = t, vn = n, Fn = r, ve = a, Ma = o, es = s, Is = i;
  }
}
function Vle(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = ile.call(n, e);
    if (r !== -1) {
      var a = n.length - 1;
      a === 0 ? n = t.reactions = null : (n[r] = n[a], n.pop());
    }
  }
  n === null && (t.f & fn) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (it === null || !it.includes(t)) && (Zt(t, ea), (t.f & Qr) !== 0 && (t.f ^= Qr, t.f &= ~Xs), h8(
    /** @type {Derived} **/
    t
  ), Sp(
    /** @type {Derived} **/
    t,
    0
  ));
}
function Sp(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      Vle(e, n[r]);
}
function Dp(e) {
  var t = e.f;
  if ((t & vs) === 0) {
    Zt(e, St);
    var n = Jt, r = Ts;
    Jt = e, Ts = !0;
    try {
      (t & (Ou | ple)) !== 0 ? Ule(e) : I8(e), T8(e);
      var a = D8(e);
      e.teardown = typeof a == "function" ? a : null, e.wv = _8;
      var o;
      ole && vle && (e.f & _r) !== 0 && e.deps;
    } finally {
      Ts = r, Jt = n;
    }
  }
}
function Dm(e) {
  var t = e.f, n = (t & fn) !== 0;
  if (ve !== null && !es) {
    var r = Jt !== null && (Jt.f & vs) !== 0;
    if (!r && !Ma?.includes(e)) {
      var a = ve.deps;
      if ((ve.f & ON) !== 0)
        e.rv < oc && (e.rv = oc, it === null && a !== null && a[vn] === e ? vn++ : it === null ? it = [e] : it.includes(e) || it.push(e));
      else {
        (ve.deps ??= []).push(e);
        var o = e.reactions;
        o === null ? e.reactions = [ve] : o.includes(ve) || o.push(ve);
      }
    }
  }
  if (Of) {
    if (mo.has(e))
      return mo.get(e);
    if (n) {
      var s = (
        /** @type {Derived} */
        e
      ), i = s.v;
      return ((s.f & St) === 0 && s.reactions !== null || A8(s)) && (i = R1(s)), mo.set(s, i), i;
    }
  } else n && (!Gn?.has(e) || ze?.is_fork && !wp()) && (s = /** @type {Derived} */
  e, Sf(s) && y8(s), Ts && wp() && (s.f & Qr) === 0 && k8(s));
  if (Gn?.has(e))
    return Gn.get(e);
  if ((e.f & nc) !== 0)
    throw e.v;
  return e.v;
}
function k8(e) {
  if (e.deps !== null) {
    e.f ^= Qr;
    for (const t of e.deps)
      (t.reactions ??= []).push(e), (t.f & fn) !== 0 && (t.f & Qr) === 0 && k8(
        /** @type {Derived} */
        t
      );
  }
}
function A8(e) {
  if (e.v === yt) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (mo.has(t) || (t.f & fn) !== 0 && A8(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
const xle = -7169;
function Zt(e, t) {
  e.f = e.f & xle | t;
}
function L8() {
  return {
    isDark: document.documentElement.classList.contains("night-mode")
  };
}
const Yle = wi(L8()), jle = new MutationObserver((e, t) => {
  Yle.isDark = L8().isDark;
});
jle.observe(document.documentElement, { attributeFilter: ["class"] });
const Ble = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(Ble);
var M;
(function(e) {
  e[e.Canceled = 1] = "Canceled", e[e.Unknown = 2] = "Unknown", e[e.InvalidArgument = 3] = "InvalidArgument", e[e.DeadlineExceeded = 4] = "DeadlineExceeded", e[e.NotFound = 5] = "NotFound", e[e.AlreadyExists = 6] = "AlreadyExists", e[e.PermissionDenied = 7] = "PermissionDenied", e[e.ResourceExhausted = 8] = "ResourceExhausted", e[e.FailedPrecondition = 9] = "FailedPrecondition", e[e.Aborted = 10] = "Aborted", e[e.OutOfRange = 11] = "OutOfRange", e[e.Unimplemented = 12] = "Unimplemented", e[e.Internal = 13] = "Internal", e[e.Unavailable = 14] = "Unavailable", e[e.DataLoss = 15] = "DataLoss", e[e.Unauthenticated = 16] = "Unauthenticated";
})(M || (M = {}));
function P1(e, t) {
  return e !== null && typeof e == "object" && "$typeName" in e && typeof e.$typeName == "string" ? t === void 0 ? !0 : t.typeName === e.$typeName : !1;
}
var w;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(w || (w = {}));
function Gle() {
  let e = 0, t = 0;
  for (let r = 0; r < 28; r += 7) {
    let a = this.buf[this.pos++];
    if (e |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  let n = this.buf[this.pos++];
  if (e |= (n & 15) << 28, t = (n & 112) >> 4, (n & 128) == 0)
    return this.assertBounds(), [e, t];
  for (let r = 3; r <= 31; r += 7) {
    let a = this.buf[this.pos++];
    if (t |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  throw new Error("invalid varint");
}
function Lh(e, t, n) {
  for (let o = 0; o < 28; o = o + 7) {
    const s = e >>> o, i = !(!(s >>> 7) && t == 0), u = (i ? s | 128 : s) & 255;
    if (n.push(u), !i)
      return;
  }
  const r = e >>> 28 & 15 | (t & 7) << 4, a = t >> 3 != 0;
  if (n.push((a ? r | 128 : r) & 255), !!a) {
    for (let o = 3; o < 31; o = o + 7) {
      const s = t >>> o, i = !!(s >>> 7), u = (i ? s | 128 : s) & 255;
      if (n.push(u), !i)
        return;
    }
    n.push(t >>> 31 & 1);
  }
}
const cd = 4294967296;
function ek(e) {
  const t = e[0] === "-";
  t && (e = e.slice(1));
  const n = 1e6;
  let r = 0, a = 0;
  function o(s, i) {
    const u = Number(e.slice(s, i));
    a *= n, r = r * n + u, r >= cd && (a = a + (r / cd | 0), r = r % cd);
  }
  return o(-24, -18), o(-18, -12), o(-12, -6), o(-6), t ? U8(r, a) : V1(r, a);
}
function Mle(e, t) {
  let n = V1(e, t);
  const r = n.hi & 2147483648;
  r && (n = U8(n.lo, n.hi));
  const a = F8(n.lo, n.hi);
  return r ? "-" + a : a;
}
function F8(e, t) {
  if ({ lo: e, hi: t } = Cle(e, t), t <= 2097151)
    return String(cd * t + e);
  const n = e & 16777215, r = (e >>> 24 | t << 8) & 16777215, a = t >> 16 & 65535;
  let o = n + r * 6777216 + a * 6710656, s = r + a * 8147497, i = a * 2;
  const u = 1e7;
  return o >= u && (s += Math.floor(o / u), o %= u), s >= u && (i += Math.floor(s / u), s %= u), i.toString() + tk(s) + tk(o);
}
function Cle(e, t) {
  return { lo: e >>> 0, hi: t >>> 0 };
}
function V1(e, t) {
  return { lo: e | 0, hi: t | 0 };
}
function U8(e, t) {
  return t = ~t, e ? e = ~e + 1 : t += 1, V1(e, t);
}
const tk = (e) => {
  const t = String(e);
  return "0000000".slice(t.length) + t;
};
function kN(e, t) {
  if (e >= 0) {
    for (; e > 127; )
      t.push(e & 127 | 128), e = e >>> 7;
    t.push(e);
  } else {
    for (let n = 0; n < 9; n++)
      t.push(e & 127 | 128), e = e >> 7;
    t.push(1);
  }
}
function Kle() {
  let e = this.buf[this.pos++], t = e & 127;
  if ((e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 7, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 14, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 21, (e & 128) == 0)
    return this.assertBounds(), t;
  e = this.buf[this.pos++], t |= (e & 15) << 28;
  for (let n = 5; (e & 128) !== 0 && n < 10; n++)
    e = this.buf[this.pos++];
  if ((e & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
const Q = /* @__PURE__ */ Xle();
function Xle() {
  const e = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof e.getBigInt64 == "function" && typeof e.getBigUint64 == "function" && typeof e.setBigInt64 == "function" && typeof e.setBigUint64 == "function" && (globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const t = BigInt("-9223372036854775808"), n = BigInt("9223372036854775807"), r = BigInt("0"), a = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > n || s < t)
          throw new Error(`invalid int64: ${o}`);
        return s;
      },
      uParse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > a || s < r)
          throw new Error(`invalid uint64: ${o}`);
        return s;
      },
      enc(o) {
        return e.setBigInt64(0, this.parse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      uEnc(o) {
        return e.setBigInt64(0, this.uParse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      dec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigInt64(0, !0);
      },
      uDec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigUint64(0, !0);
      }
    };
  }
  return {
    zero: "0",
    supported: !1,
    parse(t) {
      return typeof t != "string" && (t = t.toString()), nk(t), t;
    },
    uParse(t) {
      return typeof t != "string" && (t = t.toString()), rk(t), t;
    },
    enc(t) {
      return typeof t != "string" && (t = t.toString()), nk(t), ek(t);
    },
    uEnc(t) {
      return typeof t != "string" && (t = t.toString()), rk(t), ek(t);
    },
    dec(t, n) {
      return Mle(t, n);
    },
    uDec(t, n) {
      return F8(t, n);
    }
  };
}
function nk(e) {
  if (!/^-?[0-9]+$/.test(e))
    throw new Error("invalid int64: " + e);
}
function rk(e) {
  if (!/^[0-9]+$/.test(e))
    throw new Error("invalid uint64: " + e);
}
function Ws(e, t) {
  switch (e) {
    case w.STRING:
      return "";
    case w.BOOL:
      return !1;
    case w.DOUBLE:
    case w.FLOAT:
      return 0;
    case w.INT64:
    case w.UINT64:
    case w.SFIXED64:
    case w.FIXED64:
    case w.SINT64:
      return t ? "0" : Q.zero;
    case w.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function Wle(e, t) {
  switch (e) {
    case w.BOOL:
      return t === !1;
    case w.STRING:
      return t === "";
    case w.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
const R8 = 2, Ra = /* @__PURE__ */ Symbol.for("reflect unsafe local");
function $8(e, t) {
  const n = e[t.localName].case;
  return n === void 0 ? n : t.fields.find((r) => r.localName === n);
}
function Jle(e, t) {
  const n = t.localName;
  if (t.oneof)
    return e[t.oneof.localName].case === n;
  if (t.presence != R8)
    return e[n] !== void 0 && Object.prototype.hasOwnProperty.call(e, n);
  switch (t.fieldKind) {
    case "list":
      return e[n].length > 0;
    case "map":
      return Object.keys(e[n]).length > 0;
    case "scalar":
      return !Wle(t.scalar, e[n]);
    case "enum":
      return e[n] !== t.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function sc(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) && e[t] !== void 0;
}
function P8(e, t) {
  if (t.oneof) {
    const n = e[t.oneof.localName];
    return n.case === t.localName ? n.value : void 0;
  }
  return e[t.localName];
}
function V8(e, t, n) {
  t.oneof ? e[t.oneof.localName] = {
    case: t.localName,
    value: n
  } : e[t.localName] = n;
}
function Zle(e, t) {
  const n = t.localName;
  if (t.oneof) {
    const r = t.oneof.localName;
    e[r].case === n && (e[r] = { case: void 0 });
  } else if (t.presence != R8)
    delete e[n];
  else
    switch (t.fieldKind) {
      case "map":
        e[n] = {};
        break;
      case "list":
        e[n] = [];
        break;
      case "enum":
        e[n] = t.enum.values[0].number;
        break;
      case "scalar":
        e[n] = Ws(t.scalar, t.longAsString);
        break;
    }
}
function _o(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function x1(e, t) {
  var n, r, a, o;
  if (_o(e) && Ra in e && "add" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.listKind == i.listKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function Y1(e, t) {
  var n, r, a, o;
  if (_o(e) && Ra in e && "has" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.mapKey === i.mapKey && s.mapKind == i.mapKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function j1(e, t) {
  return _o(e) && Ra in e && "desc" in e && _o(e.desc) && e.desc.kind === "message" && (t === void 0 || e.desc.typeName == t.typeName);
}
function Hle(e) {
  return x8(e.$typeName);
}
function Df(e) {
  const t = e.fields[0];
  return x8(e.typeName) && t !== void 0 && t.fieldKind == "scalar" && t.name == "value" && t.number == 1;
}
function x8(e) {
  return e.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(e.substring(16));
}
const zle = 999, qle = 998, fd = 2;
function Or(e, t) {
  if (P1(t, e))
    return t;
  const n = rce(e);
  return t !== void 0 && Qle(e, n, t), n;
}
function Qle(e, t, n) {
  for (const r of e.members) {
    let a = n[r.localName];
    if (a == null)
      continue;
    let o;
    if (r.kind == "oneof") {
      const s = $8(n, r);
      if (!s)
        continue;
      o = s, a = P8(n, s);
    } else
      o = r;
    switch (o.fieldKind) {
      case "message":
        a = B1(o, a);
        break;
      case "scalar":
        a = Y8(o, a);
        break;
      case "list":
        a = tce(o, a);
        break;
      case "map":
        a = ece(o, a);
        break;
    }
    V8(t, o, a);
  }
  return t;
}
function Y8(e, t) {
  return e.scalar == w.BYTES ? G1(t) : t;
}
function ece(e, t) {
  if (_o(t)) {
    if (e.scalar == w.BYTES)
      return ak(t, G1);
    if (e.mapKind == "message")
      return ak(t, (n) => B1(e, n));
  }
  return t;
}
function tce(e, t) {
  if (Array.isArray(t)) {
    if (e.scalar == w.BYTES)
      return t.map(G1);
    if (e.listKind == "message")
      return t.map((n) => B1(e, n));
  }
  return t;
}
function B1(e, t) {
  if (e.fieldKind == "message" && !e.oneof && Df(e.message))
    return Y8(e.message.fields[0], t);
  if (_o(t)) {
    if (e.message.typeName == "google.protobuf.Struct" && e.parent.typeName !== "google.protobuf.Value")
      return t;
    if (!P1(t, e.message))
      return Or(e.message, t);
  }
  return t;
}
function G1(e) {
  return Array.isArray(e) ? new Uint8Array(e) : e;
}
function ak(e, t) {
  const n = {};
  for (const r of Object.entries(e))
    n[r[0]] = t(r[1]);
  return n;
}
const nce = /* @__PURE__ */ Symbol(), ok = /* @__PURE__ */ new WeakMap();
function rce(e) {
  let t;
  if (ace(e)) {
    const n = ok.get(e);
    let r, a;
    if (n)
      ({ prototype: r, members: a } = n);
    else {
      r = {}, a = /* @__PURE__ */ new Set();
      for (const o of e.members)
        o.kind != "oneof" && (o.fieldKind != "scalar" && o.fieldKind != "enum" || o.presence != fd && (a.add(o), r[o.localName] = Fh(o)));
      ok.set(e, { prototype: r, members: a });
    }
    t = Object.create(r), t.$typeName = e.typeName;
    for (const o of e.members)
      a.has(o) || o.kind == "field" && (o.fieldKind == "message" || (o.fieldKind == "scalar" || o.fieldKind == "enum") && o.presence != fd) || (t[o.localName] = Fh(o));
  } else {
    t = {
      $typeName: e.typeName
    };
    for (const n of e.members)
      (n.kind == "oneof" || n.presence == fd) && (t[n.localName] = Fh(n));
  }
  return t;
}
function ace(e) {
  switch (e.file.edition) {
    case zle:
      return !1;
    case qle:
      return !0;
    default:
      return e.fields.some((t) => t.presence != fd && t.fieldKind != "message" && !t.oneof);
  }
}
function Fh(e) {
  if (e.kind == "oneof")
    return { case: void 0 };
  if (e.fieldKind == "list")
    return [];
  if (e.fieldKind == "map")
    return {};
  if (e.fieldKind == "message")
    return nce;
  const t = e.getDefaultValue();
  return t !== void 0 ? e.fieldKind == "scalar" && e.longAsString ? t.toString() : t : e.fieldKind == "scalar" ? Ws(e.scalar, e.longAsString) : e.enum.values[0].number;
}
const oce = [
  "FieldValueInvalidError",
  "FieldListRangeError",
  "ForeignFieldError"
];
class Ht extends Error {
  constructor(t, n, r = "FieldValueInvalidError") {
    super(n), this.name = r, this.field = () => t;
  }
}
function sce(e) {
  return e instanceof Error && oce.includes(e.name) && "field" in e && typeof e.field == "function";
}
const Uh = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
function M1() {
  if (globalThis[Uh] == null) {
    const e = new globalThis.TextEncoder(), t = new globalThis.TextDecoder();
    globalThis[Uh] = {
      encodeUtf8(n) {
        return e.encode(n);
      },
      decodeUtf8(n) {
        return t.decode(n);
      },
      checkUtf8(n) {
        try {
          return encodeURIComponent(n), !0;
        } catch {
          return !1;
        }
      }
    };
  }
  return globalThis[Uh];
}
var fe;
(function(e) {
  e[e.Varint = 0] = "Varint", e[e.Bit64 = 1] = "Bit64", e[e.LengthDelimited = 2] = "LengthDelimited", e[e.StartGroup = 3] = "StartGroup", e[e.EndGroup = 4] = "EndGroup", e[e.Bit32 = 5] = "Bit32";
})(fe || (fe = {}));
const j8 = 34028234663852886e22, B8 = -34028234663852886e22, G8 = 4294967295, M8 = 2147483647, C8 = -2147483648;
class K8 {
  constructor(t = M1().encodeUtf8) {
    this.encodeUtf8 = t, this.stack = [], this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []);
    let t = 0;
    for (let a = 0; a < this.chunks.length; a++)
      t += this.chunks[a].length;
    let n = new Uint8Array(t), r = 0;
    for (let a = 0; a < this.chunks.length; a++)
      n.set(this.chunks[a], r), r += this.chunks[a].length;
    return this.chunks = [], n;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), n = this.stack.pop();
    if (!n)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = n.chunks, this.buf = n.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, n) {
    return this.uint32((t << 3 | n) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (sk(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return Rh(t), kN(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let n = this.encodeUtf8(t);
    return this.uint32(n.byteLength), this.raw(n);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    ice(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setFloat32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let n = new Uint8Array(8);
    return new DataView(n.buffer).setFloat64(0, t, !0), this.raw(n);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    sk(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    Rh(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setInt32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return Rh(t), t = (t << 1 ^ t >> 31) >>> 0, kN(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = Q.enc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = Q.uEnc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let n = Q.enc(t);
    return Lh(n.lo, n.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    const n = Q.enc(t), r = n.hi >> 31, a = n.lo << 1 ^ r, o = (n.hi << 1 | n.lo >>> 31) ^ r;
    return Lh(a, o, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    const n = Q.uEnc(t);
    return Lh(n.lo, n.hi, this.buf), this;
  }
}
class C1 {
  constructor(t, n = M1().decodeUtf8) {
    this.decodeUtf8 = n, this.varint64 = Gle, this.uint32 = Kle, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), n = t >>> 3, r = t & 7;
    if (n <= 0 || r < 0 || r > 5)
      throw new Error("illegal tag: field no " + n + " wire type " + r);
    return [n, r];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, n) {
    let r = this.pos;
    switch (t) {
      case fe.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case fe.Bit64:
        this.pos += 4;
      case fe.Bit32:
        this.pos += 4;
        break;
      case fe.LengthDelimited:
        let a = this.uint32();
        this.pos += a;
        break;
      case fe.StartGroup:
        for (; ; ) {
          const [o, s] = this.tag();
          if (s === fe.EndGroup) {
            if (n !== void 0 && o !== n)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(s, o);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return Q.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return Q.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, n] = this.varint64(), r = -(t & 1);
    return t = (t >>> 1 | (n & 1) << 31) ^ r, n = n >>> 1 ^ r, Q.dec(t, n);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, n] = this.varint64();
    return t !== 0 || n !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return Q.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return Q.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), n = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(n, n + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function Rh(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid int32: " + typeof e);
  if (!Number.isInteger(e) || e > M8 || e < C8)
    throw new Error("invalid int32: " + e);
}
function sk(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid uint32: " + typeof e);
  if (!Number.isInteger(e) || e > G8 || e < 0)
    throw new Error("invalid uint32: " + e);
}
function ice(e) {
  if (typeof e == "string") {
    const t = e;
    if (e = Number(e), Number.isNaN(e) && t !== "NaN")
      throw new Error("invalid float32: " + t);
  } else if (typeof e != "number")
    throw new Error("invalid float32: " + typeof e);
  if (Number.isFinite(e) && (e > j8 || e < B8))
    throw new Error("invalid float32: " + e);
}
function Go(e, t) {
  const n = e.fieldKind == "list" ? x1(t, e) : e.fieldKind == "map" ? Y1(t, e) : K1(e, t);
  if (n === !0)
    return;
  let r;
  switch (e.fieldKind) {
    case "list":
      r = `expected ${J8(e)}, got ${Be(t)}`;
      break;
    case "map":
      r = `expected ${Z8(e)}, got ${Be(t)}`;
      break;
    default:
      r = kp(e, t, n);
  }
  return new Ht(e, r);
}
function ik(e, t, n) {
  const r = K1(e, n);
  if (r !== !0)
    return new Ht(e, `list item #${t + 1}: ${kp(e, n, r)}`);
}
function uce(e, t, n) {
  const r = X8(t, e.mapKey);
  if (r !== !0)
    return new Ht(e, `invalid map key: ${kp({ scalar: e.mapKey }, t, r)}`);
  const a = K1(e, n);
  if (a !== !0)
    return new Ht(e, `map entry ${Be(t)}: ${kp(e, n, a)}`);
}
function K1(e, t) {
  return e.scalar !== void 0 ? X8(t, e.scalar) : e.enum !== void 0 ? e.enum.open ? Number.isInteger(t) : e.enum.values.some((n) => n.number === t) : j1(t, e.message);
}
function X8(e, t) {
  switch (t) {
    case w.DOUBLE:
      return typeof e == "number";
    case w.FLOAT:
      return typeof e != "number" ? !1 : Number.isNaN(e) || !Number.isFinite(e) ? !0 : e > j8 || e < B8 ? `${e.toFixed()} out of range` : !0;
    case w.INT32:
    case w.SFIXED32:
    case w.SINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > M8 || e < C8 ? `${e.toFixed()} out of range` : !0;
    case w.FIXED32:
    case w.UINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > G8 || e < 0 ? `${e.toFixed()} out of range` : !0;
    case w.BOOL:
      return typeof e == "boolean";
    case w.STRING:
      return typeof e != "string" ? !1 : M1().checkUtf8(e) || "invalid UTF8";
    case w.BYTES:
      return e instanceof Uint8Array;
    case w.INT64:
    case w.SFIXED64:
    case w.SINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return Q.parse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
    case w.FIXED64:
    case w.UINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return Q.uParse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
  }
}
function kp(e, t, n) {
  return n = typeof n == "string" ? `: ${n}` : `, got ${Be(t)}`, e.scalar !== void 0 ? `expected ${lce(e.scalar)}` + n : e.enum !== void 0 ? `expected ${e.enum.toString()}` + n : `expected ${W8(e.message)}` + n;
}
function Be(e) {
  switch (typeof e) {
    case "object":
      return e === null ? "null" : e instanceof Uint8Array ? `Uint8Array(${e.length})` : Array.isArray(e) ? `Array(${e.length})` : x1(e) ? J8(e.field()) : Y1(e) ? Z8(e.field()) : j1(e) ? W8(e.desc) : P1(e) ? `message ${e.$typeName}` : "object";
    case "string":
      return e.length > 30 ? "string" : `"${e.split('"').join('\\"')}"`;
    case "boolean":
      return String(e);
    case "number":
      return String(e);
    case "bigint":
      return String(e) + "n";
    default:
      return typeof e;
  }
}
function W8(e) {
  return `ReflectMessage (${e.typeName})`;
}
function J8(e) {
  switch (e.listKind) {
    case "message":
      return `ReflectList (${e.message.toString()})`;
    case "enum":
      return `ReflectList (${e.enum.toString()})`;
    case "scalar":
      return `ReflectList (${w[e.scalar]})`;
  }
}
function Z8(e) {
  switch (e.mapKind) {
    case "message":
      return `ReflectMap (${w[e.mapKey]}, ${e.message.toString()})`;
    case "enum":
      return `ReflectMap (${w[e.mapKey]}, ${e.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${w[e.mapKey]}, ${w[e.scalar]})`;
  }
}
function lce(e) {
  switch (e) {
    case w.STRING:
      return "string";
    case w.BOOL:
      return "boolean";
    case w.INT64:
    case w.SINT64:
    case w.SFIXED64:
      return "bigint (int64)";
    case w.UINT64:
    case w.FIXED64:
      return "bigint (uint64)";
    case w.BYTES:
      return "Uint8Array";
    case w.DOUBLE:
      return "number (float64)";
    case w.FLOAT:
      return "number (float32)";
    case w.FIXED32:
    case w.UINT32:
      return "number (uint32)";
    case w.INT32:
    case w.SFIXED32:
    case w.SINT32:
      return "number (int32)";
  }
}
function Qn(e, t, n = !0) {
  return new H8(e, t, n);
}
const uk = /* @__PURE__ */ new WeakMap();
class H8 {
  get sortedFields() {
    const t = uk.get(this.desc);
    if (t)
      return t;
    const n = this.desc.fields.concat().sort((r, a) => r.number - a.number);
    return uk.set(this.desc, n), n;
  }
  constructor(t, n, r = !0) {
    this.lists = /* @__PURE__ */ new Map(), this.maps = /* @__PURE__ */ new Map(), this.check = r, this.desc = t, this.message = this[Ra] = n ?? Or(t), this.fields = t.fields, this.oneofs = t.oneofs, this.members = t.members;
  }
  findNumber(t) {
    return this._fieldsByNumber || (this._fieldsByNumber = new Map(this.desc.fields.map((n) => [n.number, n]))), this._fieldsByNumber.get(t);
  }
  oneofCase(t) {
    return Vu(this.message, t), $8(this.message, t);
  }
  isSet(t) {
    return Vu(this.message, t), Jle(this.message, t);
  }
  clear(t) {
    Vu(this.message, t), Zle(this.message, t);
  }
  get(t) {
    Vu(this.message, t);
    const n = P8(this.message, t);
    switch (t.fieldKind) {
      case "list":
        let r = this.lists.get(t);
        return (!r || r[Ra] !== n) && this.lists.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          r = new cce(t, n, this.check)
        ), r;
      case "map":
        let a = this.maps.get(t);
        return (!a || a[Ra] !== n) && this.maps.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = new fce(t, n, this.check)
        ), a;
      case "message":
        return W1(t, n, this.check);
      case "scalar":
        return n === void 0 ? Ws(t.scalar, !1) : J1(t, n);
      case "enum":
        return n ?? t.enum.values[0].number;
    }
  }
  set(t, n) {
    if (Vu(this.message, t), this.check) {
      const a = Go(t, n);
      if (a)
        throw a;
    }
    let r;
    t.fieldKind == "message" ? r = X1(t, n) : Y1(n) || x1(n) ? r = n[Ra] : r = Z1(t, n), V8(this.message, t, r);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(t) {
    this.message.$unknown = t;
  }
}
function Vu(e, t) {
  if (t.parent.typeName !== e.$typeName)
    throw new Ht(t, `cannot use ${t.toString()} with message ${e.$typeName}`, "ForeignFieldError");
}
class cce {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(t, n, r) {
    this._field = t, this._arr = this[Ra] = n, this.check = r;
  }
  get(t) {
    const n = this._arr[t];
    return n === void 0 ? void 0 : $h(this._field, n, this.check);
  }
  set(t, n) {
    if (t < 0 || t >= this._arr.length)
      throw new Ht(this._field, `list item #${t + 1}: out of range`);
    if (this.check) {
      const r = ik(this._field, t, n);
      if (r)
        throw r;
    }
    this._arr[t] = lk(this._field, n);
  }
  add(t) {
    if (this.check) {
      const n = ik(this._field, this._arr.length, t);
      if (n)
        throw n;
    }
    this._arr.push(lk(this._field, t));
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const t of this._arr)
      yield $h(this._field, t, this.check);
  }
  *entries() {
    for (let t = 0; t < this._arr.length; t++)
      yield [t, $h(this._field, this._arr[t], this.check)];
  }
}
class fce {
  constructor(t, n, r = !0) {
    this.obj = this[Ra] = n ?? {}, this.check = r, this._field = t;
  }
  field() {
    return this._field;
  }
  set(t, n) {
    if (this.check) {
      const r = uce(this._field, t, n);
      if (r)
        throw r;
    }
    return this.obj[km(t)] = mce(this._field, n), this;
  }
  delete(t) {
    const n = km(t), r = Object.prototype.hasOwnProperty.call(this.obj, n);
    return r && delete this.obj[n], r;
  }
  clear() {
    for (const t of Object.keys(this.obj))
      delete this.obj[t];
  }
  get(t) {
    let n = this.obj[km(t)];
    return n !== void 0 && (n = Ph(this._field, n, this.check)), n;
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.obj, km(t));
  }
  *keys() {
    for (const t of Object.keys(this.obj))
      yield ck(t, this._field.mapKey);
  }
  *entries() {
    for (const t of Object.entries(this.obj))
      yield [
        ck(t[0], this._field.mapKey),
        Ph(this._field, t[1], this.check)
      ];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const t of Object.values(this.obj))
      yield Ph(this._field, t, this.check);
  }
  forEach(t, n) {
    for (const r of this.entries())
      t.call(n, r[1], r[0], this);
  }
}
function X1(e, t) {
  return j1(t) ? Hle(t.message) && !e.oneof && e.fieldKind == "message" ? t.message.value : t.desc.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" ? q8(t.message) : t.message : t;
}
function W1(e, t, n) {
  return t !== void 0 && (Df(e.message) && !e.oneof && e.fieldKind == "message" ? t = {
    $typeName: e.message.typeName,
    value: J1(e.message.fields[0], t)
  } : e.message.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" && _o(t) && (t = z8(t))), new H8(e.message, t, n);
}
function lk(e, t) {
  return e.listKind == "message" ? X1(e, t) : Z1(e, t);
}
function $h(e, t, n) {
  return e.listKind == "message" ? W1(e, t, n) : J1(e, t);
}
function mce(e, t) {
  return e.mapKind == "message" ? X1(e, t) : Z1(e, t);
}
function Ph(e, t, n) {
  return e.mapKind == "message" ? W1(e, t, n) : t;
}
function km(e) {
  return typeof e == "string" || typeof e == "number" ? e : String(e);
}
function ck(e, t) {
  switch (t) {
    case w.STRING:
      return e;
    case w.INT32:
    case w.FIXED32:
    case w.UINT32:
    case w.SFIXED32:
    case w.SINT32: {
      const n = Number.parseInt(e);
      if (Number.isFinite(n))
        return n;
      break;
    }
    case w.BOOL:
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      break;
    case w.UINT64:
    case w.FIXED64:
      try {
        return Q.uParse(e);
      } catch {
      }
      break;
    default:
      try {
        return Q.parse(e);
      } catch {
      }
      break;
  }
  return e;
}
function J1(e, t) {
  switch (e.scalar) {
    case w.INT64:
    case w.SFIXED64:
    case w.SINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = Q.parse(t));
      break;
    case w.FIXED64:
    case w.UINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = Q.uParse(t));
      break;
  }
  return t;
}
function Z1(e, t) {
  switch (e.scalar) {
    case w.INT64:
    case w.SFIXED64:
    case w.SINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = Q.parse(t));
      break;
    case w.FIXED64:
    case w.UINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = Q.uParse(t));
      break;
  }
  return t;
}
function z8(e) {
  const t = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (_o(e))
    for (const [n, r] of Object.entries(e))
      t.fields[n] = eY(r);
  return t;
}
function q8(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = Q8(r);
  return t;
}
function Q8(e) {
  switch (e.kind.case) {
    case "structValue":
      return q8(e.kind.value);
    case "listValue":
      return e.kind.value.values.map(Q8);
    case "nullValue":
    case void 0:
      return null;
    default:
      return e.kind.value;
  }
}
function eY(e) {
  const t = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof e) {
    case "number":
      t.kind = { case: "numberValue", value: e };
      break;
    case "string":
      t.kind = { case: "stringValue", value: e };
      break;
    case "boolean":
      t.kind = { case: "boolValue", value: e };
      break;
    case "object":
      if (e === null)
        t.kind = { case: "nullValue", value: 0 };
      else if (Array.isArray(e)) {
        const n = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(e))
          for (const r of e)
            n.values.push(eY(r));
        t.kind = {
          case: "listValue",
          value: n
        };
      } else
        t.kind = {
          case: "structValue",
          value: z8(e)
        };
      break;
  }
  return t;
}
function H1(e) {
  const t = dce();
  let n = e.length * 3 / 4;
  e[e.length - 2] == "=" ? n -= 2 : e[e.length - 1] == "=" && (n -= 1);
  let r = new Uint8Array(n), a = 0, o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++) {
    if (s = t[e.charCodeAt(u)], s === void 0)
      switch (e[u]) {
        // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
        case "=":
          o = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string");
      }
    switch (o) {
      case 0:
        i = s, o = 1;
        break;
      case 1:
        r[a++] = i << 2 | (s & 48) >> 4, i = s, o = 2;
        break;
      case 2:
        r[a++] = (i & 15) << 4 | (s & 60) >> 2, i = s, o = 3;
        break;
      case 3:
        r[a++] = (i & 3) << 6 | s, o = 0;
        break;
    }
  }
  if (o == 1)
    throw Error("invalid base64 string");
  return r.subarray(0, a);
}
function tY(e, t = "std") {
  const n = nY(t), r = t == "std";
  let a = "", o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++)
    switch (s = e[u], o) {
      case 0:
        a += n[s >> 2], i = (s & 3) << 4, o = 1;
        break;
      case 1:
        a += n[i | s >> 4], i = (s & 15) << 2, o = 2;
        break;
      case 2:
        a += n[i | s >> 6], a += n[s & 63], o = 0;
        break;
    }
  return o && (a += n[i], r && (a += "=", o == 1 && (a += "="))), a;
}
let Am, fk, ii;
function nY(e) {
  return Am || (Am = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), fk = Am.slice(0, -2).concat("-", "_")), e == "url" ? (
    // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
    fk
  ) : Am;
}
function dce() {
  if (!ii) {
    ii = [];
    const e = nY("std");
    for (let t = 0; t < e.length; t++)
      ii[e[t].charCodeAt(0)] = t;
    ii[45] = e.indexOf("+"), ii[95] = e.indexOf("/");
  }
  return ii;
}
function ic(e) {
  let t = !1;
  const n = [];
  for (let r = 0; r < e.length; r++) {
    let a = e.charAt(r);
    switch (a) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        n.push(a), t = !1;
        break;
      default:
        t && (t = !1, a = a.toUpperCase()), n.push(a);
        break;
    }
  }
  return n.join("");
}
const pce = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function uc(e) {
  return pce.has(e) ? e + "$" : e;
}
function z1(e) {
  for (const t of e.field)
    sc(t, "jsonName") || (t.jsonName = ic(t.name));
  e.nestedType.forEach(z1);
}
function bce(e, t) {
  const n = e.values.find((r) => r.name === t);
  if (!n)
    throw new Error(`cannot parse ${e} default value: ${t}`);
  return n.number;
}
function gce(e, t) {
  switch (e) {
    case w.STRING:
      return t;
    case w.BYTES: {
      const n = hce(t);
      if (n === !1)
        throw new Error(`cannot parse ${w[e]} default value: ${t}`);
      return n;
    }
    case w.INT64:
    case w.SFIXED64:
    case w.SINT64:
      return Q.parse(t);
    case w.UINT64:
    case w.FIXED64:
      return Q.uParse(t);
    case w.DOUBLE:
    case w.FLOAT:
      switch (t) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(t);
      }
    case w.BOOL:
      return t === "true";
    case w.INT32:
    case w.UINT32:
    case w.SINT32:
    case w.FIXED32:
    case w.SFIXED32:
      return parseInt(t, 10);
  }
}
function hce(e) {
  const t = [], n = {
    tail: e,
    c: "",
    next() {
      return this.tail.length == 0 ? !1 : (this.c = this.tail[0], this.tail = this.tail.substring(1), !0);
    },
    take(r) {
      if (this.tail.length >= r) {
        const a = this.tail.substring(0, r);
        return this.tail = this.tail.substring(r), a;
      }
      return !1;
    }
  };
  for (; n.next(); )
    switch (n.c) {
      case "\\":
        if (n.next())
          switch (n.c) {
            case "\\":
              t.push(n.c.charCodeAt(0));
              break;
            case "b":
              t.push(8);
              break;
            case "f":
              t.push(12);
              break;
            case "n":
              t.push(10);
              break;
            case "r":
              t.push(13);
              break;
            case "t":
              t.push(9);
              break;
            case "v":
              t.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 8);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "x": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "u": {
              const r = n.c, a = n.take(4);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              const s = new Uint8Array(4);
              new DataView(s.buffer).setInt32(0, o, !0), t.push(s[0], s[1], s[2], s[3]);
              break;
            }
            case "U": {
              const r = n.c, a = n.take(8);
              if (a === !1)
                return !1;
              const o = Q.uEnc(r + a), s = new Uint8Array(8), i = new DataView(s.buffer);
              i.setInt32(0, o.lo, !0), i.setInt32(4, o.hi, !0), t.push(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
              break;
            }
          }
        break;
      default:
        t.push(n.c.charCodeAt(0));
    }
  return new Uint8Array(t);
}
function* AN(e) {
  switch (e.kind) {
    case "file":
      for (const t of e.messages)
        yield t, yield* AN(t);
      yield* e.enums, yield* e.services, yield* e.extensions;
      break;
    case "message":
      for (const t of e.nestedMessages)
        yield t, yield* AN(t);
      yield* e.nestedEnums, yield* e.nestedExtensions;
      break;
  }
}
function rY(...e) {
  const t = yce();
  if (!e.length)
    return t;
  if ("$typeName" in e[0] && e[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const n of e[0].file)
      gk(n, t);
    return t;
  }
  if ("$typeName" in e[0]) {
    let n = function(s) {
      const i = [];
      for (const u of s.dependency) {
        if (t.getFile(u) != null || o.has(u))
          continue;
        const l = a(u);
        if (!l)
          throw new Error(`Unable to resolve ${u}, imported by ${s.name}`);
        "kind" in l ? t.addFile(l, !1, !0) : (o.add(l.name), i.push(l));
      }
      return i.concat(...i.map(n));
    };
    const r = e[0], a = e[1], o = /* @__PURE__ */ new Set();
    for (const s of [r, ...n(r)].reverse())
      gk(s, t);
  } else
    for (const n of e)
      for (const r of n.files)
        t.addFile(r);
  return t;
}
function yce() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    kind: "registry",
    types: e,
    extendees: t,
    [Symbol.iterator]() {
      return e.values();
    },
    get files() {
      return n.values();
    },
    addFile(r, a, o) {
      if (n.set(r.proto.name, r), !a)
        for (const s of AN(r))
          this.add(s);
      if (o)
        for (const s of r.dependencies)
          this.addFile(s, a, o);
    },
    add(r) {
      if (r.kind == "extension") {
        let a = t.get(r.extendee.typeName);
        a || t.set(
          r.extendee.typeName,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = /* @__PURE__ */ new Map()
        ), a.set(r.number, r);
      }
      e.set(r.typeName, r);
    },
    get(r) {
      return e.get(r);
    },
    getFile(r) {
      return n.get(r);
    },
    getMessage(r) {
      const a = e.get(r);
      return a?.kind == "message" ? a : void 0;
    },
    getEnum(r) {
      const a = e.get(r);
      return a?.kind == "enum" ? a : void 0;
    },
    getExtension(r) {
      const a = e.get(r);
      return a?.kind == "extension" ? a : void 0;
    },
    getExtensionFor(r, a) {
      var o;
      return (o = t.get(r.typeName)) === null || o === void 0 ? void 0 : o.get(a);
    },
    getService(r) {
      const a = e.get(r);
      return a?.kind == "service" ? a : void 0;
    }
  };
}
const Nce = 998, Ece = 999, vce = 9, lc = 10, Ju = 11, Tce = 12, mk = 14, q1 = 3, Ice = 2, dk = 1, wce = 0, pk = 1, bk = 2, _ce = 3, Oce = 1, Sce = 2, Dce = 1, aY = {
  // EDITION_PROTO2
  998: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 2,
    // CLOSED,
    repeatedFieldEncoding: 2,
    // EXPANDED,
    utf8Validation: 3,
    // NONE,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 2,
    // LEGACY_BEST_EFFORT,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_PROTO3
  999: {
    fieldPresence: 2,
    // IMPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2023
  1e3: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2024
  1001: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 1,
    // STYLE2024,
    defaultSymbolVisibility: 2
    // EXPORT_TOP_LEVEL,
  }
};
function gk(e, t) {
  var n, r;
  const a = {
    kind: "file",
    proto: e,
    deprecated: (r = (n = e.options) === null || n === void 0 ? void 0 : n.deprecated) !== null && r !== void 0 ? r : !1,
    edition: Fce(e),
    name: e.name.replace(/\.proto$/, ""),
    dependencies: Uce(e, t),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${e.name}`;
    }
  }, o = /* @__PURE__ */ new Map(), s = {
    get(i) {
      return o.get(i);
    },
    add(i) {
      var u;
      lr(((u = i.proto.options) === null || u === void 0 ? void 0 : u.mapEntry) === !0), o.set(i.typeName, i);
    }
  };
  for (const i of e.enumType)
    oY(i, a, void 0, t);
  for (const i of e.messageType)
    sY(i, a, void 0, t, s);
  for (const i of e.service)
    kce(i, a, t);
  LN(a, t);
  for (const i of o.values())
    FN(i, t, s);
  for (const i of a.messages)
    FN(i, t, s), LN(i, t);
  t.addFile(a, !0);
}
function LN(e, t) {
  switch (e.kind) {
    case "file":
      for (const n of e.proto.extension) {
        const r = UN(n, e, t);
        e.extensions.push(r), t.add(r);
      }
      break;
    case "message":
      for (const n of e.proto.extension) {
        const r = UN(n, e, t);
        e.nestedExtensions.push(r), t.add(r);
      }
      for (const n of e.nestedMessages)
        LN(n, t);
      break;
  }
}
function FN(e, t, n) {
  const r = e.proto.oneofDecl.map((o) => Lce(o, e)), a = /* @__PURE__ */ new Set();
  for (const o of e.proto.field) {
    const s = Pce(o, r), i = UN(o, e, t, s, n);
    e.fields.push(i), e.field[i.localName] = i, s === void 0 ? e.members.push(i) : (s.fields.push(i), a.has(s) || (a.add(s), e.members.push(s)));
  }
  for (const o of r.filter((s) => a.has(s)))
    e.oneofs.push(o);
  for (const o of e.nestedMessages)
    FN(o, t, n);
}
function oY(e, t, n, r) {
  var a, o, s, i, u;
  const l = Rce(e.name, e.value), c = {
    kind: "enum",
    proto: e,
    deprecated: (o = (a = e.options) === null || a === void 0 ? void 0 : a.deprecated) !== null && o !== void 0 ? o : !1,
    file: t,
    parent: n,
    open: !0,
    name: e.name,
    typeName: Qb(e, n, t),
    value: {},
    values: [],
    sharedPrefix: l,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  c.open = jce(c), r.add(c);
  for (const f of e.value) {
    const d = f.name;
    c.values.push(
      // biome-ignore lint/suspicious/noAssignInExpressions: no
      c.value[f.number] = {
        kind: "enum_value",
        proto: f,
        deprecated: (i = (s = f.options) === null || s === void 0 ? void 0 : s.deprecated) !== null && i !== void 0 ? i : !1,
        parent: c,
        name: d,
        localName: uc(l == null ? d : d.substring(l.length)),
        number: f.number,
        toString() {
          return `enum value ${c.typeName}.${d}`;
        }
      }
    );
  }
  ((u = n?.nestedEnums) !== null && u !== void 0 ? u : t.enums).push(c);
}
function sY(e, t, n, r, a) {
  var o, s, i, u;
  const l = {
    kind: "message",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    file: t,
    parent: n,
    name: e.name,
    typeName: Qb(e, n, t),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  ((i = e.options) === null || i === void 0 ? void 0 : i.mapEntry) === !0 ? a.add(l) : (((u = n?.nestedMessages) !== null && u !== void 0 ? u : t.messages).push(l), r.add(l));
  for (const c of e.enumType)
    oY(c, t, l, r);
  for (const c of e.nestedType)
    sY(c, t, l, r, a);
}
function kce(e, t, n) {
  var r, a;
  const o = {
    kind: "service",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    file: t,
    name: e.name,
    typeName: Qb(e, void 0, t),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  t.services.push(o), n.add(o);
  for (const s of e.method) {
    const i = Ace(s, o, n);
    o.methods.push(i), o.method[i.localName] = i;
  }
}
function Ace(e, t, n) {
  var r, a, o, s;
  let i;
  e.clientStreaming && e.serverStreaming ? i = "bidi_streaming" : e.clientStreaming ? i = "client_streaming" : e.serverStreaming ? i = "server_streaming" : i = "unary";
  const u = n.getMessage(va(e.inputType)), l = n.getMessage(va(e.outputType));
  lr(u, `invalid MethodDescriptorProto: input_type ${e.inputType} not found`), lr(l, `invalid MethodDescriptorProto: output_type ${e.inputType} not found`);
  const c = e.name;
  return {
    kind: "rpc",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    parent: t,
    name: c,
    localName: uc(c.length ? uc(c[0].toLowerCase() + c.substring(1)) : c),
    methodKind: i,
    input: u,
    output: l,
    idempotency: (s = (o = e.options) === null || o === void 0 ? void 0 : o.idempotencyLevel) !== null && s !== void 0 ? s : wce,
    toString() {
      return `rpc ${t.typeName}.${c}`;
    }
  };
}
function Lce(e, t) {
  return {
    kind: "oneof",
    proto: e,
    deprecated: !1,
    parent: t,
    fields: [],
    name: e.name,
    localName: uc(ic(e.name)),
    toString() {
      return `oneof ${t.typeName}.${this.name}`;
    }
  };
}
function UN(e, t, n, r, a) {
  var o, s, i;
  const u = a === void 0, l = {
    kind: "field",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    name: e.name,
    number: e.number,
    scalar: void 0,
    message: void 0,
    enum: void 0,
    presence: Vce(e, r, u, t),
    listKind: void 0,
    mapKind: void 0,
    mapKey: void 0,
    delimitedEncoding: void 0,
    packed: void 0,
    longAsString: !1,
    getDefaultValue: void 0
  };
  if (u) {
    const m = t.kind == "file" ? t : t.file, p = t.kind == "file" ? void 0 : t, b = Qb(e, p, m);
    l.kind = "extension", l.file = m, l.parent = p, l.oneof = void 0, l.typeName = b, l.jsonName = `[${b}]`, l.toString = () => `extension ${b}`;
    const g = n.getMessage(va(e.extendee));
    lr(g, `invalid FieldDescriptorProto: extendee ${e.extendee} not found`), l.extendee = g;
  } else {
    const m = t;
    lr(m.kind == "message"), l.parent = m, l.oneof = r, l.localName = r ? ic(e.name) : uc(ic(e.name)), l.jsonName = e.jsonName, l.toString = () => `field ${m.typeName}.${e.name}`;
  }
  const c = e.label, f = e.type, d = (i = e.options) === null || i === void 0 ? void 0 : i.jstype;
  if (c === q1) {
    const m = f == Ju ? a?.get(va(e.typeName)) : void 0;
    if (m) {
      l.fieldKind = "map";
      const { key: p, value: b } = Yce(m);
      return l.mapKey = p.scalar, l.mapKind = b.fieldKind, l.message = b.message, l.delimitedEncoding = !1, l.enum = b.enum, l.scalar = b.scalar, l;
    }
    switch (l.fieldKind = "list", f) {
      case Ju:
      case lc:
        l.listKind = "message", l.message = n.getMessage(va(e.typeName)), lr(l.message), l.delimitedEncoding = hk(e, t);
        break;
      case mk:
        l.listKind = "enum", l.enum = n.getEnum(va(e.typeName)), lr(l.enum);
        break;
      default:
        l.listKind = "scalar", l.scalar = f, l.longAsString = d == dk;
        break;
    }
    return l.packed = xce(e, t), l;
  }
  switch (f) {
    case Ju:
    case lc:
      l.fieldKind = "message", l.message = n.getMessage(va(e.typeName)), lr(l.message, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.delimitedEncoding = hk(e, t), l.getDefaultValue = () => {
      };
      break;
    case mk: {
      const m = n.getEnum(va(e.typeName));
      lr(m !== void 0, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.fieldKind = "enum", l.enum = n.getEnum(va(e.typeName)), l.getDefaultValue = () => sc(e, "defaultValue") ? bce(m, e.defaultValue) : void 0;
      break;
    }
    default: {
      l.fieldKind = "scalar", l.scalar = f, l.longAsString = d == dk, l.getDefaultValue = () => sc(e, "defaultValue") ? gce(f, e.defaultValue) : void 0;
      break;
    }
  }
  return l;
}
function Fce(e) {
  switch (e.syntax) {
    case "":
    case "proto2":
      return Nce;
    case "proto3":
      return Ece;
    case "editions":
      if (e.edition in aY)
        return e.edition;
      throw new Error(`${e.name}: unsupported edition`);
    default:
      throw new Error(`${e.name}: unsupported syntax "${e.syntax}"`);
  }
}
function Uce(e, t) {
  return e.dependency.map((n) => {
    const r = t.getFile(n);
    if (!r)
      throw new Error(`Cannot find ${n}, imported by ${e.name}`);
    return r;
  });
}
function Rce(e, t) {
  const n = $ce(e) + "_";
  for (const r of t) {
    if (!r.name.toLowerCase().startsWith(n))
      return;
    const a = r.name.substring(n.length);
    if (a.length == 0 || /^\d/.test(a))
      return;
  }
  return n;
}
function $ce(e) {
  return (e.substring(0, 1) + e.substring(1).replace(/[A-Z]/g, (t) => "_" + t)).toLowerCase();
}
function Qb(e, t, n) {
  let r;
  return t ? r = `${t.typeName}.${e.name}` : n.proto.package.length > 0 ? r = `${n.proto.package}.${e.name}` : r = `${e.name}`, r;
}
function va(e) {
  return e.startsWith(".") ? e.substring(1) : e;
}
function Pce(e, t) {
  if (!sc(e, "oneofIndex") || e.proto3Optional)
    return;
  const n = t[e.oneofIndex];
  return lr(n, `invalid FieldDescriptorProto: oneof #${e.oneofIndex} for field #${e.number} not found`), n;
}
function Vce(e, t, n, r) {
  if (e.label == Ice)
    return _ce;
  if (e.label == q1)
    return bk;
  if (t || e.proto3Optional || n)
    return pk;
  const a = uu("fieldPresence", { proto: e, parent: r });
  return a == bk && (e.type == Ju || e.type == lc) ? pk : a;
}
function xce(e, t) {
  if (e.label != q1)
    return !1;
  switch (e.type) {
    case vce:
    case Tce:
    case lc:
    case Ju:
      return !1;
  }
  const n = e.options;
  return n && sc(n, "packed") ? n.packed : Oce == uu("repeatedFieldEncoding", {
    proto: e,
    parent: t
  });
}
function Yce(e) {
  const t = e.fields.find((r) => r.number === 1), n = e.fields.find((r) => r.number === 2);
  return lr(t && t.fieldKind == "scalar" && t.scalar != w.BYTES && t.scalar != w.FLOAT && t.scalar != w.DOUBLE && n && n.fieldKind != "list" && n.fieldKind != "map"), { key: t, value: n };
}
function jce(e) {
  var t;
  return Dce == uu("enumType", {
    proto: e.proto,
    parent: (t = e.parent) !== null && t !== void 0 ? t : e.file
  });
}
function hk(e, t) {
  return e.type == lc ? !0 : Sce == uu("messageEncoding", {
    proto: e,
    parent: t
  });
}
function uu(e, t) {
  var n, r;
  const a = (n = t.proto.options) === null || n === void 0 ? void 0 : n.features;
  if (a) {
    const o = a[e];
    if (o != 0)
      return o;
  }
  if ("kind" in t) {
    if (t.kind == "message")
      return uu(e, (r = t.parent) !== null && r !== void 0 ? r : t.file);
    const o = aY[t.edition];
    if (!o)
      throw new Error(`feature default for edition ${t.edition} not found`);
    return o[e];
  }
  return uu(e, t.parent);
}
function lr(e, t) {
  if (!e)
    throw new Error(t);
}
function Bce(e) {
  const t = Gce(e);
  return t.messageType.forEach(z1), rY(t, () => {
  }).getFile(t.name);
}
function Gce(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    syntax: "",
    edition: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, e), { messageType: e.messageType.map(iY), enumType: e.enumType.map(uY) }));
}
function iY(e) {
  var t, n, r, a, o, s, i, u;
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.DescriptorProto",
    name: e.name,
    field: (n = (t = e.field) === null || t === void 0 ? void 0 : t.map(Mce)) !== null && n !== void 0 ? n : [],
    extension: [],
    nestedType: (a = (r = e.nestedType) === null || r === void 0 ? void 0 : r.map(iY)) !== null && a !== void 0 ? a : [],
    enumType: (s = (o = e.enumType) === null || o === void 0 ? void 0 : o.map(uY)) !== null && s !== void 0 ? s : [],
    extensionRange: (u = (i = e.extensionRange) === null || i === void 0 ? void 0 : i.map((l) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, l))) !== null && u !== void 0 ? u : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function Mce(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: !1
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, e), { options: e.options ? Cce(e.options) : void 0 }));
}
function Cce(e) {
  var t, n, r;
  return Object.assign(/* @__PURE__ */ Object.create({
    ctype: 0,
    packed: !1,
    jstype: 0,
    lazy: !1,
    unverifiedLazy: !1,
    deprecated: !1,
    weak: !1,
    debugRedact: !1,
    retention: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, e), { targets: (t = e.targets) !== null && t !== void 0 ? t : [], editionDefaults: (r = (n = e.editionDefaults) === null || n === void 0 ? void 0 : n.map((a) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, a))) !== null && r !== void 0 ? r : [], uninterpretedOption: [] }));
}
function uY(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: e.name,
    reservedName: [],
    reservedRange: [],
    value: e.value.map((t) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, t))
  });
}
function kf(e, t, ...n) {
  return n.reduce((r, a) => r.nestedMessages[a], e.messages[t]);
}
const Kce = /* @__PURE__ */ Bce({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: !0 } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false", options: { deprecated: !0 } }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1e3 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1e3, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: !0 } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1e3 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_UNSTABLE", number: 9999 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] }), Xce = /* @__PURE__ */ kf(Kce, 1);
var yk;
(function(e) {
  e[e.DECLARATION = 0] = "DECLARATION", e[e.UNVERIFIED = 1] = "UNVERIFIED";
})(yk || (yk = {}));
var Nk;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.GROUP = 10] = "GROUP", e[e.MESSAGE = 11] = "MESSAGE", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.ENUM = 14] = "ENUM", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(Nk || (Nk = {}));
var Ek;
(function(e) {
  e[e.OPTIONAL = 1] = "OPTIONAL", e[e.REPEATED = 3] = "REPEATED", e[e.REQUIRED = 2] = "REQUIRED";
})(Ek || (Ek = {}));
var vk;
(function(e) {
  e[e.SPEED = 1] = "SPEED", e[e.CODE_SIZE = 2] = "CODE_SIZE", e[e.LITE_RUNTIME = 3] = "LITE_RUNTIME";
})(vk || (vk = {}));
var Tk;
(function(e) {
  e[e.STRING = 0] = "STRING", e[e.CORD = 1] = "CORD", e[e.STRING_PIECE = 2] = "STRING_PIECE";
})(Tk || (Tk = {}));
var Ik;
(function(e) {
  e[e.JS_NORMAL = 0] = "JS_NORMAL", e[e.JS_STRING = 1] = "JS_STRING", e[e.JS_NUMBER = 2] = "JS_NUMBER";
})(Ik || (Ik = {}));
var wk;
(function(e) {
  e[e.RETENTION_UNKNOWN = 0] = "RETENTION_UNKNOWN", e[e.RETENTION_RUNTIME = 1] = "RETENTION_RUNTIME", e[e.RETENTION_SOURCE = 2] = "RETENTION_SOURCE";
})(wk || (wk = {}));
var _k;
(function(e) {
  e[e.TARGET_TYPE_UNKNOWN = 0] = "TARGET_TYPE_UNKNOWN", e[e.TARGET_TYPE_FILE = 1] = "TARGET_TYPE_FILE", e[e.TARGET_TYPE_EXTENSION_RANGE = 2] = "TARGET_TYPE_EXTENSION_RANGE", e[e.TARGET_TYPE_MESSAGE = 3] = "TARGET_TYPE_MESSAGE", e[e.TARGET_TYPE_FIELD = 4] = "TARGET_TYPE_FIELD", e[e.TARGET_TYPE_ONEOF = 5] = "TARGET_TYPE_ONEOF", e[e.TARGET_TYPE_ENUM = 6] = "TARGET_TYPE_ENUM", e[e.TARGET_TYPE_ENUM_ENTRY = 7] = "TARGET_TYPE_ENUM_ENTRY", e[e.TARGET_TYPE_SERVICE = 8] = "TARGET_TYPE_SERVICE", e[e.TARGET_TYPE_METHOD = 9] = "TARGET_TYPE_METHOD";
})(_k || (_k = {}));
var RN;
(function(e) {
  e[e.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e[e.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e[e.IDEMPOTENT = 2] = "IDEMPOTENT";
})(RN || (RN = {}));
var Ok;
(function(e) {
  e[e.DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", e[e.EXPORT_ALL = 1] = "EXPORT_ALL", e[e.EXPORT_TOP_LEVEL = 2] = "EXPORT_TOP_LEVEL", e[e.LOCAL_ALL = 3] = "LOCAL_ALL", e[e.STRICT = 4] = "STRICT";
})(Ok || (Ok = {}));
var Sk;
(function(e) {
  e[e.FIELD_PRESENCE_UNKNOWN = 0] = "FIELD_PRESENCE_UNKNOWN", e[e.EXPLICIT = 1] = "EXPLICIT", e[e.IMPLICIT = 2] = "IMPLICIT", e[e.LEGACY_REQUIRED = 3] = "LEGACY_REQUIRED";
})(Sk || (Sk = {}));
var Dk;
(function(e) {
  e[e.ENUM_TYPE_UNKNOWN = 0] = "ENUM_TYPE_UNKNOWN", e[e.OPEN = 1] = "OPEN", e[e.CLOSED = 2] = "CLOSED";
})(Dk || (Dk = {}));
var kk;
(function(e) {
  e[e.REPEATED_FIELD_ENCODING_UNKNOWN = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN", e[e.PACKED = 1] = "PACKED", e[e.EXPANDED = 2] = "EXPANDED";
})(kk || (kk = {}));
var Ak;
(function(e) {
  e[e.UTF8_VALIDATION_UNKNOWN = 0] = "UTF8_VALIDATION_UNKNOWN", e[e.VERIFY = 2] = "VERIFY", e[e.NONE = 3] = "NONE";
})(Ak || (Ak = {}));
var Lk;
(function(e) {
  e[e.MESSAGE_ENCODING_UNKNOWN = 0] = "MESSAGE_ENCODING_UNKNOWN", e[e.LENGTH_PREFIXED = 1] = "LENGTH_PREFIXED", e[e.DELIMITED = 2] = "DELIMITED";
})(Lk || (Lk = {}));
var Fk;
(function(e) {
  e[e.JSON_FORMAT_UNKNOWN = 0] = "JSON_FORMAT_UNKNOWN", e[e.ALLOW = 1] = "ALLOW", e[e.LEGACY_BEST_EFFORT = 2] = "LEGACY_BEST_EFFORT";
})(Fk || (Fk = {}));
var Uk;
(function(e) {
  e[e.ENFORCE_NAMING_STYLE_UNKNOWN = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN", e[e.STYLE2024 = 1] = "STYLE2024", e[e.STYLE_LEGACY = 2] = "STYLE_LEGACY";
})(Uk || (Uk = {}));
var Rk;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SET = 1] = "SET", e[e.ALIAS = 2] = "ALIAS";
})(Rk || (Rk = {}));
var $k;
(function(e) {
  e[e.EDITION_UNKNOWN = 0] = "EDITION_UNKNOWN", e[e.EDITION_LEGACY = 900] = "EDITION_LEGACY", e[e.EDITION_PROTO2 = 998] = "EDITION_PROTO2", e[e.EDITION_PROTO3 = 999] = "EDITION_PROTO3", e[e.EDITION_2023 = 1e3] = "EDITION_2023", e[e.EDITION_2024 = 1001] = "EDITION_2024", e[e.EDITION_UNSTABLE = 9999] = "EDITION_UNSTABLE", e[e.EDITION_1_TEST_ONLY = 1] = "EDITION_1_TEST_ONLY", e[e.EDITION_2_TEST_ONLY = 2] = "EDITION_2_TEST_ONLY", e[e.EDITION_99997_TEST_ONLY = 99997] = "EDITION_99997_TEST_ONLY", e[e.EDITION_99998_TEST_ONLY = 99998] = "EDITION_99998_TEST_ONLY", e[e.EDITION_99999_TEST_ONLY = 99999] = "EDITION_99999_TEST_ONLY", e[e.EDITION_MAX = 2147483647] = "EDITION_MAX";
})($k || ($k = {}));
var Pk;
(function(e) {
  e[e.VISIBILITY_UNSET = 0] = "VISIBILITY_UNSET", e[e.VISIBILITY_LOCAL = 1] = "VISIBILITY_LOCAL", e[e.VISIBILITY_EXPORT = 2] = "VISIBILITY_EXPORT";
})(Pk || (Pk = {}));
const Vk = {
  readUnknownFields: !0
};
function Wce(e) {
  return e ? Object.assign(Object.assign({}, Vk), e) : Vk;
}
function eg(e, t, n) {
  const r = Qn(e, void 0, !1);
  return lY(r, new C1(t), Wce(n), !1, t.byteLength), r.message;
}
function lY(e, t, n, r, a) {
  var o;
  const s = r ? t.len : t.pos + a;
  let i, u;
  const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
  for (; t.pos < s && ([i, u] = t.tag(), !(r && u == fe.EndGroup)); ) {
    const c = e.findNumber(i);
    if (!c) {
      const f = t.skip(u, i);
      n.readUnknownFields && l.push({ no: i, wireType: u, data: f });
      continue;
    }
    cY(e, t, c, u, n);
  }
  if (r && (u != fe.EndGroup || i !== a))
    throw new Error("invalid end group tag");
  l.length > 0 && e.setUnknown(l);
}
function cY(e, t, n, r, a) {
  var o;
  switch (n.fieldKind) {
    case "scalar":
      e.set(n, lu(t, n.scalar));
      break;
    case "enum":
      const s = lu(t, w.INT32);
      if (n.enum.open)
        e.set(n, s);
      else if (n.enum.values.some((i) => i.number === s))
        e.set(n, s);
      else if (a.readUnknownFields) {
        const i = [];
        kN(s, i);
        const u = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
        u.push({
          no: n.number,
          wireType: r,
          data: new Uint8Array(i)
        }), e.setUnknown(u);
      }
      break;
    case "message":
      e.set(n, Q1(t, a, n, e.get(n)));
      break;
    case "list":
      Zce(t, r, e.get(n), a);
      break;
    case "map":
      Jce(t, e.get(n), a);
      break;
  }
}
function Jce(e, t, n) {
  const r = t.field();
  let a, o;
  const s = e.uint32(), i = e.pos + s;
  for (; e.pos < i; ) {
    const [u] = e.tag();
    switch (u) {
      case 1:
        a = lu(e, r.mapKey);
        break;
      case 2:
        switch (r.mapKind) {
          case "scalar":
            o = lu(e, r.scalar);
            break;
          case "enum":
            o = e.int32();
            break;
          case "message":
            o = Q1(e, n, r);
            break;
        }
        break;
    }
  }
  if (a === void 0 && (a = Ws(r.mapKey, !1)), o === void 0)
    switch (r.mapKind) {
      case "scalar":
        o = Ws(r.scalar, !1);
        break;
      case "enum":
        o = r.enum.values[0].number;
        break;
      case "message":
        o = Qn(r.message, void 0, !1);
        break;
    }
  t.set(a, o);
}
function Zce(e, t, n, r) {
  var a;
  const o = n.field();
  if (o.listKind === "message") {
    n.add(Q1(e, r, o));
    return;
  }
  const s = (a = o.scalar) !== null && a !== void 0 ? a : w.INT32;
  if (!(t == fe.LengthDelimited && s != w.STRING && s != w.BYTES)) {
    n.add(lu(e, s));
    return;
  }
  const i = e.uint32() + e.pos;
  for (; e.pos < i; )
    n.add(lu(e, s));
}
function Q1(e, t, n, r) {
  const a = n.delimitedEncoding, o = r ?? Qn(n.message, void 0, !1);
  return lY(o, e, t, a, a ? n.number : e.uint32()), o;
}
function lu(e, t) {
  switch (t) {
    case w.STRING:
      return e.string();
    case w.BOOL:
      return e.bool();
    case w.DOUBLE:
      return e.double();
    case w.FLOAT:
      return e.float();
    case w.INT32:
      return e.int32();
    case w.INT64:
      return e.int64();
    case w.UINT64:
      return e.uint64();
    case w.FIXED64:
      return e.fixed64();
    case w.BYTES:
      return e.bytes();
    case w.FIXED32:
      return e.fixed32();
    case w.SFIXED32:
      return e.sfixed32();
    case w.SFIXED64:
      return e.sfixed64();
    case w.SINT64:
      return e.sint64();
    case w.UINT32:
      return e.uint32();
    case w.SINT32:
      return e.sint32();
  }
}
function fY(e, t) {
  var n;
  const r = eg(Xce, H1(e));
  return r.messageType.forEach(z1), r.dependency = (n = void 0) !== null && n !== void 0 ? n : [], rY(r, (a) => {
  }).getFile(r.name);
}
const Hce = /* @__PURE__ */ fY("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), zce = /* @__PURE__ */ kf(Hce, 0), qce = 3, xk = {
  writeUnknownFields: !0
};
function Qce(e) {
  return e ? Object.assign(Object.assign({}, xk), e) : xk;
}
function mY(e, t, n) {
  return Ap(new K8(), Qce(n), Qn(e, t)).finish();
}
function Ap(e, t, n) {
  var r;
  for (const a of n.sortedFields) {
    if (!n.isSet(a)) {
      if (a.presence == qce)
        throw new Error(`cannot encode ${a} to binary: required field not set`);
      continue;
    }
    dY(e, t, n, a);
  }
  if (t.writeUnknownFields)
    for (const { no: a, wireType: o, data: s } of (r = n.getUnknown()) !== null && r !== void 0 ? r : [])
      e.tag(a, o).raw(s);
  return e;
}
function dY(e, t, n, r) {
  var a;
  switch (r.fieldKind) {
    case "scalar":
    case "enum":
      Lp(e, n.desc.typeName, r.name, (a = r.scalar) !== null && a !== void 0 ? a : w.INT32, r.number, n.get(r));
      break;
    case "list":
      efe(e, t, r, n.get(r));
      break;
    case "message":
      pY(e, t, r, n.get(r));
      break;
    case "map":
      for (const [o, s] of n.get(r))
        tfe(e, t, r, o, s);
      break;
  }
}
function Lp(e, t, n, r, a, o) {
  bY(e.tag(a, nfe(r)), t, n, r, o);
}
function pY(e, t, n, r) {
  n.delimitedEncoding ? Ap(e.tag(n.number, fe.StartGroup), t, r).tag(n.number, fe.EndGroup) : Ap(e.tag(n.number, fe.LengthDelimited).fork(), t, r).join();
}
function efe(e, t, n, r) {
  var a;
  if (n.listKind == "message") {
    for (const s of r)
      pY(e, t, n, s);
    return;
  }
  const o = (a = n.scalar) !== null && a !== void 0 ? a : w.INT32;
  if (n.packed) {
    if (!r.size)
      return;
    e.tag(n.number, fe.LengthDelimited).fork();
    for (const s of r)
      bY(e, n.parent.typeName, n.name, o, s);
    e.join();
    return;
  }
  for (const s of r)
    Lp(e, n.parent.typeName, n.name, o, n.number, s);
}
function tfe(e, t, n, r, a) {
  var o;
  switch (e.tag(n.number, fe.LengthDelimited).fork(), Lp(e, n.parent.typeName, n.name, n.mapKey, 1, r), n.mapKind) {
    case "scalar":
    case "enum":
      Lp(e, n.parent.typeName, n.name, (o = n.scalar) !== null && o !== void 0 ? o : w.INT32, 2, a);
      break;
    case "message":
      Ap(e.tag(2, fe.LengthDelimited).fork(), t, a).join();
      break;
  }
  e.join();
}
function bY(e, t, n, r, a) {
  try {
    switch (r) {
      case w.STRING:
        e.string(a);
        break;
      case w.BOOL:
        e.bool(a);
        break;
      case w.DOUBLE:
        e.double(a);
        break;
      case w.FLOAT:
        e.float(a);
        break;
      case w.INT32:
        e.int32(a);
        break;
      case w.INT64:
        e.int64(a);
        break;
      case w.UINT64:
        e.uint64(a);
        break;
      case w.FIXED64:
        e.fixed64(a);
        break;
      case w.BYTES:
        e.bytes(a);
        break;
      case w.FIXED32:
        e.fixed32(a);
        break;
      case w.SFIXED32:
        e.sfixed32(a);
        break;
      case w.SFIXED64:
        e.sfixed64(a);
        break;
      case w.SINT64:
        e.sint64(a);
        break;
      case w.UINT32:
        e.uint32(a);
        break;
      case w.SINT32:
        e.sint32(a);
        break;
    }
  } catch (o) {
    throw o instanceof Error ? new Error(`cannot encode field ${t}.${n} to binary: ${o.message}`) : o;
  }
}
function nfe(e) {
  switch (e) {
    case w.BYTES:
    case w.STRING:
      return fe.LengthDelimited;
    case w.DOUBLE:
    case w.FIXED64:
    case w.SFIXED64:
      return fe.Bit64;
    case w.FIXED32:
    case w.SFIXED32:
    case w.FLOAT:
      return fe.Bit32;
    default:
      return fe.Varint;
  }
}
function rfe(e, t, n) {
  let r = !1;
  return n || (n = Or(zce), r = !0), n.value = mY(e, t), n.typeUrl = sfe(t.$typeName), r ? n : void 0;
}
function afe(e, t) {
  if (e.typeUrl === "")
    return !1;
  const n = typeof t == "string" ? t : t.typeName, r = gY(e.typeUrl);
  return n === r;
}
function ofe(e, t) {
  if (e.typeUrl === "")
    return;
  const n = t.kind == "message" ? t : t.getMessage(gY(e.typeUrl));
  if (!(!n || !afe(e, n)))
    return eg(n, e.value);
}
function sfe(e) {
  return `type.googleapis.com/${e}`;
}
function gY(e) {
  const t = e.lastIndexOf("/"), n = t >= 0 ? e.substring(t + 1) : e;
  if (!n.length)
    throw new Error(`invalid type url: ${e}`);
  return n;
}
const eT = /* @__PURE__ */ fY("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), ife = /* @__PURE__ */ kf(eT, 0), hY = /* @__PURE__ */ kf(eT, 1), ufe = /* @__PURE__ */ kf(eT, 2);
var $N;
(function(e) {
  e[e.NULL_VALUE = 0] = "NULL_VALUE";
})($N || ($N = {}));
function lfe(e, t) {
  yY(t, e);
  const n = ffe(e.$unknown, t), [r, a, o] = tg(t);
  for (const s of n)
    cY(r, new C1(s.data), a, s.wireType, {
      readUnknownFields: !0
    });
  return o();
}
function cfe(e, t, n) {
  var r;
  yY(t, e);
  const a = ((r = e.$unknown) !== null && r !== void 0 ? r : []).filter((l) => l.no !== t.number), [o, s] = tg(t, n), i = new K8();
  dY(i, { writeUnknownFields: !0 }, o, s);
  const u = new C1(i.finish());
  for (; u.pos < u.len; ) {
    const [l, c] = u.tag(), f = u.skip(c, l);
    a.push({ no: l, wireType: c, data: f });
  }
  e.$unknown = a;
}
function ffe(e, t) {
  if (e === void 0)
    return [];
  if (t.fieldKind === "enum" || t.fieldKind === "scalar") {
    for (let n = e.length - 1; n >= 0; --n)
      if (e[n].no == t.number)
        return [e[n]];
    return [];
  }
  return e.filter((n) => n.no === t.number);
}
function tg(e, t) {
  const n = e.typeName, r = Object.assign(Object.assign({}, e), { kind: "field", parent: e.extendee, localName: n }), a = Object.assign(Object.assign({}, e.extendee), { fields: [r], members: [r], oneofs: [] }), o = Or(a, t !== void 0 ? { [n]: t } : void 0);
  return [
    Qn(a, o),
    r,
    () => {
      const s = o[n];
      if (s === void 0) {
        const i = e.message;
        return Df(i) ? Ws(i.fields[0].scalar, i.fields[0].longAsString) : Or(i);
      }
      return s;
    }
  ];
}
function yY(e, t) {
  if (e.extendee.typeName != t.$typeName)
    throw new Error(`extension ${e.typeName} can only be applied to message ${e.extendee.typeName}`);
}
const mfe = 3, dfe = 2, Yk = {
  alwaysEmitImplicit: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1
};
function pfe(e) {
  return e ? Object.assign(Object.assign({}, Yk), e) : Yk;
}
function bfe(e, t, n) {
  return Af(Qn(e, t), pfe(n));
}
function gfe(e, t, n) {
  var r;
  const a = bfe(e, t, n);
  return JSON.stringify(a, null, (r = n?.prettySpaces) !== null && r !== void 0 ? r : 0);
}
function Af(e, t) {
  var n;
  const r = Efe(e, t);
  if (r !== void 0)
    return r;
  const a = {};
  for (const o of e.sortedFields) {
    if (!e.isSet(o)) {
      if (o.presence == mfe)
        throw new Error(`cannot encode ${o} to JSON: required field not set`);
      if (!t.alwaysEmitImplicit || o.presence !== dfe)
        continue;
    }
    const s = jk(o, e.get(o), t);
    s !== void 0 && (a[Nfe(o, t)] = s);
  }
  if (t.registry) {
    const o = /* @__PURE__ */ new Set();
    for (const { no: s } of (n = e.getUnknown()) !== null && n !== void 0 ? n : [])
      if (!o.has(s)) {
        o.add(s);
        const i = t.registry.getExtensionFor(e.desc, s);
        if (!i)
          continue;
        const u = lfe(e.message, i), [l, c] = tg(i, u), f = jk(c, l.get(c), t);
        f !== void 0 && (a[i.jsonName] = f);
      }
  }
  return a;
}
function jk(e, t, n) {
  switch (e.fieldKind) {
    case "scalar":
      return ng(e, t);
    case "message":
      return Af(t, n);
    case "enum":
      return tT(e.enum, t, n.enumAsInteger);
    case "list":
      return yfe(t, n);
    case "map":
      return hfe(t, n);
  }
}
function hfe(e, t) {
  const n = e.field(), r = {};
  switch (n.mapKind) {
    case "scalar":
      for (const [a, o] of e)
        r[a] = ng(n, o);
      break;
    case "message":
      for (const [a, o] of e)
        r[a] = Af(o, t);
      break;
    case "enum":
      for (const [a, o] of e)
        r[a] = tT(n.enum, o, t.enumAsInteger);
      break;
  }
  return t.alwaysEmitImplicit || e.size > 0 ? r : void 0;
}
function yfe(e, t) {
  const n = e.field(), r = [];
  switch (n.listKind) {
    case "scalar":
      for (const a of e)
        r.push(ng(n, a));
      break;
    case "enum":
      for (const a of e)
        r.push(tT(n.enum, a, t.enumAsInteger));
      break;
    case "message":
      for (const a of e)
        r.push(Af(a, t));
      break;
  }
  return t.alwaysEmitImplicit || r.length > 0 ? r : void 0;
}
function tT(e, t, n) {
  var r;
  if (typeof t != "number")
    throw new Error(`cannot encode ${e} to JSON: expected number, got ${Be(t)}`);
  return e.typeName == "google.protobuf.NullValue" ? null : n ? t : (r = e.value[t]?.name) !== null && r !== void 0 ? r : t;
}
function ng(e, t) {
  var n, r, a, o, s, i;
  switch (e.scalar) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case w.INT32:
    case w.SFIXED32:
    case w.SINT32:
    case w.FIXED32:
    case w.UINT32:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(n = Go(e, t)) === null || n === void 0 ? void 0 : n.message}`);
      return t;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case w.FLOAT:
    case w.DOUBLE:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(r = Go(e, t)) === null || r === void 0 ? void 0 : r.message}`);
      return Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    // string:
    case w.STRING:
      if (typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(a = Go(e, t)) === null || a === void 0 ? void 0 : a.message}`);
      return t;
    // bool:
    case w.BOOL:
      if (typeof t != "boolean")
        throw new Error(`cannot encode ${e} to JSON: ${(o = Go(e, t)) === null || o === void 0 ? void 0 : o.message}`);
      return t;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case w.UINT64:
    case w.FIXED64:
    case w.INT64:
    case w.SFIXED64:
    case w.SINT64:
      if (typeof t != "bigint" && typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(s = Go(e, t)) === null || s === void 0 ? void 0 : s.message}`);
      return t.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case w.BYTES:
      if (t instanceof Uint8Array)
        return tY(t);
      throw new Error(`cannot encode ${e} to JSON: ${(i = Go(e, t)) === null || i === void 0 ? void 0 : i.message}`);
  }
}
function Nfe(e, t) {
  return t.useProtoFieldName ? e.name : e.jsonName;
}
function Efe(e, t) {
  if (e.desc.typeName.startsWith("google.protobuf."))
    switch (e.desc.typeName) {
      case "google.protobuf.Any":
        return vfe(e.message, t);
      case "google.protobuf.Timestamp":
        return wfe(e.message);
      case "google.protobuf.Duration":
        return Tfe(e.message);
      case "google.protobuf.FieldMask":
        return Ife(e.message);
      case "google.protobuf.Struct":
        return NY(e.message);
      case "google.protobuf.Value":
        return nT(e.message);
      case "google.protobuf.ListValue":
        return EY(e.message);
      default:
        if (Df(e.desc)) {
          const n = e.desc.fields[0];
          return ng(n, e.get(n));
        }
        return;
    }
}
function vfe(e, t) {
  if (e.typeUrl === "")
    return {};
  const { registry: n } = t;
  let r, a;
  if (n && (r = ofe(e, n), r && (a = n.getMessage(r.$typeName))), !a || !r)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: "${e.typeUrl}" is not in the type registry`);
  let o = Af(Qn(a, r), t);
  return (a.typeName.startsWith("google.protobuf.") || o === null || Array.isArray(o) || typeof o != "object") && (o = { value: o }), o["@type"] = e.typeUrl, o;
}
function Tfe(e) {
  const t = Number(e.seconds), n = e.nanos;
  if (t > 315576e6 || t < -315576e6)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: value out of range`);
  if (t > 0 && n < 0 || t < 0 && n > 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos sign must match seconds sign`);
  let r = e.seconds.toString();
  if (n !== 0) {
    let a = Math.abs(n).toString();
    a = "0".repeat(9 - a.length) + a, a.substring(3) === "000000" ? a = a.substring(0, 3) : a.substring(6) === "000" && (a = a.substring(0, 6)), r += "." + a, n < 0 && t == 0 && (r = "-" + r);
  }
  return r + "s";
}
function Ife(e) {
  return e.paths.map((t) => {
    if (t.match(/_[0-9]?_/g) || t.match(/[A-Z]/g))
      throw new Error(`cannot encode message ${e.$typeName} to JSON: lowerCamelCase of path name "` + t + '" is irreversible');
    return ic(t);
  }).join(",");
}
function NY(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = nT(r);
  return t;
}
function nT(e) {
  switch (e.kind.case) {
    case "nullValue":
      return null;
    case "numberValue":
      if (!Number.isFinite(e.kind.value))
        throw new Error(`${e.$typeName} cannot be NaN or Infinity`);
      return e.kind.value;
    case "boolValue":
      return e.kind.value;
    case "stringValue":
      return e.kind.value;
    case "structValue":
      return NY(e.kind.value);
    case "listValue":
      return EY(e.kind.value);
    default:
      throw new Error(`${e.$typeName} must have a value`);
  }
}
function EY(e) {
  return e.values.map(nT);
}
function wfe(e) {
  const t = Number(e.seconds) * 1e3;
  if (t < Date.parse("0001-01-01T00:00:00Z") || t > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot encode message ${e.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  if (e.nanos < 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be negative`);
  if (e.nanos > 999999999)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be greater than 99999999`);
  let n = "Z";
  if (e.nanos > 0) {
    const r = (e.nanos + 1e9).toString().substring(1);
    r.substring(3) === "000000" ? n = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? n = "." + r.substring(0, 6) + "Z" : n = "." + r + "Z";
  }
  return new Date(t).toISOString().replace(".000Z", n);
}
const Bk = {
  ignoreUnknownFields: !1
};
function _fe(e) {
  return e ? Object.assign(Object.assign({}, Bk), e) : Bk;
}
function Ofe(e, t, n) {
  return vY(e, Ufe(t, e.typeName), n);
}
function vY(e, t, n) {
  const r = Qn(e);
  try {
    cu(r, t, _fe(n));
  } catch (a) {
    throw sce(a) ? new Error(`cannot decode ${a.field()} from JSON: ${a.message}`, {
      cause: a
    }) : a;
  }
  return r.message;
}
function cu(e, t, n) {
  var r;
  if (Rfe(e, t, n))
    return;
  if (t == null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode ${e.desc} from JSON: ${Be(t)}`);
  const a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const s of e.desc.fields)
    o.set(s.name, s).set(s.jsonName, s);
  for (const [s, i] of Object.entries(t)) {
    const u = o.get(s);
    if (u) {
      if (u.oneof) {
        if (i === null && u.fieldKind == "scalar")
          continue;
        const l = a.get(u.oneof);
        if (l !== void 0)
          throw new Ht(u.oneof, `oneof set multiple times by ${l.name} and ${u.name}`);
        a.set(u.oneof, u);
      }
      Gk(e, u, i, n);
    } else {
      let l;
      if (s.startsWith("[") && s.endsWith("]") && // biome-ignore lint/suspicious/noAssignInExpressions: no
      (l = (r = n.registry) === null || r === void 0 ? void 0 : r.getExtension(s.substring(1, s.length - 1))) && l.extendee.typeName === e.desc.typeName) {
        const [c, f, d] = tg(l);
        Gk(c, f, i, n), cfe(e.message, l, d());
      }
      if (!l && !n.ignoreUnknownFields)
        throw new Error(`cannot decode ${e.desc} from JSON: key "${s}" is unknown`);
    }
  }
}
function Gk(e, t, n, r) {
  switch (t.fieldKind) {
    case "scalar":
      Lfe(e, t, n);
      break;
    case "enum":
      Afe(e, t, n, r);
      break;
    case "message":
      kfe(e, t, n, r);
      break;
    case "list":
      Dfe(e.get(t), n, r);
      break;
    case "map":
      Sfe(e.get(t), n, r);
      break;
  }
}
function Sfe(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (typeof t != "object" || Array.isArray(t))
    throw new Ht(r, "expected object, got " + Be(t));
  for (const [a, o] of Object.entries(t)) {
    if (o === null && !TY(r))
      throw new Ht(r, "map value must not be null");
    let s;
    switch (r.mapKind) {
      case "message":
        const u = Qn(r.message);
        cu(u, o, n), s = u;
        break;
      case "enum":
        if (s = rT(r.enum, o, n.ignoreUnknownFields, !0), s === rg)
          return;
        break;
      case "scalar":
        s = og(r, o, !0);
        break;
    }
    const i = Ffe(r.mapKey, a);
    e.set(i, s);
  }
}
function Dfe(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (!Array.isArray(t))
    throw new Ht(r, "expected Array, got " + Be(t));
  for (const a of t) {
    if (a === null && !TY(r))
      throw new Ht(r, "list item must not be null");
    switch (r.listKind) {
      case "message":
        const o = Qn(r.message);
        cu(o, a, n), e.add(o);
        break;
      case "enum":
        const s = rT(r.enum, a, n.ignoreUnknownFields, !0);
        s !== rg && e.add(s);
        break;
      case "scalar":
        e.add(og(r, a, !0));
        break;
    }
  }
}
function TY(e) {
  var t, n;
  return ((t = e.message) === null || t === void 0 ? void 0 : t.typeName) == "google.protobuf.Value" || ((n = e.enum) === null || n === void 0 ? void 0 : n.typeName) == "google.protobuf.NullValue";
}
function kfe(e, t, n, r) {
  if (n === null && t.message.typeName != "google.protobuf.Value") {
    e.clear(t);
    return;
  }
  const a = e.isSet(t) ? e.get(t) : Qn(t.message);
  cu(a, n, r), e.set(t, a);
}
function Afe(e, t, n, r) {
  const a = rT(t.enum, n, r.ignoreUnknownFields, !1);
  a === ag ? e.clear(t) : a !== rg && e.set(t, a);
}
function Lfe(e, t, n) {
  const r = og(t, n, !1);
  r === ag ? e.clear(t) : e.set(t, r);
}
const rg = /* @__PURE__ */ Symbol();
function rT(e, t, n, r) {
  if (t === null)
    return e.typeName == "google.protobuf.NullValue" ? 0 : r ? e.values[0].number : ag;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const a = e.values.find((o) => o.name === t);
      if (a !== void 0)
        return a.number;
      if (n)
        return rg;
      break;
  }
  throw new Error(`cannot decode ${e} from JSON: ${Be(t)}`);
}
const ag = /* @__PURE__ */ Symbol();
function og(e, t, n) {
  if (t === null)
    return n ? Ws(e.scalar, !1) : ag;
  switch (e.scalar) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case w.DOUBLE:
    case w.FLOAT:
      if (t === "NaN")
        return NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (typeof t == "number") {
        if (Number.isNaN(t))
          throw new Ht(e, "unexpected NaN number");
        if (!Number.isFinite(t))
          throw new Ht(e, "unexpected infinite number");
        break;
      }
      if (typeof t == "string") {
        if (t === "" || t.trim().length !== t.length)
          break;
        const r = Number(t);
        if (!Number.isFinite(r))
          break;
        return r;
      }
      break;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case w.INT32:
    case w.FIXED32:
    case w.SFIXED32:
    case w.SINT32:
    case w.UINT32:
      return IY(t);
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case w.BYTES:
      if (typeof t == "string") {
        if (t === "")
          return new Uint8Array(0);
        try {
          return H1(t);
        } catch (r) {
          const a = r instanceof Error ? r.message : String(r);
          throw new Ht(e, a);
        }
      }
      break;
  }
  return t;
}
function Ffe(e, t) {
  switch (e) {
    case w.BOOL:
      switch (t) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      return t;
    case w.INT32:
    case w.FIXED32:
    case w.UINT32:
    case w.SFIXED32:
    case w.SINT32:
      return IY(t);
    default:
      return t;
  }
}
function IY(e) {
  if (typeof e == "string") {
    if (e === "" || e.trim().length !== e.length)
      return e;
    const t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
function Ufe(e, t) {
  try {
    return JSON.parse(e);
  } catch (n) {
    const r = n instanceof Error ? n.message : String(n);
    throw new Error(
      `cannot decode message ${t} from JSON: ${r}`,
      // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
      { cause: n }
    );
  }
}
function Rfe(e, t, n) {
  if (!e.desc.typeName.startsWith("google.protobuf."))
    return !1;
  switch (e.desc.typeName) {
    case "google.protobuf.Any":
      return $fe(e.message, t, n), !0;
    case "google.protobuf.Timestamp":
      return Pfe(e.message, t), !0;
    case "google.protobuf.Duration":
      return Vfe(e.message, t), !0;
    case "google.protobuf.FieldMask":
      return xfe(e.message, t), !0;
    case "google.protobuf.Struct":
      return wY(e.message, t), !0;
    case "google.protobuf.Value":
      return aT(e.message, t), !0;
    case "google.protobuf.ListValue":
      return _Y(e.message, t), !0;
    default:
      if (Df(e.desc)) {
        const r = e.desc.fields[0];
        return t === null ? e.clear(r) : e.set(r, og(r, t, !0)), !0;
      }
      return !1;
  }
}
function $fe(e, t, n) {
  var r;
  if (t === null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: expected object but got ${Be(t)}`);
  if (Object.keys(t).length == 0)
    return;
  const a = t["@type"];
  if (typeof a != "string" || a == "")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is empty`);
  const o = a.includes("/") ? a.substring(a.lastIndexOf("/") + 1) : a;
  if (!o.length)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is invalid`);
  const s = (r = n.registry) === null || r === void 0 ? void 0 : r.getMessage(o);
  if (!s)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${a} is not in the type registry`);
  const i = Qn(s);
  if (o.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(t, "value")) {
    const u = t.value;
    cu(i, u, n);
  } else {
    const u = Object.assign({}, t);
    delete u["@type"], cu(i, u, n);
  }
  rfe(i.desc, i.message, e);
}
function Pfe(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Be(t)}`);
  const n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
  if (!n)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  const r = Date.parse(
    // biome-ignore format: want this to read well
    n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z")
  );
  if (Number.isNaN(r))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  e.seconds = Q.parse(r / 1e3), e.nanos = 0, n[7] && (e.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9);
}
function Vfe(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Be(t)}`);
  const n = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
  if (n === null)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Be(t)}`);
  const r = Number(n[1]);
  if (r > 315576e6 || r < -315576e6)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Be(t)}`);
  if (e.seconds = Q.parse(r), typeof n[2] != "string")
    return;
  const a = n[2] + "0".repeat(9 - n[2].length);
  e.nanos = parseInt(a), (r < 0 || Object.is(r, -0)) && (e.nanos = -e.nanos);
}
function xfe(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Be(t)}`);
  if (t === "")
    return;
  function n(r) {
    if (r.includes("_"))
      throw new Error(`cannot decode message ${e.$typeName} from JSON: path names must be lowerCamelCase`);
    const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase());
    return a[0] === "_" ? a.substring(1) : a;
  }
  e.paths = t.split(",").map(n);
}
function wY(e, t) {
  if (typeof t != "object" || t == null || Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Be(t)}`);
  for (const [n, r] of Object.entries(t)) {
    const a = Or(hY);
    aT(a, r), e.fields[n] = a;
  }
}
function aT(e, t) {
  switch (typeof t) {
    case "number":
      e.kind = { case: "numberValue", value: t };
      break;
    case "string":
      e.kind = { case: "stringValue", value: t };
      break;
    case "boolean":
      e.kind = { case: "boolValue", value: t };
      break;
    case "object":
      if (t === null)
        e.kind = { case: "nullValue", value: $N.NULL_VALUE };
      else if (Array.isArray(t)) {
        const n = Or(ufe);
        _Y(n, t), e.kind = { case: "listValue", value: n };
      } else {
        const n = Or(ife);
        wY(n, t), e.kind = { case: "structValue", value: n };
      }
      break;
    default:
      throw new Error(`cannot decode message ${e.$typeName} from JSON ${Be(t)}`);
  }
  return e;
}
function _Y(e, t) {
  if (!Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Be(t)}`);
  for (const n of t) {
    const r = Or(hY);
    aT(r, n), e.values.push(r);
  }
}
function PN(e) {
  const t = M[e];
  return typeof t != "string" ? e.toString() : t[0].toLowerCase() + t.substring(1).replace(/[A-Z]/g, (n) => "_" + n.toLowerCase());
}
let Lm;
function Yfe(e) {
  if (!Lm) {
    Lm = {};
    for (const t of Object.values(M))
      typeof t != "string" && (Lm[PN(t)] = t);
  }
  return Lm[e];
}
class Le extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(t, n = M.Unknown, r, a, o) {
    super(jfe(t, n)), this.name = "ConnectError", Object.setPrototypeOf(this, new.target.prototype), this.rawMessage = t, this.code = n, this.metadata = new Headers(r ?? {}), this.details = a ?? [], this.cause = o;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(t, n = M.Unknown) {
    return t instanceof Le ? t : t instanceof Error ? t.name == "AbortError" || t.name == "TimeoutError" ? new Le(t.message, M.Canceled) : new Le(t.message, n, void 0, void 0, t) : new Le(String(t), n, void 0, void 0, t);
  }
  static [Symbol.hasInstance](t) {
    return t instanceof Error ? Object.getPrototypeOf(t) === Le.prototype ? !0 : t.name === "ConnectError" && "code" in t && typeof t.code == "number" && "metadata" in t && "details" in t && Array.isArray(t.details) && "rawMessage" in t && typeof t.rawMessage == "string" && "cause" in t : !1;
  }
  findDetails(t) {
    const n = t.kind === "message" ? {
      getMessage: (a) => a === t.typeName ? t : void 0
    } : t, r = [];
    for (const a of this.details) {
      if ("desc" in a) {
        n.getMessage(a.desc.typeName) && r.push(Or(a.desc, a.value));
        continue;
      }
      const o = n.getMessage(a.type);
      if (o)
        try {
          r.push(eg(o, a.value));
        } catch {
        }
    }
    return r;
  }
}
function jfe(e, t) {
  return e.length ? `[${PN(t)}] ${e}` : `[${PN(t)}]`;
}
function Bfe(...e) {
  const t = new Headers();
  for (const n of e)
    n.forEach((r, a) => {
      t.append(a, r);
    });
  return t;
}
const Mk = 1;
function Gfe(e, t, n = !1) {
  if (t > e) {
    let r = `message size is larger than configured readMaxBytes ${e}`;
    throw n && (r = `message size ${t} is larger than configured readMaxBytes ${e}`), new Le(r, M.ResourceExhausted);
  }
}
function Mfe(e) {
  return new Cfe(e);
}
class Cfe {
  constructor(t) {
    this.readMaxBytes = t, this.header = new Uint8Array(5), this.headerView = new DataView(this.header.buffer), this.buf = [];
  }
  get byteLength() {
    return this.buf.reduce((t, n) => t + n.byteLength, 0);
  }
  decode(t) {
    this.buf.push(t);
    const n = [];
    for (; ; ) {
      let r = this.pop();
      if (!r)
        break;
      n.push(r);
    }
    return n;
  }
  // consume an enveloped message
  pop() {
    if (!(!this.env && (this.env = this.head(), !this.env)) && this.cons(this.env.data)) {
      const t = this.env;
      return this.env = void 0, t;
    }
  }
  // consume header
  head() {
    if (!this.cons(this.header))
      return;
    const t = this.headerView.getUint8(0), n = this.headerView.getUint32(1);
    return Gfe(this.readMaxBytes, n, !0), {
      flags: t,
      data: new Uint8Array(n)
    };
  }
  // consume from buffer, fill target
  cons(t) {
    const n = t.byteLength;
    if (this.byteLength < n)
      return !1;
    let r = 0;
    for (; r < n; ) {
      const a = this.buf.shift();
      a.byteLength > n - r ? (t.set(a.subarray(0, n - r), r), this.buf.unshift(a.subarray(n - r)), r += n - r) : (t.set(a, r), r += a.byteLength);
    }
    return !0;
  }
}
function Kfe(e) {
  let t;
  const n = Mfe(4294967295);
  return new ReadableStream({
    start() {
      t = e.getReader();
    },
    async pull(r) {
      let a = !1;
      for (; !a; ) {
        const o = await t.read();
        if (o.done)
          n.byteLength > 0 && r.error(new Le("protocol error: incomplete envelope", M.InvalidArgument)), r.close();
        else
          for (const s of n.decode(o.value))
            r.enqueue(s), a = !0;
      }
    }
  });
}
function Xfe(e, t) {
  const n = new Uint8Array(t.length + 5);
  n.set(t, 5);
  const r = new DataView(n.buffer, n.byteOffset, n.byteLength);
  return r.setUint8(0, e), r.setUint32(1, t.length), n;
}
function Wfe(...e) {
  const t = new AbortController(), n = e.filter((a) => a !== void 0).concat(t.signal);
  for (const a of n) {
    if (a.aborted) {
      r.apply(a);
      break;
    }
    a.addEventListener("abort", r);
  }
  function r() {
    t.signal.aborted || t.abort(OY(this));
    for (const a of n)
      a.removeEventListener("abort", r);
  }
  return t;
}
function Jfe(e) {
  const t = new AbortController(), n = () => {
    t.abort(new Le("the operation timed out", M.DeadlineExceeded));
  };
  let r;
  return e !== void 0 && (e <= 0 ? n() : r = setTimeout(n, e)), {
    signal: t.signal,
    cleanup: () => clearTimeout(r)
  };
}
function OY(e) {
  if (!e.aborted)
    return;
  if (e.reason !== void 0)
    return e.reason;
  const t = new Error("This operation was aborted");
  return t.name = "AbortError", t;
}
function Ck() {
  return {
    get(e) {
      return e.id in this ? this[e.id] : e.defaultValue;
    },
    set(e, t) {
      return this[e.id] = t, this;
    },
    delete(e) {
      return delete this[e.id], this;
    }
  };
}
function Kk(e, t) {
  return e.toString().replace(/\/?$/, `/${t.parent.typeName}/${t.name}`);
}
function SY(e, t) {
  return Or(e, t);
}
function Zfe(e, t) {
  function n(r) {
    return r.done === !0 ? r : {
      done: r.done,
      value: SY(e, r.value)
    };
  }
  return {
    [Symbol.asyncIterator]() {
      const r = t[Symbol.asyncIterator](), a = {
        next: () => r.next().then(n)
      };
      return r.throw !== void 0 && (a.throw = (o) => r.throw(o).then(n)), r.return !== void 0 && (a.return = (o) => r.return(o).then(n)), a;
    }
  };
}
function DY(e, t) {
  if (!t)
    return e;
  for (const n of t.concat().reverse())
    e = n(e);
  return e;
}
function kY(e) {
  var t;
  const n = Object.assign({}, e);
  return (t = n.ignoreUnknownFields) !== null && t !== void 0 || (n.ignoreUnknownFields = !0), n;
}
function Xk(e, t, n, r) {
  const a = t ? Wk(e.input, r) : Jk(e.input, n);
  return { parse: (t ? Wk(e.output, r) : Jk(e.output, n)).parse, serialize: a.serialize };
}
function Wk(e, t) {
  return {
    parse(n) {
      try {
        return eg(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Le(`parse binary: ${a}`, M.Internal);
      }
    },
    serialize(n) {
      try {
        return mY(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Le(`serialize binary: ${a}`, M.Internal);
      }
    }
  };
}
function Jk(e, t) {
  var n, r;
  const a = (n = t?.textEncoder) !== null && n !== void 0 ? n : new TextEncoder(), o = (r = t?.textDecoder) !== null && r !== void 0 ? r : new TextDecoder(), s = kY(t);
  return {
    parse(i) {
      try {
        const u = o.decode(i);
        return Ofe(e, u, s);
      } catch (u) {
        throw Le.from(u, M.InvalidArgument);
      }
    },
    serialize(i) {
      try {
        const u = gfe(e, i, s);
        return a.encode(u);
      } catch (u) {
        throw Le.from(u, M.Internal);
      }
    }
  };
}
const Hfe = /^application\/(connect\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i, zfe = "application/proto", qfe = "application/json", Qfe = "application/connect+proto", eme = "application/connect+json";
function tme(e) {
  const t = e?.match(Hfe);
  if (!t)
    return;
  const n = !!t[1], r = !!t[3];
  return { stream: n, binary: r };
}
function AY(e, t, n) {
  var r;
  if (t && new Headers(t).forEach((i, u) => n.metadata.append(u, i)), typeof e != "object" || e == null || Array.isArray(e))
    throw n;
  let a = n.code;
  "code" in e && typeof e.code == "string" && (a = (r = Yfe(e.code)) !== null && r !== void 0 ? r : a);
  const o = e.message;
  if (o != null && typeof o != "string")
    throw n;
  const s = new Le(o ?? "", a, t);
  if ("details" in e && Array.isArray(e.details))
    for (const i of e.details) {
      if (i === null || typeof i != "object" || Array.isArray(i) || typeof i.type != "string" || typeof i.value != "string")
        throw n;
      try {
        s.details.push({
          type: i.type,
          value: H1(i.value),
          debug: i.debug
        });
      } catch {
        throw n;
      }
    }
  return s;
}
const Zk = 2;
function nme(e) {
  const t = new Le("invalid end stream", M.Unknown);
  let n;
  try {
    n = JSON.parse(typeof e == "string" ? e : new TextDecoder().decode(e));
  } catch {
    throw t;
  }
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw t;
  const r = new Headers();
  if ("metadata" in n) {
    if (typeof n.metadata != "object" || n.metadata == null || Array.isArray(n.metadata))
      throw t;
    for (const [o, s] of Object.entries(n.metadata)) {
      if (!Array.isArray(s) || s.some((i) => typeof i != "string"))
        throw t;
      for (const i of s)
        r.append(o, i);
    }
  }
  const a = "error" in n && n.error != null ? AY(n.error, r, t) : void 0;
  return { metadata: r, error: a };
}
const Fp = "Content-Type", rme = "Content-Length", Hk = "Content-Encoding", ame = "Accept-Encoding", ome = "Connect-Timeout-Ms", LY = "Connect-Protocol-Version", sme = "User-Agent";
function ime(e) {
  switch (e) {
    case 400:
      return M.Internal;
    case 401:
      return M.Unauthenticated;
    case 403:
      return M.PermissionDenied;
    case 404:
      return M.Unimplemented;
    case 429:
      return M.Unavailable;
    case 502:
      return M.Unavailable;
    case 503:
      return M.Unavailable;
    case 504:
      return M.Unavailable;
    default:
      return M.Unknown;
  }
}
function zk(e) {
  const t = new Headers(), n = new Headers();
  return e.forEach((r, a) => {
    a.toLowerCase().startsWith("trailer-") ? n.append(a.substring(8), r) : t.append(a, r);
  }), [t, n];
}
const FY = "1";
function qk(e, t, n, r, a) {
  const o = new Headers(r ?? {});
  return n !== void 0 && o.set(ome, `${n}`), o.set(Fp, e == "unary" ? t ? zfe : qfe : t ? Qfe : eme), o.set(LY, FY), o.has(sme), o;
}
function Qk(e, t, n, r) {
  const a = r.get(Fp), o = tme(a);
  if (n !== 200) {
    const i = new Le(`HTTP ${n}`, ime(n), r);
    if (e == "unary" && o && !o.binary)
      return { isUnaryError: !0, unaryError: i };
    throw i;
  }
  const s = {
    binary: t,
    stream: e !== "unary"
  };
  if (o?.binary !== s.binary || o.stream !== s.stream)
    throw new Le(`unsupported content type ${a}`, o === void 0 ? M.Unknown : M.Internal, r);
  return { isUnaryError: !1 };
}
const eA = "application/";
function ume(e, t) {
  return t ? tY(e, "url") : encodeURIComponent(new TextDecoder().decode(e));
}
function lme(e, t, n) {
  let r = `?connect=v${FY}`;
  const a = e.header.get(Fp);
  a?.indexOf(eA) === 0 && (r += "&encoding=" + encodeURIComponent(a.slice(eA.length)));
  const o = e.header.get(Hk);
  o !== null && o !== "identity" && (r += "&compression=" + encodeURIComponent(o), n = !0), n && (r += "&base64=1"), r += "&message=" + ume(t, n);
  const s = e.url + r, i = new Headers(e.header);
  for (const u of [
    LY,
    Fp,
    rme,
    Hk,
    ame
  ])
    i.delete(u);
  return Object.assign(Object.assign({}, e), {
    requestMethod: "GET",
    url: s,
    header: i
  });
}
function cme(e) {
  const t = DY(e.next, e.interceptors), [n, r, a] = UY(e), o = Object.assign(Object.assign({}, e.req), { message: SY(e.req.method.input, e.req.message), signal: n });
  return t(o).then((s) => (a(), s), r);
}
function fme(e) {
  const t = DY(e.next, e.interceptors), [n, r, a] = UY(e), o = Object.assign(Object.assign({}, e.req), { message: Zfe(e.req.method.input, e.req.message), signal: n });
  let s = !1;
  return n.addEventListener("abort", function() {
    var i, u;
    const l = e.req.message[Symbol.asyncIterator]();
    s || (i = l.throw) === null || i === void 0 || i.call(l, this.reason).catch(() => {
    }), (u = l.return) === null || u === void 0 || u.call(l).catch(() => {
    });
  }), t(o).then((i) => Object.assign(Object.assign({}, i), { message: {
    [Symbol.asyncIterator]() {
      const u = i.message[Symbol.asyncIterator]();
      return {
        next() {
          return u.next().then((l) => (l.done == !0 && (s = !0, a()), l), r);
        }
        // We deliberately omit throw/return.
      };
    }
  } }), r);
}
function UY(e) {
  const { signal: t, cleanup: n } = Jfe(e.timeoutMs), r = Wfe(e.signal, t);
  return [
    r.signal,
    function(a) {
      const o = Le.from(t.aborted ? OY(t) : a);
      return r.abort(o), n(), Promise.reject(o);
    },
    function() {
      n(), r.abort();
    }
  ];
}
function mme() {
  try {
    new Headers();
  } catch {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}
var cc = function(e) {
  return this instanceof cc ? (this.v = e, this) : new cc(e);
}, dme = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof cc ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
const tA = {
  redirect: "error"
};
function pme(e) {
  var t;
  mme();
  const n = (t = e.useBinaryFormat) !== null && t !== void 0 ? t : !1;
  return {
    async unary(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = Xk(r, n, e.jsonOptions, e.binaryOptions);
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await cme({
        interceptors: e.interceptors,
        signal: a,
        timeoutMs: o,
        req: {
          stream: !1,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: Kk(e.baseUrl, r),
          header: qk(r.methodKind, n, o, s),
          contextValues: u ?? Ck(),
          message: i
        },
        next: async (f) => {
          var d;
          const m = e.useHttpGet === !0 && r.idempotency === RN.NO_SIDE_EFFECTS;
          let p = null;
          m ? f = lme(f, l(f.message), n) : p = l(f.message);
          const b = await ((d = e.fetch) !== null && d !== void 0 ? d : globalThis.fetch)(f.url, Object.assign(Object.assign({}, tA), { method: f.requestMethod, headers: f.header, signal: f.signal, body: p })), { isUnaryError: g, unaryError: S } = Qk(r.methodKind, n, b.status, b.headers);
          if (g)
            throw AY(await b.json(), Bfe(...zk(b.headers)), S);
          const [D, k] = zk(b.headers);
          return {
            stream: !1,
            service: r.parent,
            method: r,
            header: D,
            message: n ? c(new Uint8Array(await b.arrayBuffer())) : vY(r.output, await b.json(), kY(e.jsonOptions)),
            trailer: k
          };
        }
      });
    },
    async stream(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = Xk(r, n, e.jsonOptions, e.binaryOptions);
      function f(m, p, b, g) {
        return dme(this, arguments, function* () {
          const S = Kfe(m).getReader();
          let D = !1;
          for (; ; ) {
            const k = yield cc(S.read());
            if (k.done)
              break;
            const { flags: U, data: R } = k.value;
            if ((U & Mk) === Mk)
              throw new Le("protocol error: received unsupported compressed output", M.Internal);
            if ((U & Zk) === Zk) {
              D = !0;
              const F = nme(R);
              if (F.error) {
                const A = F.error;
                throw b.forEach((L, re) => {
                  A.metadata.append(re, L);
                }), A;
              }
              F.metadata.forEach((A, L) => p.set(L, A));
              continue;
            }
            yield yield cc(c(R));
          }
          if ("throwIfAborted" in g && g.throwIfAborted(), !D)
            throw "missing EndStreamResponse";
        });
      }
      async function d(m) {
        if (r.methodKind != "server_streaming")
          throw "The fetch API does not support streaming request bodies";
        const p = await m[Symbol.asyncIterator]().next();
        if (p.done == !0)
          throw "missing request message";
        return Xfe(0, l(p.value));
      }
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await fme({
        interceptors: e.interceptors,
        timeoutMs: o,
        signal: a,
        req: {
          stream: !0,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: Kk(e.baseUrl, r),
          header: qk(r.methodKind, n, o, s),
          contextValues: u ?? Ck(),
          message: i
        },
        next: async (m) => {
          var p;
          const b = await ((p = e.fetch) !== null && p !== void 0 ? p : globalThis.fetch)(m.url, Object.assign(Object.assign({}, tA), { method: m.requestMethod, headers: m.header, signal: m.signal, body: await d(m.message) }));
          if (Qk(r.methodKind, n, b.status, b.headers), b.body === null)
            throw "missing response body";
          const g = new Headers();
          return Object.assign(Object.assign({}, m), { header: b.headers, trailer: g, message: f(b.body, g, b.headers, m.signal) });
        }
      });
    }
  };
}
pme({
  baseUrl: "/api",
  useBinaryFormat: !0,
  fetch: (e, t) => {
    const n = t?.headers ?? {};
    return fetch(e, {
      ...t,
      headers: {
        ...n,
        "qt-widget-id": window.qtWidgetId
      }
    });
  }
});
const Nt = /* @__PURE__ */ Symbol(), bme = !1;
var gme = Array.isArray, hme = Array.prototype.indexOf, Vh = Object.getOwnPropertyDescriptor, yme = Object.prototype, Nme = Array.prototype, Eme = Object.getPrototypeOf;
function vme(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function Tme() {
  var e, t, n = new Promise((r, a) => {
    e = r, t = a;
  });
  return { promise: n, resolve: e, reject: t };
}
const mn = 2, Ime = 4, wme = 1 << 24, Su = 16, Lf = 32, Ff = 64, oT = 128, ta = 512, Dt = 1024, Sr = 2048, na = 4096, md = 8192, ws = 16384, _me = 32768, nA = 1 << 17, RY = 1 << 18, Js = 32768, VN = 1 << 21, $Y = 1 << 22, fc = 1 << 23, xh = /* @__PURE__ */ Symbol("$state"), PY = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function Ome() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Sme() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function Dme() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function kme() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function Ame(e) {
  return e === this.v;
}
let Lme = !1;
function VY() {
  return !0;
}
let _i = [];
function Fme() {
  var e = _i;
  _i = [], vme(e);
}
function Ume(e) {
  if (_i.length === 0) {
    var t = _i;
    queueMicrotask(() => {
      t === _i && Fme();
    });
  }
  _i.push(e);
}
function Rme(e) {
  var t = zt;
  if (t === null)
    return Te.f |= fc, e;
  if ((t.f & _me) === 0) {
    if ((t.f & oT) === 0)
      throw e;
    t.b.error(e);
  } else
    xY(e, t);
}
function xY(e, t) {
  for (; t !== null; ) {
    if ((t.f & oT) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e;
}
const Fm = /* @__PURE__ */ new Set();
let qe = null, Mn = null, Yr = [], sT = null, xN = !1;
class mc {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #e = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #i = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    Yr = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const r of t)
      this.#u(r, n);
    this.is_fork || this.#c(), this.is_deferred() ? (this.#n(n.effects), this.#n(n.render_effects)) : (qe = null, rA(n.render_effects), rA(n.effects), this.#i?.resolve()), Mn = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #u(t, n) {
    t.f ^= Dt;
    for (var r = t.first; r !== null; ) {
      var a = r.f, o = (a & (Lf | Ff)) !== 0, s = o && (a & Dt) !== 0, i = s || (a & md) !== 0 || this.skipped_effects.has(r);
      if ((r.f & oT) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: []
      }), !i && r.fn !== null) {
        o ? r.f ^= Dt : (a & Ime) !== 0 ? n.effects.push(r) : Rf(r) && ((r.f & Su) !== 0 && this.#o.add(r), Vp(r));
        var u = r.first;
        if (u !== null) {
          r = u;
          continue;
        }
      }
      var l = r.parent;
      for (r = r.next; r === null && l !== null; )
        l === n.effect && (this.#n(n.effects), this.#n(n.render_effects), n = /** @type {EffectTarget} */
        n.parent), r = l.next, l = l.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #n(t) {
    for (const n of t)
      (n.f & Sr) !== 0 ? this.#o.add(n) : (n.f & na) !== 0 && this.#s.add(n), this.#l(n.deps), qt(n, Dt);
  }
  /**
   * @param {Value[] | null} deps
   */
  #l(t) {
    if (t !== null)
      for (const n of t)
        (n.f & mn) === 0 || (n.f & Js) === 0 || (n.f ^= Js, this.#l(
          /** @type {Derived} */
          n.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.previous.has(t) || this.previous.set(t, n), (t.f & fc) === 0 && (this.current.set(t, t.v), Mn?.set(t, t.v));
  }
  activate() {
    qe = this, this.apply();
  }
  deactivate() {
    qe === this && (qe = null, Mn = null);
  }
  flush() {
    if (this.activate(), Yr.length > 0) {
      if ($me(), qe !== null && qe !== this)
        return;
    } else this.#e === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const t of this.#a) t(this);
    this.#a.clear();
  }
  #c() {
    if (this.#t === 0) {
      for (const t of this.#r) t();
      this.#r.clear();
    }
    this.#e === 0 && this.#f();
  }
  #f() {
    if (Fm.size > 1) {
      this.previous.clear();
      var t = Mn, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const o of Fm) {
        if (o === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [u, l] of this.current) {
          if (o.current.has(u))
            if (n && l !== o.current.get(u))
              o.current.set(u, l);
            else
              continue;
          s.push(u);
        }
        if (s.length === 0)
          continue;
        const i = [...o.current.keys()].filter((u) => !this.current.has(u));
        if (i.length > 0) {
          var a = Yr;
          Yr = [];
          const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            YY(c, i, u, l);
          if (Yr.length > 0) {
            qe = o, o.apply();
            for (const c of Yr)
              o.#u(c, r);
            o.deactivate();
          }
          Yr = a;
        }
      }
      qe = null, Mn = t;
    }
    this.committed = !0, Fm.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(t) {
    this.#e += 1, t && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(t) {
    this.#e -= 1, t && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const t of this.#o)
      this.#s.delete(t), qt(t, Sr), dc(t);
    for (const t of this.#s)
      qt(t, na), dc(t);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(t) {
    this.#r.add(t);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(t) {
    this.#a.add(t);
  }
  settled() {
    return (this.#i ??= Tme()).promise;
  }
  static ensure() {
    if (qe === null) {
      const t = qe = new mc();
      Fm.add(qe), mc.enqueue(() => {
        qe === t && t.flush();
      });
    }
    return qe;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    Ume(t);
  }
  apply() {
  }
}
function $me() {
  var e = _s;
  xN = !0;
  try {
    var t = 0;
    for (Rp(!0); Yr.length > 0; ) {
      var n = mc.ensure();
      if (t++ > 1e3) {
        var r, a;
        Pme();
      }
      n.process(Yr), po.clear();
    }
  } finally {
    xN = !1, Rp(e), sT = null;
  }
}
function Pme() {
  try {
    Ome();
  } catch (e) {
    xY(e, sT);
  }
}
let Ta = null;
function rA(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (ws | md)) === 0 && Rf(r) && (Ta = /* @__PURE__ */ new Set(), Vp(r), r.deps === null && r.first === null && r.nodes === null && (r.teardown === null && r.ac === null ? JY(r) : r.fn = null), Ta?.size > 0)) {
        po.clear();
        for (const a of Ta) {
          if ((a.f & (ws | md)) !== 0) continue;
          const o = [a];
          let s = a.parent;
          for (; s !== null; )
            Ta.has(s) && (Ta.delete(s), o.push(s)), s = s.parent;
          for (let i = o.length - 1; i >= 0; i--) {
            const u = o[i];
            (u.f & (ws | md)) === 0 && Vp(u);
          }
        }
        Ta.clear();
      }
    }
    Ta = null;
  }
}
function YY(e, t, n, r) {
  if (!n.has(e) && (n.add(e), e.reactions !== null))
    for (const a of e.reactions) {
      const o = a.f;
      (o & mn) !== 0 ? YY(
        /** @type {Derived} */
        a,
        t,
        n,
        r
      ) : (o & ($Y | Su)) !== 0 && (o & Sr) === 0 && jY(a, t, r) && (qt(a, Sr), dc(
        /** @type {Effect} */
        a
      ));
    }
}
function jY(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (e.deps !== null)
    for (const a of e.deps) {
      if (t.includes(a))
        return !0;
      if ((a.f & mn) !== 0 && jY(
        /** @type {Derived} */
        a,
        t,
        n
      ))
        return n.set(
          /** @type {Derived} */
          a,
          !0
        ), !0;
    }
  return n.set(e, !1), !1;
}
function dc(e) {
  for (var t = sT = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (xN && t === zt && (n & Su) !== 0 && (n & RY) === 0)
      return;
    if ((n & (Ff | Lf)) !== 0) {
      if ((n & Dt) === 0) return;
      t.f ^= Dt;
    }
  }
  Yr.push(t);
}
function BY(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      uT(
        /** @type {Effect} */
        t[n]
      );
  }
}
function Vme(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & mn) === 0)
      return (t.f & ws) === 0 ? (
        /** @type {Effect} */
        t
      ) : null;
    t = t.parent;
  }
  return null;
}
function iT(e) {
  var t, n = zt;
  $p(Vme(e));
  try {
    e.f &= ~Js, BY(e), t = qY(e);
  } finally {
    $p(n);
  }
  return t;
}
function GY(e) {
  var t = iT(e);
  if (e.equals(t) || (qe?.is_fork || (e.v = t), e.wv = HY()), !Uf)
    if (Mn !== null)
      (Up() || qe?.is_fork) && Mn.set(e, t);
    else {
      var n = (e.f & ta) === 0 ? na : Dt;
      qt(e, n);
    }
}
let YN = /* @__PURE__ */ new Set();
const po = /* @__PURE__ */ new Map();
let MY = !1;
function xme(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: Ame,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function to(e, t) {
  const n = xme(e);
  return Kme(n), n;
}
function Mo(e, t, n = !1) {
  Te !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!ts || (Te.f & nA) !== 0) && VY() && (Te.f & (mn | Su | $Y | nA)) !== 0 && !Ca?.includes(e) && kme();
  let r = n ? Oi(t) : t;
  return Yme(e, r);
}
function Yme(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    Uf ? po.set(e, t) : po.set(e, n), e.v = t;
    var r = mc.ensure();
    r.capture(e, n), (e.f & mn) !== 0 && ((e.f & Sr) !== 0 && iT(
      /** @type {Derived} */
      e
    ), qt(e, (e.f & ta) !== 0 ? Dt : na)), e.wv = HY(), CY(e, Sr), zt !== null && (zt.f & Dt) !== 0 && (zt.f & (Lf | Ff)) === 0 && (Un === null ? Xme([e]) : Un.push(e)), !r.is_fork && YN.size > 0 && !MY && jme();
  }
  return t;
}
function jme() {
  MY = !1;
  var e = _s;
  Rp(!0);
  const t = Array.from(YN);
  try {
    for (const n of t)
      (n.f & Dt) !== 0 && qt(n, na), Rf(n) && Vp(n);
  } finally {
    Rp(e);
  }
  YN.clear();
}
function Yh(e) {
  Mo(e, e.v + 1);
}
function CY(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, a = 0; a < r; a++) {
      var o = n[a], s = o.f, i = (s & Sr) === 0;
      if (i && qt(o, t), (s & mn) !== 0) {
        var u = (
          /** @type {Derived} */
          o
        );
        Mn?.delete(u), (s & Js) === 0 && (s & ta && (o.f |= Js), CY(u, na));
      } else i && ((s & Su) !== 0 && Ta !== null && Ta.add(
        /** @type {Effect} */
        o
      ), dc(
        /** @type {Effect} */
        o
      ));
    }
}
function Oi(e) {
  if (typeof e != "object" || e === null || xh in e)
    return e;
  const t = Eme(e);
  if (t !== yme && t !== Nme)
    return e;
  var n = /* @__PURE__ */ new Map(), r = gme(e), a = /* @__PURE__ */ to(0), o = Os, s = (i) => {
    if (Os === o)
      return i();
    var u = Te, l = Os;
    fu(null), oA(o);
    var c = i();
    return fu(u), oA(l), c;
  };
  return r && n.set("length", /* @__PURE__ */ to(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(i, u, l) {
        (!("value" in l) || l.configurable === !1 || l.enumerable === !1 || l.writable === !1) && Sme();
        var c = n.get(u);
        return c === void 0 ? c = s(() => {
          var f = /* @__PURE__ */ to(l.value);
          return n.set(u, f), f;
        }) : Mo(c, l.value, !0), !0;
      },
      deleteProperty(i, u) {
        var l = n.get(u);
        if (l === void 0) {
          if (u in i) {
            const c = s(() => /* @__PURE__ */ to(Nt));
            n.set(u, c), Yh(a);
          }
        } else
          Mo(l, Nt), Yh(a);
        return !0;
      },
      get(i, u, l) {
        if (u === xh)
          return e;
        var c = n.get(u), f = u in i;
        if (c === void 0 && (!f || Vh(i, u)?.writable) && (c = s(() => {
          var m = Oi(f ? i[u] : Nt), p = /* @__PURE__ */ to(m);
          return p;
        }), n.set(u, c)), c !== void 0) {
          var d = Um(c);
          return d === Nt ? void 0 : d;
        }
        return Reflect.get(i, u, l);
      },
      getOwnPropertyDescriptor(i, u) {
        var l = Reflect.getOwnPropertyDescriptor(i, u);
        if (l && "value" in l) {
          var c = n.get(u);
          c && (l.value = Um(c));
        } else if (l === void 0) {
          var f = n.get(u), d = f?.v;
          if (f !== void 0 && d !== Nt)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return l;
      },
      has(i, u) {
        if (u === xh)
          return !0;
        var l = n.get(u), c = l !== void 0 && l.v !== Nt || Reflect.has(i, u);
        if (l !== void 0 || zt !== null && (!c || Vh(i, u)?.writable)) {
          l === void 0 && (l = s(() => {
            var d = c ? Oi(i[u]) : Nt, m = /* @__PURE__ */ to(d);
            return m;
          }), n.set(u, l));
          var f = Um(l);
          if (f === Nt)
            return !1;
        }
        return c;
      },
      set(i, u, l, c) {
        var f = n.get(u), d = u in i;
        if (r && u === "length")
          for (var m = l; m < /** @type {Source<number>} */
          f.v; m += 1) {
            var p = n.get(m + "");
            p !== void 0 ? Mo(p, Nt) : m in i && (p = s(() => /* @__PURE__ */ to(Nt)), n.set(m + "", p));
          }
        if (f === void 0)
          (!d || Vh(i, u)?.writable) && (f = s(() => /* @__PURE__ */ to(void 0)), Mo(f, Oi(l)), n.set(u, f));
        else {
          d = f.v !== Nt;
          var b = s(() => Oi(l));
          Mo(f, b);
        }
        var g = Reflect.getOwnPropertyDescriptor(i, u);
        if (g?.set && g.set.call(c, l), !d) {
          if (r && typeof u == "string") {
            var S = (
              /** @type {Source<number>} */
              n.get("length")
            ), D = Number(u);
            Number.isInteger(D) && D >= S.v && Mo(S, D + 1);
          }
          Yh(a);
        }
        return !0;
      },
      ownKeys(i) {
        Um(a);
        var u = Reflect.ownKeys(i).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== Nt;
        });
        for (var [l, c] of n)
          c.v !== Nt && !(l in i) && u.push(l);
        return u;
      },
      setPrototypeOf() {
        Dme();
      }
    }
  );
}
var Bme;
// @__NO_SIDE_EFFECTS__
function Gme(e) {
  return (
    /** @type {TemplateNode | null} */
    Bme.call(e)
  );
}
function KY(e) {
  var t = Te, n = zt;
  fu(null), $p(null);
  try {
    return e();
  } finally {
    fu(t), $p(n);
  }
}
function Up() {
  return Te !== null && !ts;
}
function XY(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = Uf, r = Te;
    aA(!0), fu(null);
    try {
      t.call(null);
    } finally {
      aA(n), fu(r);
    }
  }
}
function WY(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const a = n.ac;
    a !== null && KY(() => {
      a.abort(PY);
    });
    var r = n.next;
    (n.f & Ff) !== 0 ? n.parent = null : uT(n, t), n = r;
  }
}
function Mme(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & Lf) === 0 && uT(t), t = n;
  }
}
function uT(e, t = !0) {
  var n = !1;
  (t || (e.f & RY) !== 0) && e.nodes !== null && e.nodes.end !== null && (Cme(
    e.nodes.start,
    /** @type {TemplateNode} */
    e.nodes.end
  ), n = !0), WY(e, t && !n), Pp(e, 0), qt(e, ws);
  var r = e.nodes && e.nodes.t;
  if (r !== null)
    for (const o of r)
      o.stop();
  XY(e);
  var a = e.parent;
  a !== null && a.first !== null && JY(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes = e.ac = null;
}
function Cme(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : /* @__PURE__ */ Gme(e);
    e.remove(), e = n;
  }
}
function JY(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
let _s = !1;
function Rp(e) {
  _s = e;
}
let Uf = !1;
function aA(e) {
  Uf = e;
}
let Te = null, ts = !1;
function fu(e) {
  Te = e;
}
let zt = null;
function $p(e) {
  zt = e;
}
let Ca = null;
function Kme(e) {
  Te !== null && (Ca === null ? Ca = [e] : Ca.push(e));
}
let ut = null, Tn = 0, Un = null;
function Xme(e) {
  Un = e;
}
let ZY = 1, pc = 0, Os = pc;
function oA(e) {
  Os = e;
}
function HY() {
  return ++ZY;
}
function Rf(e) {
  var t = e.f;
  if ((t & Sr) !== 0)
    return !0;
  if (t & mn && (e.f &= ~Js), (t & na) !== 0) {
    var n = e.deps;
    if (n !== null)
      for (var r = n.length, a = 0; a < r; a++) {
        var o = n[a];
        if (Rf(
          /** @type {Derived} */
          o
        ) && GY(
          /** @type {Derived} */
          o
        ), o.wv > e.wv)
          return !0;
      }
    (t & ta) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Mn === null && qt(e, Dt);
  }
  return !1;
}
function zY(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !Ca?.includes(e))
    for (var a = 0; a < r.length; a++) {
      var o = r[a];
      (o.f & mn) !== 0 ? zY(
        /** @type {Derived} */
        o,
        t,
        !1
      ) : t === o && (n ? qt(o, Sr) : (o.f & Dt) !== 0 && qt(o, na), dc(
        /** @type {Effect} */
        o
      ));
    }
}
function qY(e) {
  var t = ut, n = Tn, r = Un, a = Te, o = Ca, s = ts, i = Os, u = e.f;
  ut = /** @type {null | Value[]} */
  null, Tn = 0, Un = null, Te = (u & (Lf | Ff)) === 0 ? e : null, Ca = null, e.ctx, ts = !1, Os = ++pc, e.ac !== null && (KY(() => {
    e.ac.abort(PY);
  }), e.ac = null);
  try {
    e.f |= VN;
    var l = (
      /** @type {Function} */
      e.fn
    ), c = l(), f = e.deps;
    if (ut !== null) {
      var d;
      if (Pp(e, Tn), f !== null && Tn > 0)
        for (f.length = Tn + ut.length, d = 0; d < ut.length; d++)
          f[Tn + d] = ut[d];
      else
        e.deps = f = ut;
      if (Up() && (e.f & ta) !== 0)
        for (d = Tn; d < f.length; d++)
          (f[d].reactions ??= []).push(e);
    } else f !== null && Tn < f.length && (Pp(e, Tn), f.length = Tn);
    if (VY() && Un !== null && !ts && f !== null && (e.f & (mn | na | Sr)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      Un.length; d++)
        zY(
          Un[d],
          /** @type {Effect} */
          e
        );
    return a !== null && a !== e && (pc++, Un !== null && (r === null ? r = Un : r.push(.../** @type {Source[]} */
    Un))), (e.f & fc) !== 0 && (e.f ^= fc), c;
  } catch (m) {
    return Rme(m);
  } finally {
    e.f ^= VN, ut = t, Tn = n, Un = r, Te = a, Ca = o, ts = s, Os = i;
  }
}
function Wme(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = hme.call(n, e);
    if (r !== -1) {
      var a = n.length - 1;
      a === 0 ? n = t.reactions = null : (n[r] = n[a], n.pop());
    }
  }
  n === null && (t.f & mn) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (ut === null || !ut.includes(t)) && (qt(t, na), (t.f & ta) !== 0 && (t.f ^= ta, t.f &= ~Js), BY(
    /** @type {Derived} **/
    t
  ), Pp(
    /** @type {Derived} **/
    t,
    0
  ));
}
function Pp(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      Wme(e, n[r]);
}
function Vp(e) {
  var t = e.f;
  if ((t & ws) === 0) {
    qt(e, Dt);
    var n = zt, r = _s;
    zt = e, _s = !0;
    try {
      (t & (Su | wme)) !== 0 ? Mme(e) : WY(e), XY(e);
      var a = qY(e);
      e.teardown = typeof a == "function" ? a : null, e.wv = ZY;
      var o;
      bme && Lme && (e.f & Sr) !== 0 && e.deps;
    } finally {
      _s = r, zt = n;
    }
  }
}
function Um(e) {
  var t = e.f, n = (t & mn) !== 0;
  if (Te !== null && !ts) {
    var r = zt !== null && (zt.f & ws) !== 0;
    if (!r && !Ca?.includes(e)) {
      var a = Te.deps;
      if ((Te.f & VN) !== 0)
        e.rv < pc && (e.rv = pc, ut === null && a !== null && a[Tn] === e ? Tn++ : ut === null ? ut = [e] : ut.includes(e) || ut.push(e));
      else {
        (Te.deps ??= []).push(e);
        var o = e.reactions;
        o === null ? e.reactions = [Te] : o.includes(Te) || o.push(Te);
      }
    }
  }
  if (Uf) {
    if (po.has(e))
      return po.get(e);
    if (n) {
      var s = (
        /** @type {Derived} */
        e
      ), i = s.v;
      return ((s.f & Dt) === 0 && s.reactions !== null || ej(s)) && (i = iT(s)), po.set(s, i), i;
    }
  } else n && (!Mn?.has(e) || qe?.is_fork && !Up()) && (s = /** @type {Derived} */
  e, Rf(s) && GY(s), _s && Up() && (s.f & ta) === 0 && QY(s));
  if (Mn?.has(e))
    return Mn.get(e);
  if ((e.f & fc) !== 0)
    throw e.v;
  return e.v;
}
function QY(e) {
  if (e.deps !== null) {
    e.f ^= ta;
    for (const t of e.deps)
      (t.reactions ??= []).push(e), (t.f & mn) !== 0 && (t.f & ta) === 0 && QY(
        /** @type {Derived} */
        t
      );
  }
}
function ej(e) {
  if (e.v === Nt) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (po.has(t) || (t.f & mn) !== 0 && ej(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
const Jme = -7169;
function qt(e, t) {
  e.f = e.f & Jme | t;
}
function tj() {
  return {
    isDark: document.documentElement.classList.contains("night-mode")
  };
}
const Zme = Oi(tj()), Hme = new MutationObserver((e, t) => {
  Zme.isDark = tj().isDark;
});
Hme.observe(document.documentElement, { attributeFilter: ["class"] });
const zme = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(zme);
var C;
(function(e) {
  e[e.Canceled = 1] = "Canceled", e[e.Unknown = 2] = "Unknown", e[e.InvalidArgument = 3] = "InvalidArgument", e[e.DeadlineExceeded = 4] = "DeadlineExceeded", e[e.NotFound = 5] = "NotFound", e[e.AlreadyExists = 6] = "AlreadyExists", e[e.PermissionDenied = 7] = "PermissionDenied", e[e.ResourceExhausted = 8] = "ResourceExhausted", e[e.FailedPrecondition = 9] = "FailedPrecondition", e[e.Aborted = 10] = "Aborted", e[e.OutOfRange = 11] = "OutOfRange", e[e.Unimplemented = 12] = "Unimplemented", e[e.Internal = 13] = "Internal", e[e.Unavailable = 14] = "Unavailable", e[e.DataLoss = 15] = "DataLoss", e[e.Unauthenticated = 16] = "Unauthenticated";
})(C || (C = {}));
function lT(e, t) {
  return e !== null && typeof e == "object" && "$typeName" in e && typeof e.$typeName == "string" ? t === void 0 ? !0 : t.typeName === e.$typeName : !1;
}
var _;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(_ || (_ = {}));
function qme() {
  let e = 0, t = 0;
  for (let r = 0; r < 28; r += 7) {
    let a = this.buf[this.pos++];
    if (e |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  let n = this.buf[this.pos++];
  if (e |= (n & 15) << 28, t = (n & 112) >> 4, (n & 128) == 0)
    return this.assertBounds(), [e, t];
  for (let r = 3; r <= 31; r += 7) {
    let a = this.buf[this.pos++];
    if (t |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  throw new Error("invalid varint");
}
function jh(e, t, n) {
  for (let o = 0; o < 28; o = o + 7) {
    const s = e >>> o, i = !(!(s >>> 7) && t == 0), u = (i ? s | 128 : s) & 255;
    if (n.push(u), !i)
      return;
  }
  const r = e >>> 28 & 15 | (t & 7) << 4, a = t >> 3 != 0;
  if (n.push((a ? r | 128 : r) & 255), !!a) {
    for (let o = 3; o < 31; o = o + 7) {
      const s = t >>> o, i = !!(s >>> 7), u = (i ? s | 128 : s) & 255;
      if (n.push(u), !i)
        return;
    }
    n.push(t >>> 31 & 1);
  }
}
const dd = 4294967296;
function sA(e) {
  const t = e[0] === "-";
  t && (e = e.slice(1));
  const n = 1e6;
  let r = 0, a = 0;
  function o(s, i) {
    const u = Number(e.slice(s, i));
    a *= n, r = r * n + u, r >= dd && (a = a + (r / dd | 0), r = r % dd);
  }
  return o(-24, -18), o(-18, -12), o(-12, -6), o(-6), t ? rj(r, a) : cT(r, a);
}
function Qme(e, t) {
  let n = cT(e, t);
  const r = n.hi & 2147483648;
  r && (n = rj(n.lo, n.hi));
  const a = nj(n.lo, n.hi);
  return r ? "-" + a : a;
}
function nj(e, t) {
  if ({ lo: e, hi: t } = ede(e, t), t <= 2097151)
    return String(dd * t + e);
  const n = e & 16777215, r = (e >>> 24 | t << 8) & 16777215, a = t >> 16 & 65535;
  let o = n + r * 6777216 + a * 6710656, s = r + a * 8147497, i = a * 2;
  const u = 1e7;
  return o >= u && (s += Math.floor(o / u), o %= u), s >= u && (i += Math.floor(s / u), s %= u), i.toString() + iA(s) + iA(o);
}
function ede(e, t) {
  return { lo: e >>> 0, hi: t >>> 0 };
}
function cT(e, t) {
  return { lo: e | 0, hi: t | 0 };
}
function rj(e, t) {
  return t = ~t, e ? e = ~e + 1 : t += 1, cT(e, t);
}
const iA = (e) => {
  const t = String(e);
  return "0000000".slice(t.length) + t;
};
function jN(e, t) {
  if (e >= 0) {
    for (; e > 127; )
      t.push(e & 127 | 128), e = e >>> 7;
    t.push(e);
  } else {
    for (let n = 0; n < 9; n++)
      t.push(e & 127 | 128), e = e >> 7;
    t.push(1);
  }
}
function tde() {
  let e = this.buf[this.pos++], t = e & 127;
  if ((e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 7, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 14, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 21, (e & 128) == 0)
    return this.assertBounds(), t;
  e = this.buf[this.pos++], t |= (e & 15) << 28;
  for (let n = 5; (e & 128) !== 0 && n < 10; n++)
    e = this.buf[this.pos++];
  if ((e & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
const ee = /* @__PURE__ */ nde();
function nde() {
  const e = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof e.getBigInt64 == "function" && typeof e.getBigUint64 == "function" && typeof e.setBigInt64 == "function" && typeof e.setBigUint64 == "function" && (globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const t = BigInt("-9223372036854775808"), n = BigInt("9223372036854775807"), r = BigInt("0"), a = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > n || s < t)
          throw new Error(`invalid int64: ${o}`);
        return s;
      },
      uParse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > a || s < r)
          throw new Error(`invalid uint64: ${o}`);
        return s;
      },
      enc(o) {
        return e.setBigInt64(0, this.parse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      uEnc(o) {
        return e.setBigInt64(0, this.uParse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      dec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigInt64(0, !0);
      },
      uDec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigUint64(0, !0);
      }
    };
  }
  return {
    zero: "0",
    supported: !1,
    parse(t) {
      return typeof t != "string" && (t = t.toString()), uA(t), t;
    },
    uParse(t) {
      return typeof t != "string" && (t = t.toString()), lA(t), t;
    },
    enc(t) {
      return typeof t != "string" && (t = t.toString()), uA(t), sA(t);
    },
    uEnc(t) {
      return typeof t != "string" && (t = t.toString()), lA(t), sA(t);
    },
    dec(t, n) {
      return Qme(t, n);
    },
    uDec(t, n) {
      return nj(t, n);
    }
  };
}
function uA(e) {
  if (!/^-?[0-9]+$/.test(e))
    throw new Error("invalid int64: " + e);
}
function lA(e) {
  if (!/^[0-9]+$/.test(e))
    throw new Error("invalid uint64: " + e);
}
function Zs(e, t) {
  switch (e) {
    case _.STRING:
      return "";
    case _.BOOL:
      return !1;
    case _.DOUBLE:
    case _.FLOAT:
      return 0;
    case _.INT64:
    case _.UINT64:
    case _.SFIXED64:
    case _.FIXED64:
    case _.SINT64:
      return t ? "0" : ee.zero;
    case _.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function rde(e, t) {
  switch (e) {
    case _.BOOL:
      return t === !1;
    case _.STRING:
      return t === "";
    case _.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
const aj = 2, $a = /* @__PURE__ */ Symbol.for("reflect unsafe local");
function oj(e, t) {
  const n = e[t.localName].case;
  return n === void 0 ? n : t.fields.find((r) => r.localName === n);
}
function ade(e, t) {
  const n = t.localName;
  if (t.oneof)
    return e[t.oneof.localName].case === n;
  if (t.presence != aj)
    return e[n] !== void 0 && Object.prototype.hasOwnProperty.call(e, n);
  switch (t.fieldKind) {
    case "list":
      return e[n].length > 0;
    case "map":
      return Object.keys(e[n]).length > 0;
    case "scalar":
      return !rde(t.scalar, e[n]);
    case "enum":
      return e[n] !== t.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function bc(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) && e[t] !== void 0;
}
function sj(e, t) {
  if (t.oneof) {
    const n = e[t.oneof.localName];
    return n.case === t.localName ? n.value : void 0;
  }
  return e[t.localName];
}
function ij(e, t, n) {
  t.oneof ? e[t.oneof.localName] = {
    case: t.localName,
    value: n
  } : e[t.localName] = n;
}
function ode(e, t) {
  const n = t.localName;
  if (t.oneof) {
    const r = t.oneof.localName;
    e[r].case === n && (e[r] = { case: void 0 });
  } else if (t.presence != aj)
    delete e[n];
  else
    switch (t.fieldKind) {
      case "map":
        e[n] = {};
        break;
      case "list":
        e[n] = [];
        break;
      case "enum":
        e[n] = t.enum.values[0].number;
        break;
      case "scalar":
        e[n] = Zs(t.scalar, t.longAsString);
        break;
    }
}
function Oo(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function fT(e, t) {
  var n, r, a, o;
  if (Oo(e) && $a in e && "add" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.listKind == i.listKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function mT(e, t) {
  var n, r, a, o;
  if (Oo(e) && $a in e && "has" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.mapKey === i.mapKey && s.mapKind == i.mapKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function dT(e, t) {
  return Oo(e) && $a in e && "desc" in e && Oo(e.desc) && e.desc.kind === "message" && (t === void 0 || e.desc.typeName == t.typeName);
}
function sde(e) {
  return uj(e.$typeName);
}
function $f(e) {
  const t = e.fields[0];
  return uj(e.typeName) && t !== void 0 && t.fieldKind == "scalar" && t.name == "value" && t.number == 1;
}
function uj(e) {
  return e.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(e.substring(16));
}
const ide = 999, ude = 998, pd = 2;
function Dr(e, t) {
  if (lT(t, e))
    return t;
  const n = dde(e);
  return t !== void 0 && lde(e, n, t), n;
}
function lde(e, t, n) {
  for (const r of e.members) {
    let a = n[r.localName];
    if (a == null)
      continue;
    let o;
    if (r.kind == "oneof") {
      const s = oj(n, r);
      if (!s)
        continue;
      o = s, a = sj(n, s);
    } else
      o = r;
    switch (o.fieldKind) {
      case "message":
        a = pT(o, a);
        break;
      case "scalar":
        a = lj(o, a);
        break;
      case "list":
        a = fde(o, a);
        break;
      case "map":
        a = cde(o, a);
        break;
    }
    ij(t, o, a);
  }
  return t;
}
function lj(e, t) {
  return e.scalar == _.BYTES ? bT(t) : t;
}
function cde(e, t) {
  if (Oo(t)) {
    if (e.scalar == _.BYTES)
      return cA(t, bT);
    if (e.mapKind == "message")
      return cA(t, (n) => pT(e, n));
  }
  return t;
}
function fde(e, t) {
  if (Array.isArray(t)) {
    if (e.scalar == _.BYTES)
      return t.map(bT);
    if (e.listKind == "message")
      return t.map((n) => pT(e, n));
  }
  return t;
}
function pT(e, t) {
  if (e.fieldKind == "message" && !e.oneof && $f(e.message))
    return lj(e.message.fields[0], t);
  if (Oo(t)) {
    if (e.message.typeName == "google.protobuf.Struct" && e.parent.typeName !== "google.protobuf.Value")
      return t;
    if (!lT(t, e.message))
      return Dr(e.message, t);
  }
  return t;
}
function bT(e) {
  return Array.isArray(e) ? new Uint8Array(e) : e;
}
function cA(e, t) {
  const n = {};
  for (const r of Object.entries(e))
    n[r[0]] = t(r[1]);
  return n;
}
const mde = /* @__PURE__ */ Symbol(), fA = /* @__PURE__ */ new WeakMap();
function dde(e) {
  let t;
  if (pde(e)) {
    const n = fA.get(e);
    let r, a;
    if (n)
      ({ prototype: r, members: a } = n);
    else {
      r = {}, a = /* @__PURE__ */ new Set();
      for (const o of e.members)
        o.kind != "oneof" && (o.fieldKind != "scalar" && o.fieldKind != "enum" || o.presence != pd && (a.add(o), r[o.localName] = Bh(o)));
      fA.set(e, { prototype: r, members: a });
    }
    t = Object.create(r), t.$typeName = e.typeName;
    for (const o of e.members)
      a.has(o) || o.kind == "field" && (o.fieldKind == "message" || (o.fieldKind == "scalar" || o.fieldKind == "enum") && o.presence != pd) || (t[o.localName] = Bh(o));
  } else {
    t = {
      $typeName: e.typeName
    };
    for (const n of e.members)
      (n.kind == "oneof" || n.presence == pd) && (t[n.localName] = Bh(n));
  }
  return t;
}
function pde(e) {
  switch (e.file.edition) {
    case ide:
      return !1;
    case ude:
      return !0;
    default:
      return e.fields.some((t) => t.presence != pd && t.fieldKind != "message" && !t.oneof);
  }
}
function Bh(e) {
  if (e.kind == "oneof")
    return { case: void 0 };
  if (e.fieldKind == "list")
    return [];
  if (e.fieldKind == "map")
    return {};
  if (e.fieldKind == "message")
    return mde;
  const t = e.getDefaultValue();
  return t !== void 0 ? e.fieldKind == "scalar" && e.longAsString ? t.toString() : t : e.fieldKind == "scalar" ? Zs(e.scalar, e.longAsString) : e.enum.values[0].number;
}
const bde = [
  "FieldValueInvalidError",
  "FieldListRangeError",
  "ForeignFieldError"
];
class Qt extends Error {
  constructor(t, n, r = "FieldValueInvalidError") {
    super(n), this.name = r, this.field = () => t;
  }
}
function gde(e) {
  return e instanceof Error && bde.includes(e.name) && "field" in e && typeof e.field == "function";
}
const Gh = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
function gT() {
  if (globalThis[Gh] == null) {
    const e = new globalThis.TextEncoder(), t = new globalThis.TextDecoder();
    globalThis[Gh] = {
      encodeUtf8(n) {
        return e.encode(n);
      },
      decodeUtf8(n) {
        return t.decode(n);
      },
      checkUtf8(n) {
        try {
          return encodeURIComponent(n), !0;
        } catch {
          return !1;
        }
      }
    };
  }
  return globalThis[Gh];
}
var me;
(function(e) {
  e[e.Varint = 0] = "Varint", e[e.Bit64 = 1] = "Bit64", e[e.LengthDelimited = 2] = "LengthDelimited", e[e.StartGroup = 3] = "StartGroup", e[e.EndGroup = 4] = "EndGroup", e[e.Bit32 = 5] = "Bit32";
})(me || (me = {}));
const cj = 34028234663852886e22, fj = -34028234663852886e22, mj = 4294967295, dj = 2147483647, pj = -2147483648;
class bj {
  constructor(t = gT().encodeUtf8) {
    this.encodeUtf8 = t, this.stack = [], this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []);
    let t = 0;
    for (let a = 0; a < this.chunks.length; a++)
      t += this.chunks[a].length;
    let n = new Uint8Array(t), r = 0;
    for (let a = 0; a < this.chunks.length; a++)
      n.set(this.chunks[a], r), r += this.chunks[a].length;
    return this.chunks = [], n;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), n = this.stack.pop();
    if (!n)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = n.chunks, this.buf = n.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, n) {
    return this.uint32((t << 3 | n) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (mA(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return Mh(t), jN(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let n = this.encodeUtf8(t);
    return this.uint32(n.byteLength), this.raw(n);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    hde(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setFloat32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let n = new Uint8Array(8);
    return new DataView(n.buffer).setFloat64(0, t, !0), this.raw(n);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    mA(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    Mh(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setInt32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return Mh(t), t = (t << 1 ^ t >> 31) >>> 0, jN(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = ee.enc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = ee.uEnc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let n = ee.enc(t);
    return jh(n.lo, n.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    const n = ee.enc(t), r = n.hi >> 31, a = n.lo << 1 ^ r, o = (n.hi << 1 | n.lo >>> 31) ^ r;
    return jh(a, o, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    const n = ee.uEnc(t);
    return jh(n.lo, n.hi, this.buf), this;
  }
}
class hT {
  constructor(t, n = gT().decodeUtf8) {
    this.decodeUtf8 = n, this.varint64 = qme, this.uint32 = tde, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), n = t >>> 3, r = t & 7;
    if (n <= 0 || r < 0 || r > 5)
      throw new Error("illegal tag: field no " + n + " wire type " + r);
    return [n, r];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, n) {
    let r = this.pos;
    switch (t) {
      case me.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case me.Bit64:
        this.pos += 4;
      case me.Bit32:
        this.pos += 4;
        break;
      case me.LengthDelimited:
        let a = this.uint32();
        this.pos += a;
        break;
      case me.StartGroup:
        for (; ; ) {
          const [o, s] = this.tag();
          if (s === me.EndGroup) {
            if (n !== void 0 && o !== n)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(s, o);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return ee.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return ee.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, n] = this.varint64(), r = -(t & 1);
    return t = (t >>> 1 | (n & 1) << 31) ^ r, n = n >>> 1 ^ r, ee.dec(t, n);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, n] = this.varint64();
    return t !== 0 || n !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return ee.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return ee.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), n = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(n, n + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function Mh(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid int32: " + typeof e);
  if (!Number.isInteger(e) || e > dj || e < pj)
    throw new Error("invalid int32: " + e);
}
function mA(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid uint32: " + typeof e);
  if (!Number.isInteger(e) || e > mj || e < 0)
    throw new Error("invalid uint32: " + e);
}
function hde(e) {
  if (typeof e == "string") {
    const t = e;
    if (e = Number(e), Number.isNaN(e) && t !== "NaN")
      throw new Error("invalid float32: " + t);
  } else if (typeof e != "number")
    throw new Error("invalid float32: " + typeof e);
  if (Number.isFinite(e) && (e > cj || e < fj))
    throw new Error("invalid float32: " + e);
}
function Co(e, t) {
  const n = e.fieldKind == "list" ? fT(t, e) : e.fieldKind == "map" ? mT(t, e) : yT(e, t);
  if (n === !0)
    return;
  let r;
  switch (e.fieldKind) {
    case "list":
      r = `expected ${yj(e)}, got ${Ge(t)}`;
      break;
    case "map":
      r = `expected ${Nj(e)}, got ${Ge(t)}`;
      break;
    default:
      r = xp(e, t, n);
  }
  return new Qt(e, r);
}
function dA(e, t, n) {
  const r = yT(e, n);
  if (r !== !0)
    return new Qt(e, `list item #${t + 1}: ${xp(e, n, r)}`);
}
function yde(e, t, n) {
  const r = gj(t, e.mapKey);
  if (r !== !0)
    return new Qt(e, `invalid map key: ${xp({ scalar: e.mapKey }, t, r)}`);
  const a = yT(e, n);
  if (a !== !0)
    return new Qt(e, `map entry ${Ge(t)}: ${xp(e, n, a)}`);
}
function yT(e, t) {
  return e.scalar !== void 0 ? gj(t, e.scalar) : e.enum !== void 0 ? e.enum.open ? Number.isInteger(t) : e.enum.values.some((n) => n.number === t) : dT(t, e.message);
}
function gj(e, t) {
  switch (t) {
    case _.DOUBLE:
      return typeof e == "number";
    case _.FLOAT:
      return typeof e != "number" ? !1 : Number.isNaN(e) || !Number.isFinite(e) ? !0 : e > cj || e < fj ? `${e.toFixed()} out of range` : !0;
    case _.INT32:
    case _.SFIXED32:
    case _.SINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > dj || e < pj ? `${e.toFixed()} out of range` : !0;
    case _.FIXED32:
    case _.UINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > mj || e < 0 ? `${e.toFixed()} out of range` : !0;
    case _.BOOL:
      return typeof e == "boolean";
    case _.STRING:
      return typeof e != "string" ? !1 : gT().checkUtf8(e) || "invalid UTF8";
    case _.BYTES:
      return e instanceof Uint8Array;
    case _.INT64:
    case _.SFIXED64:
    case _.SINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return ee.parse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
    case _.FIXED64:
    case _.UINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return ee.uParse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
  }
}
function xp(e, t, n) {
  return n = typeof n == "string" ? `: ${n}` : `, got ${Ge(t)}`, e.scalar !== void 0 ? `expected ${Nde(e.scalar)}` + n : e.enum !== void 0 ? `expected ${e.enum.toString()}` + n : `expected ${hj(e.message)}` + n;
}
function Ge(e) {
  switch (typeof e) {
    case "object":
      return e === null ? "null" : e instanceof Uint8Array ? `Uint8Array(${e.length})` : Array.isArray(e) ? `Array(${e.length})` : fT(e) ? yj(e.field()) : mT(e) ? Nj(e.field()) : dT(e) ? hj(e.desc) : lT(e) ? `message ${e.$typeName}` : "object";
    case "string":
      return e.length > 30 ? "string" : `"${e.split('"').join('\\"')}"`;
    case "boolean":
      return String(e);
    case "number":
      return String(e);
    case "bigint":
      return String(e) + "n";
    default:
      return typeof e;
  }
}
function hj(e) {
  return `ReflectMessage (${e.typeName})`;
}
function yj(e) {
  switch (e.listKind) {
    case "message":
      return `ReflectList (${e.message.toString()})`;
    case "enum":
      return `ReflectList (${e.enum.toString()})`;
    case "scalar":
      return `ReflectList (${_[e.scalar]})`;
  }
}
function Nj(e) {
  switch (e.mapKind) {
    case "message":
      return `ReflectMap (${_[e.mapKey]}, ${e.message.toString()})`;
    case "enum":
      return `ReflectMap (${_[e.mapKey]}, ${e.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${_[e.mapKey]}, ${_[e.scalar]})`;
  }
}
function Nde(e) {
  switch (e) {
    case _.STRING:
      return "string";
    case _.BOOL:
      return "boolean";
    case _.INT64:
    case _.SINT64:
    case _.SFIXED64:
      return "bigint (int64)";
    case _.UINT64:
    case _.FIXED64:
      return "bigint (uint64)";
    case _.BYTES:
      return "Uint8Array";
    case _.DOUBLE:
      return "number (float64)";
    case _.FLOAT:
      return "number (float32)";
    case _.FIXED32:
    case _.UINT32:
      return "number (uint32)";
    case _.INT32:
    case _.SFIXED32:
    case _.SINT32:
      return "number (int32)";
  }
}
function er(e, t, n = !0) {
  return new Ej(e, t, n);
}
const pA = /* @__PURE__ */ new WeakMap();
class Ej {
  get sortedFields() {
    const t = pA.get(this.desc);
    if (t)
      return t;
    const n = this.desc.fields.concat().sort((r, a) => r.number - a.number);
    return pA.set(this.desc, n), n;
  }
  constructor(t, n, r = !0) {
    this.lists = /* @__PURE__ */ new Map(), this.maps = /* @__PURE__ */ new Map(), this.check = r, this.desc = t, this.message = this[$a] = n ?? Dr(t), this.fields = t.fields, this.oneofs = t.oneofs, this.members = t.members;
  }
  findNumber(t) {
    return this._fieldsByNumber || (this._fieldsByNumber = new Map(this.desc.fields.map((n) => [n.number, n]))), this._fieldsByNumber.get(t);
  }
  oneofCase(t) {
    return xu(this.message, t), oj(this.message, t);
  }
  isSet(t) {
    return xu(this.message, t), ade(this.message, t);
  }
  clear(t) {
    xu(this.message, t), ode(this.message, t);
  }
  get(t) {
    xu(this.message, t);
    const n = sj(this.message, t);
    switch (t.fieldKind) {
      case "list":
        let r = this.lists.get(t);
        return (!r || r[$a] !== n) && this.lists.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          r = new Ede(t, n, this.check)
        ), r;
      case "map":
        let a = this.maps.get(t);
        return (!a || a[$a] !== n) && this.maps.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = new vde(t, n, this.check)
        ), a;
      case "message":
        return ET(t, n, this.check);
      case "scalar":
        return n === void 0 ? Zs(t.scalar, !1) : vT(t, n);
      case "enum":
        return n ?? t.enum.values[0].number;
    }
  }
  set(t, n) {
    if (xu(this.message, t), this.check) {
      const a = Co(t, n);
      if (a)
        throw a;
    }
    let r;
    t.fieldKind == "message" ? r = NT(t, n) : mT(n) || fT(n) ? r = n[$a] : r = TT(t, n), ij(this.message, t, r);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(t) {
    this.message.$unknown = t;
  }
}
function xu(e, t) {
  if (t.parent.typeName !== e.$typeName)
    throw new Qt(t, `cannot use ${t.toString()} with message ${e.$typeName}`, "ForeignFieldError");
}
class Ede {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(t, n, r) {
    this._field = t, this._arr = this[$a] = n, this.check = r;
  }
  get(t) {
    const n = this._arr[t];
    return n === void 0 ? void 0 : Ch(this._field, n, this.check);
  }
  set(t, n) {
    if (t < 0 || t >= this._arr.length)
      throw new Qt(this._field, `list item #${t + 1}: out of range`);
    if (this.check) {
      const r = dA(this._field, t, n);
      if (r)
        throw r;
    }
    this._arr[t] = bA(this._field, n);
  }
  add(t) {
    if (this.check) {
      const n = dA(this._field, this._arr.length, t);
      if (n)
        throw n;
    }
    this._arr.push(bA(this._field, t));
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const t of this._arr)
      yield Ch(this._field, t, this.check);
  }
  *entries() {
    for (let t = 0; t < this._arr.length; t++)
      yield [t, Ch(this._field, this._arr[t], this.check)];
  }
}
class vde {
  constructor(t, n, r = !0) {
    this.obj = this[$a] = n ?? {}, this.check = r, this._field = t;
  }
  field() {
    return this._field;
  }
  set(t, n) {
    if (this.check) {
      const r = yde(this._field, t, n);
      if (r)
        throw r;
    }
    return this.obj[Rm(t)] = Tde(this._field, n), this;
  }
  delete(t) {
    const n = Rm(t), r = Object.prototype.hasOwnProperty.call(this.obj, n);
    return r && delete this.obj[n], r;
  }
  clear() {
    for (const t of Object.keys(this.obj))
      delete this.obj[t];
  }
  get(t) {
    let n = this.obj[Rm(t)];
    return n !== void 0 && (n = Kh(this._field, n, this.check)), n;
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.obj, Rm(t));
  }
  *keys() {
    for (const t of Object.keys(this.obj))
      yield gA(t, this._field.mapKey);
  }
  *entries() {
    for (const t of Object.entries(this.obj))
      yield [
        gA(t[0], this._field.mapKey),
        Kh(this._field, t[1], this.check)
      ];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const t of Object.values(this.obj))
      yield Kh(this._field, t, this.check);
  }
  forEach(t, n) {
    for (const r of this.entries())
      t.call(n, r[1], r[0], this);
  }
}
function NT(e, t) {
  return dT(t) ? sde(t.message) && !e.oneof && e.fieldKind == "message" ? t.message.value : t.desc.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" ? Tj(t.message) : t.message : t;
}
function ET(e, t, n) {
  return t !== void 0 && ($f(e.message) && !e.oneof && e.fieldKind == "message" ? t = {
    $typeName: e.message.typeName,
    value: vT(e.message.fields[0], t)
  } : e.message.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" && Oo(t) && (t = vj(t))), new Ej(e.message, t, n);
}
function bA(e, t) {
  return e.listKind == "message" ? NT(e, t) : TT(e, t);
}
function Ch(e, t, n) {
  return e.listKind == "message" ? ET(e, t, n) : vT(e, t);
}
function Tde(e, t) {
  return e.mapKind == "message" ? NT(e, t) : TT(e, t);
}
function Kh(e, t, n) {
  return e.mapKind == "message" ? ET(e, t, n) : t;
}
function Rm(e) {
  return typeof e == "string" || typeof e == "number" ? e : String(e);
}
function gA(e, t) {
  switch (t) {
    case _.STRING:
      return e;
    case _.INT32:
    case _.FIXED32:
    case _.UINT32:
    case _.SFIXED32:
    case _.SINT32: {
      const n = Number.parseInt(e);
      if (Number.isFinite(n))
        return n;
      break;
    }
    case _.BOOL:
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      break;
    case _.UINT64:
    case _.FIXED64:
      try {
        return ee.uParse(e);
      } catch {
      }
      break;
    default:
      try {
        return ee.parse(e);
      } catch {
      }
      break;
  }
  return e;
}
function vT(e, t) {
  switch (e.scalar) {
    case _.INT64:
    case _.SFIXED64:
    case _.SINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = ee.parse(t));
      break;
    case _.FIXED64:
    case _.UINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = ee.uParse(t));
      break;
  }
  return t;
}
function TT(e, t) {
  switch (e.scalar) {
    case _.INT64:
    case _.SFIXED64:
    case _.SINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = ee.parse(t));
      break;
    case _.FIXED64:
    case _.UINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = ee.uParse(t));
      break;
  }
  return t;
}
function vj(e) {
  const t = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (Oo(e))
    for (const [n, r] of Object.entries(e))
      t.fields[n] = wj(r);
  return t;
}
function Tj(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = Ij(r);
  return t;
}
function Ij(e) {
  switch (e.kind.case) {
    case "structValue":
      return Tj(e.kind.value);
    case "listValue":
      return e.kind.value.values.map(Ij);
    case "nullValue":
    case void 0:
      return null;
    default:
      return e.kind.value;
  }
}
function wj(e) {
  const t = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof e) {
    case "number":
      t.kind = { case: "numberValue", value: e };
      break;
    case "string":
      t.kind = { case: "stringValue", value: e };
      break;
    case "boolean":
      t.kind = { case: "boolValue", value: e };
      break;
    case "object":
      if (e === null)
        t.kind = { case: "nullValue", value: 0 };
      else if (Array.isArray(e)) {
        const n = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(e))
          for (const r of e)
            n.values.push(wj(r));
        t.kind = {
          case: "listValue",
          value: n
        };
      } else
        t.kind = {
          case: "structValue",
          value: vj(e)
        };
      break;
  }
  return t;
}
function IT(e) {
  const t = Ide();
  let n = e.length * 3 / 4;
  e[e.length - 2] == "=" ? n -= 2 : e[e.length - 1] == "=" && (n -= 1);
  let r = new Uint8Array(n), a = 0, o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++) {
    if (s = t[e.charCodeAt(u)], s === void 0)
      switch (e[u]) {
        // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
        case "=":
          o = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string");
      }
    switch (o) {
      case 0:
        i = s, o = 1;
        break;
      case 1:
        r[a++] = i << 2 | (s & 48) >> 4, i = s, o = 2;
        break;
      case 2:
        r[a++] = (i & 15) << 4 | (s & 60) >> 2, i = s, o = 3;
        break;
      case 3:
        r[a++] = (i & 3) << 6 | s, o = 0;
        break;
    }
  }
  if (o == 1)
    throw Error("invalid base64 string");
  return r.subarray(0, a);
}
function _j(e, t = "std") {
  const n = Oj(t), r = t == "std";
  let a = "", o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++)
    switch (s = e[u], o) {
      case 0:
        a += n[s >> 2], i = (s & 3) << 4, o = 1;
        break;
      case 1:
        a += n[i | s >> 4], i = (s & 15) << 2, o = 2;
        break;
      case 2:
        a += n[i | s >> 6], a += n[s & 63], o = 0;
        break;
    }
  return o && (a += n[i], r && (a += "=", o == 1 && (a += "="))), a;
}
let $m, hA, ui;
function Oj(e) {
  return $m || ($m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), hA = $m.slice(0, -2).concat("-", "_")), e == "url" ? (
    // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
    hA
  ) : $m;
}
function Ide() {
  if (!ui) {
    ui = [];
    const e = Oj("std");
    for (let t = 0; t < e.length; t++)
      ui[e[t].charCodeAt(0)] = t;
    ui[45] = e.indexOf("+"), ui[95] = e.indexOf("/");
  }
  return ui;
}
function gc(e) {
  let t = !1;
  const n = [];
  for (let r = 0; r < e.length; r++) {
    let a = e.charAt(r);
    switch (a) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        n.push(a), t = !1;
        break;
      default:
        t && (t = !1, a = a.toUpperCase()), n.push(a);
        break;
    }
  }
  return n.join("");
}
const wde = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function hc(e) {
  return wde.has(e) ? e + "$" : e;
}
function wT(e) {
  for (const t of e.field)
    bc(t, "jsonName") || (t.jsonName = gc(t.name));
  e.nestedType.forEach(wT);
}
function _de(e, t) {
  const n = e.values.find((r) => r.name === t);
  if (!n)
    throw new Error(`cannot parse ${e} default value: ${t}`);
  return n.number;
}
function Ode(e, t) {
  switch (e) {
    case _.STRING:
      return t;
    case _.BYTES: {
      const n = Sde(t);
      if (n === !1)
        throw new Error(`cannot parse ${_[e]} default value: ${t}`);
      return n;
    }
    case _.INT64:
    case _.SFIXED64:
    case _.SINT64:
      return ee.parse(t);
    case _.UINT64:
    case _.FIXED64:
      return ee.uParse(t);
    case _.DOUBLE:
    case _.FLOAT:
      switch (t) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(t);
      }
    case _.BOOL:
      return t === "true";
    case _.INT32:
    case _.UINT32:
    case _.SINT32:
    case _.FIXED32:
    case _.SFIXED32:
      return parseInt(t, 10);
  }
}
function Sde(e) {
  const t = [], n = {
    tail: e,
    c: "",
    next() {
      return this.tail.length == 0 ? !1 : (this.c = this.tail[0], this.tail = this.tail.substring(1), !0);
    },
    take(r) {
      if (this.tail.length >= r) {
        const a = this.tail.substring(0, r);
        return this.tail = this.tail.substring(r), a;
      }
      return !1;
    }
  };
  for (; n.next(); )
    switch (n.c) {
      case "\\":
        if (n.next())
          switch (n.c) {
            case "\\":
              t.push(n.c.charCodeAt(0));
              break;
            case "b":
              t.push(8);
              break;
            case "f":
              t.push(12);
              break;
            case "n":
              t.push(10);
              break;
            case "r":
              t.push(13);
              break;
            case "t":
              t.push(9);
              break;
            case "v":
              t.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 8);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "x": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "u": {
              const r = n.c, a = n.take(4);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              const s = new Uint8Array(4);
              new DataView(s.buffer).setInt32(0, o, !0), t.push(s[0], s[1], s[2], s[3]);
              break;
            }
            case "U": {
              const r = n.c, a = n.take(8);
              if (a === !1)
                return !1;
              const o = ee.uEnc(r + a), s = new Uint8Array(8), i = new DataView(s.buffer);
              i.setInt32(0, o.lo, !0), i.setInt32(4, o.hi, !0), t.push(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
              break;
            }
          }
        break;
      default:
        t.push(n.c.charCodeAt(0));
    }
  return new Uint8Array(t);
}
function* BN(e) {
  switch (e.kind) {
    case "file":
      for (const t of e.messages)
        yield t, yield* BN(t);
      yield* e.enums, yield* e.services, yield* e.extensions;
      break;
    case "message":
      for (const t of e.nestedMessages)
        yield t, yield* BN(t);
      yield* e.nestedEnums, yield* e.nestedExtensions;
      break;
  }
}
function Sj(...e) {
  const t = Dde();
  if (!e.length)
    return t;
  if ("$typeName" in e[0] && e[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const n of e[0].file)
      TA(n, t);
    return t;
  }
  if ("$typeName" in e[0]) {
    let n = function(s) {
      const i = [];
      for (const u of s.dependency) {
        if (t.getFile(u) != null || o.has(u))
          continue;
        const l = a(u);
        if (!l)
          throw new Error(`Unable to resolve ${u}, imported by ${s.name}`);
        "kind" in l ? t.addFile(l, !1, !0) : (o.add(l.name), i.push(l));
      }
      return i.concat(...i.map(n));
    };
    const r = e[0], a = e[1], o = /* @__PURE__ */ new Set();
    for (const s of [r, ...n(r)].reverse())
      TA(s, t);
  } else
    for (const n of e)
      for (const r of n.files)
        t.addFile(r);
  return t;
}
function Dde() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    kind: "registry",
    types: e,
    extendees: t,
    [Symbol.iterator]() {
      return e.values();
    },
    get files() {
      return n.values();
    },
    addFile(r, a, o) {
      if (n.set(r.proto.name, r), !a)
        for (const s of BN(r))
          this.add(s);
      if (o)
        for (const s of r.dependencies)
          this.addFile(s, a, o);
    },
    add(r) {
      if (r.kind == "extension") {
        let a = t.get(r.extendee.typeName);
        a || t.set(
          r.extendee.typeName,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = /* @__PURE__ */ new Map()
        ), a.set(r.number, r);
      }
      e.set(r.typeName, r);
    },
    get(r) {
      return e.get(r);
    },
    getFile(r) {
      return n.get(r);
    },
    getMessage(r) {
      const a = e.get(r);
      return a?.kind == "message" ? a : void 0;
    },
    getEnum(r) {
      const a = e.get(r);
      return a?.kind == "enum" ? a : void 0;
    },
    getExtension(r) {
      const a = e.get(r);
      return a?.kind == "extension" ? a : void 0;
    },
    getExtensionFor(r, a) {
      var o;
      return (o = t.get(r.typeName)) === null || o === void 0 ? void 0 : o.get(a);
    },
    getService(r) {
      const a = e.get(r);
      return a?.kind == "service" ? a : void 0;
    }
  };
}
const kde = 998, Ade = 999, Lde = 9, yc = 10, Zu = 11, Fde = 12, yA = 14, _T = 3, Ude = 2, NA = 1, Rde = 0, EA = 1, vA = 2, $de = 3, Pde = 1, Vde = 2, xde = 1, Dj = {
  // EDITION_PROTO2
  998: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 2,
    // CLOSED,
    repeatedFieldEncoding: 2,
    // EXPANDED,
    utf8Validation: 3,
    // NONE,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 2,
    // LEGACY_BEST_EFFORT,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_PROTO3
  999: {
    fieldPresence: 2,
    // IMPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2023
  1e3: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2024
  1001: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 1,
    // STYLE2024,
    defaultSymbolVisibility: 2
    // EXPORT_TOP_LEVEL,
  }
};
function TA(e, t) {
  var n, r;
  const a = {
    kind: "file",
    proto: e,
    deprecated: (r = (n = e.options) === null || n === void 0 ? void 0 : n.deprecated) !== null && r !== void 0 ? r : !1,
    edition: Gde(e),
    name: e.name.replace(/\.proto$/, ""),
    dependencies: Mde(e, t),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${e.name}`;
    }
  }, o = /* @__PURE__ */ new Map(), s = {
    get(i) {
      return o.get(i);
    },
    add(i) {
      var u;
      cr(((u = i.proto.options) === null || u === void 0 ? void 0 : u.mapEntry) === !0), o.set(i.typeName, i);
    }
  };
  for (const i of e.enumType)
    kj(i, a, void 0, t);
  for (const i of e.messageType)
    Aj(i, a, void 0, t, s);
  for (const i of e.service)
    Yde(i, a, t);
  GN(a, t);
  for (const i of o.values())
    MN(i, t, s);
  for (const i of a.messages)
    MN(i, t, s), GN(i, t);
  t.addFile(a, !0);
}
function GN(e, t) {
  switch (e.kind) {
    case "file":
      for (const n of e.proto.extension) {
        const r = CN(n, e, t);
        e.extensions.push(r), t.add(r);
      }
      break;
    case "message":
      for (const n of e.proto.extension) {
        const r = CN(n, e, t);
        e.nestedExtensions.push(r), t.add(r);
      }
      for (const n of e.nestedMessages)
        GN(n, t);
      break;
  }
}
function MN(e, t, n) {
  const r = e.proto.oneofDecl.map((o) => Bde(o, e)), a = /* @__PURE__ */ new Set();
  for (const o of e.proto.field) {
    const s = Xde(o, r), i = CN(o, e, t, s, n);
    e.fields.push(i), e.field[i.localName] = i, s === void 0 ? e.members.push(i) : (s.fields.push(i), a.has(s) || (a.add(s), e.members.push(s)));
  }
  for (const o of r.filter((s) => a.has(s)))
    e.oneofs.push(o);
  for (const o of e.nestedMessages)
    MN(o, t, n);
}
function kj(e, t, n, r) {
  var a, o, s, i, u;
  const l = Cde(e.name, e.value), c = {
    kind: "enum",
    proto: e,
    deprecated: (o = (a = e.options) === null || a === void 0 ? void 0 : a.deprecated) !== null && o !== void 0 ? o : !1,
    file: t,
    parent: n,
    open: !0,
    name: e.name,
    typeName: sg(e, n, t),
    value: {},
    values: [],
    sharedPrefix: l,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  c.open = Hde(c), r.add(c);
  for (const f of e.value) {
    const d = f.name;
    c.values.push(
      // biome-ignore lint/suspicious/noAssignInExpressions: no
      c.value[f.number] = {
        kind: "enum_value",
        proto: f,
        deprecated: (i = (s = f.options) === null || s === void 0 ? void 0 : s.deprecated) !== null && i !== void 0 ? i : !1,
        parent: c,
        name: d,
        localName: hc(l == null ? d : d.substring(l.length)),
        number: f.number,
        toString() {
          return `enum value ${c.typeName}.${d}`;
        }
      }
    );
  }
  ((u = n?.nestedEnums) !== null && u !== void 0 ? u : t.enums).push(c);
}
function Aj(e, t, n, r, a) {
  var o, s, i, u;
  const l = {
    kind: "message",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    file: t,
    parent: n,
    name: e.name,
    typeName: sg(e, n, t),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  ((i = e.options) === null || i === void 0 ? void 0 : i.mapEntry) === !0 ? a.add(l) : (((u = n?.nestedMessages) !== null && u !== void 0 ? u : t.messages).push(l), r.add(l));
  for (const c of e.enumType)
    kj(c, t, l, r);
  for (const c of e.nestedType)
    Aj(c, t, l, r, a);
}
function Yde(e, t, n) {
  var r, a;
  const o = {
    kind: "service",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    file: t,
    name: e.name,
    typeName: sg(e, void 0, t),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  t.services.push(o), n.add(o);
  for (const s of e.method) {
    const i = jde(s, o, n);
    o.methods.push(i), o.method[i.localName] = i;
  }
}
function jde(e, t, n) {
  var r, a, o, s;
  let i;
  e.clientStreaming && e.serverStreaming ? i = "bidi_streaming" : e.clientStreaming ? i = "client_streaming" : e.serverStreaming ? i = "server_streaming" : i = "unary";
  const u = n.getMessage(Ia(e.inputType)), l = n.getMessage(Ia(e.outputType));
  cr(u, `invalid MethodDescriptorProto: input_type ${e.inputType} not found`), cr(l, `invalid MethodDescriptorProto: output_type ${e.inputType} not found`);
  const c = e.name;
  return {
    kind: "rpc",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    parent: t,
    name: c,
    localName: hc(c.length ? hc(c[0].toLowerCase() + c.substring(1)) : c),
    methodKind: i,
    input: u,
    output: l,
    idempotency: (s = (o = e.options) === null || o === void 0 ? void 0 : o.idempotencyLevel) !== null && s !== void 0 ? s : Rde,
    toString() {
      return `rpc ${t.typeName}.${c}`;
    }
  };
}
function Bde(e, t) {
  return {
    kind: "oneof",
    proto: e,
    deprecated: !1,
    parent: t,
    fields: [],
    name: e.name,
    localName: hc(gc(e.name)),
    toString() {
      return `oneof ${t.typeName}.${this.name}`;
    }
  };
}
function CN(e, t, n, r, a) {
  var o, s, i;
  const u = a === void 0, l = {
    kind: "field",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    name: e.name,
    number: e.number,
    scalar: void 0,
    message: void 0,
    enum: void 0,
    presence: Wde(e, r, u, t),
    listKind: void 0,
    mapKind: void 0,
    mapKey: void 0,
    delimitedEncoding: void 0,
    packed: void 0,
    longAsString: !1,
    getDefaultValue: void 0
  };
  if (u) {
    const m = t.kind == "file" ? t : t.file, p = t.kind == "file" ? void 0 : t, b = sg(e, p, m);
    l.kind = "extension", l.file = m, l.parent = p, l.oneof = void 0, l.typeName = b, l.jsonName = `[${b}]`, l.toString = () => `extension ${b}`;
    const g = n.getMessage(Ia(e.extendee));
    cr(g, `invalid FieldDescriptorProto: extendee ${e.extendee} not found`), l.extendee = g;
  } else {
    const m = t;
    cr(m.kind == "message"), l.parent = m, l.oneof = r, l.localName = r ? gc(e.name) : hc(gc(e.name)), l.jsonName = e.jsonName, l.toString = () => `field ${m.typeName}.${e.name}`;
  }
  const c = e.label, f = e.type, d = (i = e.options) === null || i === void 0 ? void 0 : i.jstype;
  if (c === _T) {
    const m = f == Zu ? a?.get(Ia(e.typeName)) : void 0;
    if (m) {
      l.fieldKind = "map";
      const { key: p, value: b } = Zde(m);
      return l.mapKey = p.scalar, l.mapKind = b.fieldKind, l.message = b.message, l.delimitedEncoding = !1, l.enum = b.enum, l.scalar = b.scalar, l;
    }
    switch (l.fieldKind = "list", f) {
      case Zu:
      case yc:
        l.listKind = "message", l.message = n.getMessage(Ia(e.typeName)), cr(l.message), l.delimitedEncoding = IA(e, t);
        break;
      case yA:
        l.listKind = "enum", l.enum = n.getEnum(Ia(e.typeName)), cr(l.enum);
        break;
      default:
        l.listKind = "scalar", l.scalar = f, l.longAsString = d == NA;
        break;
    }
    return l.packed = Jde(e, t), l;
  }
  switch (f) {
    case Zu:
    case yc:
      l.fieldKind = "message", l.message = n.getMessage(Ia(e.typeName)), cr(l.message, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.delimitedEncoding = IA(e, t), l.getDefaultValue = () => {
      };
      break;
    case yA: {
      const m = n.getEnum(Ia(e.typeName));
      cr(m !== void 0, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.fieldKind = "enum", l.enum = n.getEnum(Ia(e.typeName)), l.getDefaultValue = () => bc(e, "defaultValue") ? _de(m, e.defaultValue) : void 0;
      break;
    }
    default: {
      l.fieldKind = "scalar", l.scalar = f, l.longAsString = d == NA, l.getDefaultValue = () => bc(e, "defaultValue") ? Ode(f, e.defaultValue) : void 0;
      break;
    }
  }
  return l;
}
function Gde(e) {
  switch (e.syntax) {
    case "":
    case "proto2":
      return kde;
    case "proto3":
      return Ade;
    case "editions":
      if (e.edition in Dj)
        return e.edition;
      throw new Error(`${e.name}: unsupported edition`);
    default:
      throw new Error(`${e.name}: unsupported syntax "${e.syntax}"`);
  }
}
function Mde(e, t) {
  return e.dependency.map((n) => {
    const r = t.getFile(n);
    if (!r)
      throw new Error(`Cannot find ${n}, imported by ${e.name}`);
    return r;
  });
}
function Cde(e, t) {
  const n = Kde(e) + "_";
  for (const r of t) {
    if (!r.name.toLowerCase().startsWith(n))
      return;
    const a = r.name.substring(n.length);
    if (a.length == 0 || /^\d/.test(a))
      return;
  }
  return n;
}
function Kde(e) {
  return (e.substring(0, 1) + e.substring(1).replace(/[A-Z]/g, (t) => "_" + t)).toLowerCase();
}
function sg(e, t, n) {
  let r;
  return t ? r = `${t.typeName}.${e.name}` : n.proto.package.length > 0 ? r = `${n.proto.package}.${e.name}` : r = `${e.name}`, r;
}
function Ia(e) {
  return e.startsWith(".") ? e.substring(1) : e;
}
function Xde(e, t) {
  if (!bc(e, "oneofIndex") || e.proto3Optional)
    return;
  const n = t[e.oneofIndex];
  return cr(n, `invalid FieldDescriptorProto: oneof #${e.oneofIndex} for field #${e.number} not found`), n;
}
function Wde(e, t, n, r) {
  if (e.label == Ude)
    return $de;
  if (e.label == _T)
    return vA;
  if (t || e.proto3Optional || n)
    return EA;
  const a = mu("fieldPresence", { proto: e, parent: r });
  return a == vA && (e.type == Zu || e.type == yc) ? EA : a;
}
function Jde(e, t) {
  if (e.label != _T)
    return !1;
  switch (e.type) {
    case Lde:
    case Fde:
    case yc:
    case Zu:
      return !1;
  }
  const n = e.options;
  return n && bc(n, "packed") ? n.packed : Pde == mu("repeatedFieldEncoding", {
    proto: e,
    parent: t
  });
}
function Zde(e) {
  const t = e.fields.find((r) => r.number === 1), n = e.fields.find((r) => r.number === 2);
  return cr(t && t.fieldKind == "scalar" && t.scalar != _.BYTES && t.scalar != _.FLOAT && t.scalar != _.DOUBLE && n && n.fieldKind != "list" && n.fieldKind != "map"), { key: t, value: n };
}
function Hde(e) {
  var t;
  return xde == mu("enumType", {
    proto: e.proto,
    parent: (t = e.parent) !== null && t !== void 0 ? t : e.file
  });
}
function IA(e, t) {
  return e.type == yc ? !0 : Vde == mu("messageEncoding", {
    proto: e,
    parent: t
  });
}
function mu(e, t) {
  var n, r;
  const a = (n = t.proto.options) === null || n === void 0 ? void 0 : n.features;
  if (a) {
    const o = a[e];
    if (o != 0)
      return o;
  }
  if ("kind" in t) {
    if (t.kind == "message")
      return mu(e, (r = t.parent) !== null && r !== void 0 ? r : t.file);
    const o = Dj[t.edition];
    if (!o)
      throw new Error(`feature default for edition ${t.edition} not found`);
    return o[e];
  }
  return mu(e, t.parent);
}
function cr(e, t) {
  if (!e)
    throw new Error(t);
}
function zde(e) {
  const t = qde(e);
  return t.messageType.forEach(wT), Sj(t, () => {
  }).getFile(t.name);
}
function qde(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    syntax: "",
    edition: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, e), { messageType: e.messageType.map(Lj), enumType: e.enumType.map(Fj) }));
}
function Lj(e) {
  var t, n, r, a, o, s, i, u;
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.DescriptorProto",
    name: e.name,
    field: (n = (t = e.field) === null || t === void 0 ? void 0 : t.map(Qde)) !== null && n !== void 0 ? n : [],
    extension: [],
    nestedType: (a = (r = e.nestedType) === null || r === void 0 ? void 0 : r.map(Lj)) !== null && a !== void 0 ? a : [],
    enumType: (s = (o = e.enumType) === null || o === void 0 ? void 0 : o.map(Fj)) !== null && s !== void 0 ? s : [],
    extensionRange: (u = (i = e.extensionRange) === null || i === void 0 ? void 0 : i.map((l) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, l))) !== null && u !== void 0 ? u : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function Qde(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: !1
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, e), { options: e.options ? epe(e.options) : void 0 }));
}
function epe(e) {
  var t, n, r;
  return Object.assign(/* @__PURE__ */ Object.create({
    ctype: 0,
    packed: !1,
    jstype: 0,
    lazy: !1,
    unverifiedLazy: !1,
    deprecated: !1,
    weak: !1,
    debugRedact: !1,
    retention: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, e), { targets: (t = e.targets) !== null && t !== void 0 ? t : [], editionDefaults: (r = (n = e.editionDefaults) === null || n === void 0 ? void 0 : n.map((a) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, a))) !== null && r !== void 0 ? r : [], uninterpretedOption: [] }));
}
function Fj(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: e.name,
    reservedName: [],
    reservedRange: [],
    value: e.value.map((t) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, t))
  });
}
function Pf(e, t, ...n) {
  return n.reduce((r, a) => r.nestedMessages[a], e.messages[t]);
}
const tpe = /* @__PURE__ */ zde({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: !0 } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false", options: { deprecated: !0 } }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1e3 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1e3, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: !0 } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1e3 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_UNSTABLE", number: 9999 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] }), npe = /* @__PURE__ */ Pf(tpe, 1);
var wA;
(function(e) {
  e[e.DECLARATION = 0] = "DECLARATION", e[e.UNVERIFIED = 1] = "UNVERIFIED";
})(wA || (wA = {}));
var _A;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.GROUP = 10] = "GROUP", e[e.MESSAGE = 11] = "MESSAGE", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.ENUM = 14] = "ENUM", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(_A || (_A = {}));
var OA;
(function(e) {
  e[e.OPTIONAL = 1] = "OPTIONAL", e[e.REPEATED = 3] = "REPEATED", e[e.REQUIRED = 2] = "REQUIRED";
})(OA || (OA = {}));
var SA;
(function(e) {
  e[e.SPEED = 1] = "SPEED", e[e.CODE_SIZE = 2] = "CODE_SIZE", e[e.LITE_RUNTIME = 3] = "LITE_RUNTIME";
})(SA || (SA = {}));
var DA;
(function(e) {
  e[e.STRING = 0] = "STRING", e[e.CORD = 1] = "CORD", e[e.STRING_PIECE = 2] = "STRING_PIECE";
})(DA || (DA = {}));
var kA;
(function(e) {
  e[e.JS_NORMAL = 0] = "JS_NORMAL", e[e.JS_STRING = 1] = "JS_STRING", e[e.JS_NUMBER = 2] = "JS_NUMBER";
})(kA || (kA = {}));
var AA;
(function(e) {
  e[e.RETENTION_UNKNOWN = 0] = "RETENTION_UNKNOWN", e[e.RETENTION_RUNTIME = 1] = "RETENTION_RUNTIME", e[e.RETENTION_SOURCE = 2] = "RETENTION_SOURCE";
})(AA || (AA = {}));
var LA;
(function(e) {
  e[e.TARGET_TYPE_UNKNOWN = 0] = "TARGET_TYPE_UNKNOWN", e[e.TARGET_TYPE_FILE = 1] = "TARGET_TYPE_FILE", e[e.TARGET_TYPE_EXTENSION_RANGE = 2] = "TARGET_TYPE_EXTENSION_RANGE", e[e.TARGET_TYPE_MESSAGE = 3] = "TARGET_TYPE_MESSAGE", e[e.TARGET_TYPE_FIELD = 4] = "TARGET_TYPE_FIELD", e[e.TARGET_TYPE_ONEOF = 5] = "TARGET_TYPE_ONEOF", e[e.TARGET_TYPE_ENUM = 6] = "TARGET_TYPE_ENUM", e[e.TARGET_TYPE_ENUM_ENTRY = 7] = "TARGET_TYPE_ENUM_ENTRY", e[e.TARGET_TYPE_SERVICE = 8] = "TARGET_TYPE_SERVICE", e[e.TARGET_TYPE_METHOD = 9] = "TARGET_TYPE_METHOD";
})(LA || (LA = {}));
var KN;
(function(e) {
  e[e.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e[e.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e[e.IDEMPOTENT = 2] = "IDEMPOTENT";
})(KN || (KN = {}));
var FA;
(function(e) {
  e[e.DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", e[e.EXPORT_ALL = 1] = "EXPORT_ALL", e[e.EXPORT_TOP_LEVEL = 2] = "EXPORT_TOP_LEVEL", e[e.LOCAL_ALL = 3] = "LOCAL_ALL", e[e.STRICT = 4] = "STRICT";
})(FA || (FA = {}));
var UA;
(function(e) {
  e[e.FIELD_PRESENCE_UNKNOWN = 0] = "FIELD_PRESENCE_UNKNOWN", e[e.EXPLICIT = 1] = "EXPLICIT", e[e.IMPLICIT = 2] = "IMPLICIT", e[e.LEGACY_REQUIRED = 3] = "LEGACY_REQUIRED";
})(UA || (UA = {}));
var RA;
(function(e) {
  e[e.ENUM_TYPE_UNKNOWN = 0] = "ENUM_TYPE_UNKNOWN", e[e.OPEN = 1] = "OPEN", e[e.CLOSED = 2] = "CLOSED";
})(RA || (RA = {}));
var $A;
(function(e) {
  e[e.REPEATED_FIELD_ENCODING_UNKNOWN = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN", e[e.PACKED = 1] = "PACKED", e[e.EXPANDED = 2] = "EXPANDED";
})($A || ($A = {}));
var PA;
(function(e) {
  e[e.UTF8_VALIDATION_UNKNOWN = 0] = "UTF8_VALIDATION_UNKNOWN", e[e.VERIFY = 2] = "VERIFY", e[e.NONE = 3] = "NONE";
})(PA || (PA = {}));
var VA;
(function(e) {
  e[e.MESSAGE_ENCODING_UNKNOWN = 0] = "MESSAGE_ENCODING_UNKNOWN", e[e.LENGTH_PREFIXED = 1] = "LENGTH_PREFIXED", e[e.DELIMITED = 2] = "DELIMITED";
})(VA || (VA = {}));
var xA;
(function(e) {
  e[e.JSON_FORMAT_UNKNOWN = 0] = "JSON_FORMAT_UNKNOWN", e[e.ALLOW = 1] = "ALLOW", e[e.LEGACY_BEST_EFFORT = 2] = "LEGACY_BEST_EFFORT";
})(xA || (xA = {}));
var YA;
(function(e) {
  e[e.ENFORCE_NAMING_STYLE_UNKNOWN = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN", e[e.STYLE2024 = 1] = "STYLE2024", e[e.STYLE_LEGACY = 2] = "STYLE_LEGACY";
})(YA || (YA = {}));
var jA;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SET = 1] = "SET", e[e.ALIAS = 2] = "ALIAS";
})(jA || (jA = {}));
var BA;
(function(e) {
  e[e.EDITION_UNKNOWN = 0] = "EDITION_UNKNOWN", e[e.EDITION_LEGACY = 900] = "EDITION_LEGACY", e[e.EDITION_PROTO2 = 998] = "EDITION_PROTO2", e[e.EDITION_PROTO3 = 999] = "EDITION_PROTO3", e[e.EDITION_2023 = 1e3] = "EDITION_2023", e[e.EDITION_2024 = 1001] = "EDITION_2024", e[e.EDITION_UNSTABLE = 9999] = "EDITION_UNSTABLE", e[e.EDITION_1_TEST_ONLY = 1] = "EDITION_1_TEST_ONLY", e[e.EDITION_2_TEST_ONLY = 2] = "EDITION_2_TEST_ONLY", e[e.EDITION_99997_TEST_ONLY = 99997] = "EDITION_99997_TEST_ONLY", e[e.EDITION_99998_TEST_ONLY = 99998] = "EDITION_99998_TEST_ONLY", e[e.EDITION_99999_TEST_ONLY = 99999] = "EDITION_99999_TEST_ONLY", e[e.EDITION_MAX = 2147483647] = "EDITION_MAX";
})(BA || (BA = {}));
var GA;
(function(e) {
  e[e.VISIBILITY_UNSET = 0] = "VISIBILITY_UNSET", e[e.VISIBILITY_LOCAL = 1] = "VISIBILITY_LOCAL", e[e.VISIBILITY_EXPORT = 2] = "VISIBILITY_EXPORT";
})(GA || (GA = {}));
const MA = {
  readUnknownFields: !0
};
function rpe(e) {
  return e ? Object.assign(Object.assign({}, MA), e) : MA;
}
function ig(e, t, n) {
  const r = er(e, void 0, !1);
  return Uj(r, new hT(t), rpe(n), !1, t.byteLength), r.message;
}
function Uj(e, t, n, r, a) {
  var o;
  const s = r ? t.len : t.pos + a;
  let i, u;
  const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
  for (; t.pos < s && ([i, u] = t.tag(), !(r && u == me.EndGroup)); ) {
    const c = e.findNumber(i);
    if (!c) {
      const f = t.skip(u, i);
      n.readUnknownFields && l.push({ no: i, wireType: u, data: f });
      continue;
    }
    Rj(e, t, c, u, n);
  }
  if (r && (u != me.EndGroup || i !== a))
    throw new Error("invalid end group tag");
  l.length > 0 && e.setUnknown(l);
}
function Rj(e, t, n, r, a) {
  var o;
  switch (n.fieldKind) {
    case "scalar":
      e.set(n, du(t, n.scalar));
      break;
    case "enum":
      const s = du(t, _.INT32);
      if (n.enum.open)
        e.set(n, s);
      else if (n.enum.values.some((i) => i.number === s))
        e.set(n, s);
      else if (a.readUnknownFields) {
        const i = [];
        jN(s, i);
        const u = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
        u.push({
          no: n.number,
          wireType: r,
          data: new Uint8Array(i)
        }), e.setUnknown(u);
      }
      break;
    case "message":
      e.set(n, OT(t, a, n, e.get(n)));
      break;
    case "list":
      ope(t, r, e.get(n), a);
      break;
    case "map":
      ape(t, e.get(n), a);
      break;
  }
}
function ape(e, t, n) {
  const r = t.field();
  let a, o;
  const s = e.uint32(), i = e.pos + s;
  for (; e.pos < i; ) {
    const [u] = e.tag();
    switch (u) {
      case 1:
        a = du(e, r.mapKey);
        break;
      case 2:
        switch (r.mapKind) {
          case "scalar":
            o = du(e, r.scalar);
            break;
          case "enum":
            o = e.int32();
            break;
          case "message":
            o = OT(e, n, r);
            break;
        }
        break;
    }
  }
  if (a === void 0 && (a = Zs(r.mapKey, !1)), o === void 0)
    switch (r.mapKind) {
      case "scalar":
        o = Zs(r.scalar, !1);
        break;
      case "enum":
        o = r.enum.values[0].number;
        break;
      case "message":
        o = er(r.message, void 0, !1);
        break;
    }
  t.set(a, o);
}
function ope(e, t, n, r) {
  var a;
  const o = n.field();
  if (o.listKind === "message") {
    n.add(OT(e, r, o));
    return;
  }
  const s = (a = o.scalar) !== null && a !== void 0 ? a : _.INT32;
  if (!(t == me.LengthDelimited && s != _.STRING && s != _.BYTES)) {
    n.add(du(e, s));
    return;
  }
  const i = e.uint32() + e.pos;
  for (; e.pos < i; )
    n.add(du(e, s));
}
function OT(e, t, n, r) {
  const a = n.delimitedEncoding, o = r ?? er(n.message, void 0, !1);
  return Uj(o, e, t, a, a ? n.number : e.uint32()), o;
}
function du(e, t) {
  switch (t) {
    case _.STRING:
      return e.string();
    case _.BOOL:
      return e.bool();
    case _.DOUBLE:
      return e.double();
    case _.FLOAT:
      return e.float();
    case _.INT32:
      return e.int32();
    case _.INT64:
      return e.int64();
    case _.UINT64:
      return e.uint64();
    case _.FIXED64:
      return e.fixed64();
    case _.BYTES:
      return e.bytes();
    case _.FIXED32:
      return e.fixed32();
    case _.SFIXED32:
      return e.sfixed32();
    case _.SFIXED64:
      return e.sfixed64();
    case _.SINT64:
      return e.sint64();
    case _.UINT32:
      return e.uint32();
    case _.SINT32:
      return e.sint32();
  }
}
function $j(e, t) {
  var n;
  const r = ig(npe, IT(e));
  return r.messageType.forEach(wT), r.dependency = (n = void 0) !== null && n !== void 0 ? n : [], Sj(r, (a) => {
  }).getFile(r.name);
}
const spe = /* @__PURE__ */ $j("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), ipe = /* @__PURE__ */ Pf(spe, 0), upe = 3, CA = {
  writeUnknownFields: !0
};
function lpe(e) {
  return e ? Object.assign(Object.assign({}, CA), e) : CA;
}
function Pj(e, t, n) {
  return Yp(new bj(), lpe(n), er(e, t)).finish();
}
function Yp(e, t, n) {
  var r;
  for (const a of n.sortedFields) {
    if (!n.isSet(a)) {
      if (a.presence == upe)
        throw new Error(`cannot encode ${a} to binary: required field not set`);
      continue;
    }
    Vj(e, t, n, a);
  }
  if (t.writeUnknownFields)
    for (const { no: a, wireType: o, data: s } of (r = n.getUnknown()) !== null && r !== void 0 ? r : [])
      e.tag(a, o).raw(s);
  return e;
}
function Vj(e, t, n, r) {
  var a;
  switch (r.fieldKind) {
    case "scalar":
    case "enum":
      jp(e, n.desc.typeName, r.name, (a = r.scalar) !== null && a !== void 0 ? a : _.INT32, r.number, n.get(r));
      break;
    case "list":
      cpe(e, t, r, n.get(r));
      break;
    case "message":
      xj(e, t, r, n.get(r));
      break;
    case "map":
      for (const [o, s] of n.get(r))
        fpe(e, t, r, o, s);
      break;
  }
}
function jp(e, t, n, r, a, o) {
  Yj(e.tag(a, mpe(r)), t, n, r, o);
}
function xj(e, t, n, r) {
  n.delimitedEncoding ? Yp(e.tag(n.number, me.StartGroup), t, r).tag(n.number, me.EndGroup) : Yp(e.tag(n.number, me.LengthDelimited).fork(), t, r).join();
}
function cpe(e, t, n, r) {
  var a;
  if (n.listKind == "message") {
    for (const s of r)
      xj(e, t, n, s);
    return;
  }
  const o = (a = n.scalar) !== null && a !== void 0 ? a : _.INT32;
  if (n.packed) {
    if (!r.size)
      return;
    e.tag(n.number, me.LengthDelimited).fork();
    for (const s of r)
      Yj(e, n.parent.typeName, n.name, o, s);
    e.join();
    return;
  }
  for (const s of r)
    jp(e, n.parent.typeName, n.name, o, n.number, s);
}
function fpe(e, t, n, r, a) {
  var o;
  switch (e.tag(n.number, me.LengthDelimited).fork(), jp(e, n.parent.typeName, n.name, n.mapKey, 1, r), n.mapKind) {
    case "scalar":
    case "enum":
      jp(e, n.parent.typeName, n.name, (o = n.scalar) !== null && o !== void 0 ? o : _.INT32, 2, a);
      break;
    case "message":
      Yp(e.tag(2, me.LengthDelimited).fork(), t, a).join();
      break;
  }
  e.join();
}
function Yj(e, t, n, r, a) {
  try {
    switch (r) {
      case _.STRING:
        e.string(a);
        break;
      case _.BOOL:
        e.bool(a);
        break;
      case _.DOUBLE:
        e.double(a);
        break;
      case _.FLOAT:
        e.float(a);
        break;
      case _.INT32:
        e.int32(a);
        break;
      case _.INT64:
        e.int64(a);
        break;
      case _.UINT64:
        e.uint64(a);
        break;
      case _.FIXED64:
        e.fixed64(a);
        break;
      case _.BYTES:
        e.bytes(a);
        break;
      case _.FIXED32:
        e.fixed32(a);
        break;
      case _.SFIXED32:
        e.sfixed32(a);
        break;
      case _.SFIXED64:
        e.sfixed64(a);
        break;
      case _.SINT64:
        e.sint64(a);
        break;
      case _.UINT32:
        e.uint32(a);
        break;
      case _.SINT32:
        e.sint32(a);
        break;
    }
  } catch (o) {
    throw o instanceof Error ? new Error(`cannot encode field ${t}.${n} to binary: ${o.message}`) : o;
  }
}
function mpe(e) {
  switch (e) {
    case _.BYTES:
    case _.STRING:
      return me.LengthDelimited;
    case _.DOUBLE:
    case _.FIXED64:
    case _.SFIXED64:
      return me.Bit64;
    case _.FIXED32:
    case _.SFIXED32:
    case _.FLOAT:
      return me.Bit32;
    default:
      return me.Varint;
  }
}
function dpe(e, t, n) {
  let r = !1;
  return n || (n = Dr(ipe), r = !0), n.value = Pj(e, t), n.typeUrl = gpe(t.$typeName), r ? n : void 0;
}
function ppe(e, t) {
  if (e.typeUrl === "")
    return !1;
  const n = typeof t == "string" ? t : t.typeName, r = jj(e.typeUrl);
  return n === r;
}
function bpe(e, t) {
  if (e.typeUrl === "")
    return;
  const n = t.kind == "message" ? t : t.getMessage(jj(e.typeUrl));
  if (!(!n || !ppe(e, n)))
    return ig(n, e.value);
}
function gpe(e) {
  return `type.googleapis.com/${e}`;
}
function jj(e) {
  const t = e.lastIndexOf("/"), n = t >= 0 ? e.substring(t + 1) : e;
  if (!n.length)
    throw new Error(`invalid type url: ${e}`);
  return n;
}
const ST = /* @__PURE__ */ $j("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), hpe = /* @__PURE__ */ Pf(ST, 0), Bj = /* @__PURE__ */ Pf(ST, 1), ype = /* @__PURE__ */ Pf(ST, 2);
var XN;
(function(e) {
  e[e.NULL_VALUE = 0] = "NULL_VALUE";
})(XN || (XN = {}));
function Npe(e, t) {
  Gj(t, e);
  const n = vpe(e.$unknown, t), [r, a, o] = ug(t);
  for (const s of n)
    Rj(r, new hT(s.data), a, s.wireType, {
      readUnknownFields: !0
    });
  return o();
}
function Epe(e, t, n) {
  var r;
  Gj(t, e);
  const a = ((r = e.$unknown) !== null && r !== void 0 ? r : []).filter((l) => l.no !== t.number), [o, s] = ug(t, n), i = new bj();
  Vj(i, { writeUnknownFields: !0 }, o, s);
  const u = new hT(i.finish());
  for (; u.pos < u.len; ) {
    const [l, c] = u.tag(), f = u.skip(c, l);
    a.push({ no: l, wireType: c, data: f });
  }
  e.$unknown = a;
}
function vpe(e, t) {
  if (e === void 0)
    return [];
  if (t.fieldKind === "enum" || t.fieldKind === "scalar") {
    for (let n = e.length - 1; n >= 0; --n)
      if (e[n].no == t.number)
        return [e[n]];
    return [];
  }
  return e.filter((n) => n.no === t.number);
}
function ug(e, t) {
  const n = e.typeName, r = Object.assign(Object.assign({}, e), { kind: "field", parent: e.extendee, localName: n }), a = Object.assign(Object.assign({}, e.extendee), { fields: [r], members: [r], oneofs: [] }), o = Dr(a, t !== void 0 ? { [n]: t } : void 0);
  return [
    er(a, o),
    r,
    () => {
      const s = o[n];
      if (s === void 0) {
        const i = e.message;
        return $f(i) ? Zs(i.fields[0].scalar, i.fields[0].longAsString) : Dr(i);
      }
      return s;
    }
  ];
}
function Gj(e, t) {
  if (e.extendee.typeName != t.$typeName)
    throw new Error(`extension ${e.typeName} can only be applied to message ${e.extendee.typeName}`);
}
const Tpe = 3, Ipe = 2, KA = {
  alwaysEmitImplicit: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1
};
function wpe(e) {
  return e ? Object.assign(Object.assign({}, KA), e) : KA;
}
function _pe(e, t, n) {
  return Vf(er(e, t), wpe(n));
}
function Ope(e, t, n) {
  var r;
  const a = _pe(e, t, n);
  return JSON.stringify(a, null, (r = n?.prettySpaces) !== null && r !== void 0 ? r : 0);
}
function Vf(e, t) {
  var n;
  const r = Ape(e, t);
  if (r !== void 0)
    return r;
  const a = {};
  for (const o of e.sortedFields) {
    if (!e.isSet(o)) {
      if (o.presence == Tpe)
        throw new Error(`cannot encode ${o} to JSON: required field not set`);
      if (!t.alwaysEmitImplicit || o.presence !== Ipe)
        continue;
    }
    const s = XA(o, e.get(o), t);
    s !== void 0 && (a[kpe(o, t)] = s);
  }
  if (t.registry) {
    const o = /* @__PURE__ */ new Set();
    for (const { no: s } of (n = e.getUnknown()) !== null && n !== void 0 ? n : [])
      if (!o.has(s)) {
        o.add(s);
        const i = t.registry.getExtensionFor(e.desc, s);
        if (!i)
          continue;
        const u = Npe(e.message, i), [l, c] = ug(i, u), f = XA(c, l.get(c), t);
        f !== void 0 && (a[i.jsonName] = f);
      }
  }
  return a;
}
function XA(e, t, n) {
  switch (e.fieldKind) {
    case "scalar":
      return lg(e, t);
    case "message":
      return Vf(t, n);
    case "enum":
      return DT(e.enum, t, n.enumAsInteger);
    case "list":
      return Dpe(t, n);
    case "map":
      return Spe(t, n);
  }
}
function Spe(e, t) {
  const n = e.field(), r = {};
  switch (n.mapKind) {
    case "scalar":
      for (const [a, o] of e)
        r[a] = lg(n, o);
      break;
    case "message":
      for (const [a, o] of e)
        r[a] = Vf(o, t);
      break;
    case "enum":
      for (const [a, o] of e)
        r[a] = DT(n.enum, o, t.enumAsInteger);
      break;
  }
  return t.alwaysEmitImplicit || e.size > 0 ? r : void 0;
}
function Dpe(e, t) {
  const n = e.field(), r = [];
  switch (n.listKind) {
    case "scalar":
      for (const a of e)
        r.push(lg(n, a));
      break;
    case "enum":
      for (const a of e)
        r.push(DT(n.enum, a, t.enumAsInteger));
      break;
    case "message":
      for (const a of e)
        r.push(Vf(a, t));
      break;
  }
  return t.alwaysEmitImplicit || r.length > 0 ? r : void 0;
}
function DT(e, t, n) {
  var r;
  if (typeof t != "number")
    throw new Error(`cannot encode ${e} to JSON: expected number, got ${Ge(t)}`);
  return e.typeName == "google.protobuf.NullValue" ? null : n ? t : (r = e.value[t]?.name) !== null && r !== void 0 ? r : t;
}
function lg(e, t) {
  var n, r, a, o, s, i;
  switch (e.scalar) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case _.INT32:
    case _.SFIXED32:
    case _.SINT32:
    case _.FIXED32:
    case _.UINT32:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(n = Co(e, t)) === null || n === void 0 ? void 0 : n.message}`);
      return t;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case _.FLOAT:
    case _.DOUBLE:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(r = Co(e, t)) === null || r === void 0 ? void 0 : r.message}`);
      return Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    // string:
    case _.STRING:
      if (typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(a = Co(e, t)) === null || a === void 0 ? void 0 : a.message}`);
      return t;
    // bool:
    case _.BOOL:
      if (typeof t != "boolean")
        throw new Error(`cannot encode ${e} to JSON: ${(o = Co(e, t)) === null || o === void 0 ? void 0 : o.message}`);
      return t;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case _.UINT64:
    case _.FIXED64:
    case _.INT64:
    case _.SFIXED64:
    case _.SINT64:
      if (typeof t != "bigint" && typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(s = Co(e, t)) === null || s === void 0 ? void 0 : s.message}`);
      return t.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case _.BYTES:
      if (t instanceof Uint8Array)
        return _j(t);
      throw new Error(`cannot encode ${e} to JSON: ${(i = Co(e, t)) === null || i === void 0 ? void 0 : i.message}`);
  }
}
function kpe(e, t) {
  return t.useProtoFieldName ? e.name : e.jsonName;
}
function Ape(e, t) {
  if (e.desc.typeName.startsWith("google.protobuf."))
    switch (e.desc.typeName) {
      case "google.protobuf.Any":
        return Lpe(e.message, t);
      case "google.protobuf.Timestamp":
        return Rpe(e.message);
      case "google.protobuf.Duration":
        return Fpe(e.message);
      case "google.protobuf.FieldMask":
        return Upe(e.message);
      case "google.protobuf.Struct":
        return Mj(e.message);
      case "google.protobuf.Value":
        return kT(e.message);
      case "google.protobuf.ListValue":
        return Cj(e.message);
      default:
        if ($f(e.desc)) {
          const n = e.desc.fields[0];
          return lg(n, e.get(n));
        }
        return;
    }
}
function Lpe(e, t) {
  if (e.typeUrl === "")
    return {};
  const { registry: n } = t;
  let r, a;
  if (n && (r = bpe(e, n), r && (a = n.getMessage(r.$typeName))), !a || !r)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: "${e.typeUrl}" is not in the type registry`);
  let o = Vf(er(a, r), t);
  return (a.typeName.startsWith("google.protobuf.") || o === null || Array.isArray(o) || typeof o != "object") && (o = { value: o }), o["@type"] = e.typeUrl, o;
}
function Fpe(e) {
  const t = Number(e.seconds), n = e.nanos;
  if (t > 315576e6 || t < -315576e6)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: value out of range`);
  if (t > 0 && n < 0 || t < 0 && n > 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos sign must match seconds sign`);
  let r = e.seconds.toString();
  if (n !== 0) {
    let a = Math.abs(n).toString();
    a = "0".repeat(9 - a.length) + a, a.substring(3) === "000000" ? a = a.substring(0, 3) : a.substring(6) === "000" && (a = a.substring(0, 6)), r += "." + a, n < 0 && t == 0 && (r = "-" + r);
  }
  return r + "s";
}
function Upe(e) {
  return e.paths.map((t) => {
    if (t.match(/_[0-9]?_/g) || t.match(/[A-Z]/g))
      throw new Error(`cannot encode message ${e.$typeName} to JSON: lowerCamelCase of path name "` + t + '" is irreversible');
    return gc(t);
  }).join(",");
}
function Mj(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = kT(r);
  return t;
}
function kT(e) {
  switch (e.kind.case) {
    case "nullValue":
      return null;
    case "numberValue":
      if (!Number.isFinite(e.kind.value))
        throw new Error(`${e.$typeName} cannot be NaN or Infinity`);
      return e.kind.value;
    case "boolValue":
      return e.kind.value;
    case "stringValue":
      return e.kind.value;
    case "structValue":
      return Mj(e.kind.value);
    case "listValue":
      return Cj(e.kind.value);
    default:
      throw new Error(`${e.$typeName} must have a value`);
  }
}
function Cj(e) {
  return e.values.map(kT);
}
function Rpe(e) {
  const t = Number(e.seconds) * 1e3;
  if (t < Date.parse("0001-01-01T00:00:00Z") || t > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot encode message ${e.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  if (e.nanos < 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be negative`);
  if (e.nanos > 999999999)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be greater than 99999999`);
  let n = "Z";
  if (e.nanos > 0) {
    const r = (e.nanos + 1e9).toString().substring(1);
    r.substring(3) === "000000" ? n = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? n = "." + r.substring(0, 6) + "Z" : n = "." + r + "Z";
  }
  return new Date(t).toISOString().replace(".000Z", n);
}
const WA = {
  ignoreUnknownFields: !1
};
function $pe(e) {
  return e ? Object.assign(Object.assign({}, WA), e) : WA;
}
function Ppe(e, t, n) {
  return Kj(e, Mpe(t, e.typeName), n);
}
function Kj(e, t, n) {
  const r = er(e);
  try {
    pu(r, t, $pe(n));
  } catch (a) {
    throw gde(a) ? new Error(`cannot decode ${a.field()} from JSON: ${a.message}`, {
      cause: a
    }) : a;
  }
  return r.message;
}
function pu(e, t, n) {
  var r;
  if (Cpe(e, t, n))
    return;
  if (t == null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode ${e.desc} from JSON: ${Ge(t)}`);
  const a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const s of e.desc.fields)
    o.set(s.name, s).set(s.jsonName, s);
  for (const [s, i] of Object.entries(t)) {
    const u = o.get(s);
    if (u) {
      if (u.oneof) {
        if (i === null && u.fieldKind == "scalar")
          continue;
        const l = a.get(u.oneof);
        if (l !== void 0)
          throw new Qt(u.oneof, `oneof set multiple times by ${l.name} and ${u.name}`);
        a.set(u.oneof, u);
      }
      JA(e, u, i, n);
    } else {
      let l;
      if (s.startsWith("[") && s.endsWith("]") && // biome-ignore lint/suspicious/noAssignInExpressions: no
      (l = (r = n.registry) === null || r === void 0 ? void 0 : r.getExtension(s.substring(1, s.length - 1))) && l.extendee.typeName === e.desc.typeName) {
        const [c, f, d] = ug(l);
        JA(c, f, i, n), Epe(e.message, l, d());
      }
      if (!l && !n.ignoreUnknownFields)
        throw new Error(`cannot decode ${e.desc} from JSON: key "${s}" is unknown`);
    }
  }
}
function JA(e, t, n, r) {
  switch (t.fieldKind) {
    case "scalar":
      Bpe(e, t, n);
      break;
    case "enum":
      jpe(e, t, n, r);
      break;
    case "message":
      Ype(e, t, n, r);
      break;
    case "list":
      xpe(e.get(t), n, r);
      break;
    case "map":
      Vpe(e.get(t), n, r);
      break;
  }
}
function Vpe(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (typeof t != "object" || Array.isArray(t))
    throw new Qt(r, "expected object, got " + Ge(t));
  for (const [a, o] of Object.entries(t)) {
    if (o === null && !Xj(r))
      throw new Qt(r, "map value must not be null");
    let s;
    switch (r.mapKind) {
      case "message":
        const u = er(r.message);
        pu(u, o, n), s = u;
        break;
      case "enum":
        if (s = AT(r.enum, o, n.ignoreUnknownFields, !0), s === cg)
          return;
        break;
      case "scalar":
        s = mg(r, o, !0);
        break;
    }
    const i = Gpe(r.mapKey, a);
    e.set(i, s);
  }
}
function xpe(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (!Array.isArray(t))
    throw new Qt(r, "expected Array, got " + Ge(t));
  for (const a of t) {
    if (a === null && !Xj(r))
      throw new Qt(r, "list item must not be null");
    switch (r.listKind) {
      case "message":
        const o = er(r.message);
        pu(o, a, n), e.add(o);
        break;
      case "enum":
        const s = AT(r.enum, a, n.ignoreUnknownFields, !0);
        s !== cg && e.add(s);
        break;
      case "scalar":
        e.add(mg(r, a, !0));
        break;
    }
  }
}
function Xj(e) {
  var t, n;
  return ((t = e.message) === null || t === void 0 ? void 0 : t.typeName) == "google.protobuf.Value" || ((n = e.enum) === null || n === void 0 ? void 0 : n.typeName) == "google.protobuf.NullValue";
}
function Ype(e, t, n, r) {
  if (n === null && t.message.typeName != "google.protobuf.Value") {
    e.clear(t);
    return;
  }
  const a = e.isSet(t) ? e.get(t) : er(t.message);
  pu(a, n, r), e.set(t, a);
}
function jpe(e, t, n, r) {
  const a = AT(t.enum, n, r.ignoreUnknownFields, !1);
  a === fg ? e.clear(t) : a !== cg && e.set(t, a);
}
function Bpe(e, t, n) {
  const r = mg(t, n, !1);
  r === fg ? e.clear(t) : e.set(t, r);
}
const cg = /* @__PURE__ */ Symbol();
function AT(e, t, n, r) {
  if (t === null)
    return e.typeName == "google.protobuf.NullValue" ? 0 : r ? e.values[0].number : fg;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const a = e.values.find((o) => o.name === t);
      if (a !== void 0)
        return a.number;
      if (n)
        return cg;
      break;
  }
  throw new Error(`cannot decode ${e} from JSON: ${Ge(t)}`);
}
const fg = /* @__PURE__ */ Symbol();
function mg(e, t, n) {
  if (t === null)
    return n ? Zs(e.scalar, !1) : fg;
  switch (e.scalar) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case _.DOUBLE:
    case _.FLOAT:
      if (t === "NaN")
        return NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (typeof t == "number") {
        if (Number.isNaN(t))
          throw new Qt(e, "unexpected NaN number");
        if (!Number.isFinite(t))
          throw new Qt(e, "unexpected infinite number");
        break;
      }
      if (typeof t == "string") {
        if (t === "" || t.trim().length !== t.length)
          break;
        const r = Number(t);
        if (!Number.isFinite(r))
          break;
        return r;
      }
      break;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case _.INT32:
    case _.FIXED32:
    case _.SFIXED32:
    case _.SINT32:
    case _.UINT32:
      return Wj(t);
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case _.BYTES:
      if (typeof t == "string") {
        if (t === "")
          return new Uint8Array(0);
        try {
          return IT(t);
        } catch (r) {
          const a = r instanceof Error ? r.message : String(r);
          throw new Qt(e, a);
        }
      }
      break;
  }
  return t;
}
function Gpe(e, t) {
  switch (e) {
    case _.BOOL:
      switch (t) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      return t;
    case _.INT32:
    case _.FIXED32:
    case _.UINT32:
    case _.SFIXED32:
    case _.SINT32:
      return Wj(t);
    default:
      return t;
  }
}
function Wj(e) {
  if (typeof e == "string") {
    if (e === "" || e.trim().length !== e.length)
      return e;
    const t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
function Mpe(e, t) {
  try {
    return JSON.parse(e);
  } catch (n) {
    const r = n instanceof Error ? n.message : String(n);
    throw new Error(
      `cannot decode message ${t} from JSON: ${r}`,
      // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
      { cause: n }
    );
  }
}
function Cpe(e, t, n) {
  if (!e.desc.typeName.startsWith("google.protobuf."))
    return !1;
  switch (e.desc.typeName) {
    case "google.protobuf.Any":
      return Kpe(e.message, t, n), !0;
    case "google.protobuf.Timestamp":
      return Xpe(e.message, t), !0;
    case "google.protobuf.Duration":
      return Wpe(e.message, t), !0;
    case "google.protobuf.FieldMask":
      return Jpe(e.message, t), !0;
    case "google.protobuf.Struct":
      return Jj(e.message, t), !0;
    case "google.protobuf.Value":
      return LT(e.message, t), !0;
    case "google.protobuf.ListValue":
      return Zj(e.message, t), !0;
    default:
      if ($f(e.desc)) {
        const r = e.desc.fields[0];
        return t === null ? e.clear(r) : e.set(r, mg(r, t, !0)), !0;
      }
      return !1;
  }
}
function Kpe(e, t, n) {
  var r;
  if (t === null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: expected object but got ${Ge(t)}`);
  if (Object.keys(t).length == 0)
    return;
  const a = t["@type"];
  if (typeof a != "string" || a == "")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is empty`);
  const o = a.includes("/") ? a.substring(a.lastIndexOf("/") + 1) : a;
  if (!o.length)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is invalid`);
  const s = (r = n.registry) === null || r === void 0 ? void 0 : r.getMessage(o);
  if (!s)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${a} is not in the type registry`);
  const i = er(s);
  if (o.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(t, "value")) {
    const u = t.value;
    pu(i, u, n);
  } else {
    const u = Object.assign({}, t);
    delete u["@type"], pu(i, u, n);
  }
  dpe(i.desc, i.message, e);
}
function Xpe(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ge(t)}`);
  const n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
  if (!n)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  const r = Date.parse(
    // biome-ignore format: want this to read well
    n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z")
  );
  if (Number.isNaN(r))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  e.seconds = ee.parse(r / 1e3), e.nanos = 0, n[7] && (e.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9);
}
function Wpe(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ge(t)}`);
  const n = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
  if (n === null)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ge(t)}`);
  const r = Number(n[1]);
  if (r > 315576e6 || r < -315576e6)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ge(t)}`);
  if (e.seconds = ee.parse(r), typeof n[2] != "string")
    return;
  const a = n[2] + "0".repeat(9 - n[2].length);
  e.nanos = parseInt(a), (r < 0 || Object.is(r, -0)) && (e.nanos = -e.nanos);
}
function Jpe(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Ge(t)}`);
  if (t === "")
    return;
  function n(r) {
    if (r.includes("_"))
      throw new Error(`cannot decode message ${e.$typeName} from JSON: path names must be lowerCamelCase`);
    const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase());
    return a[0] === "_" ? a.substring(1) : a;
  }
  e.paths = t.split(",").map(n);
}
function Jj(e, t) {
  if (typeof t != "object" || t == null || Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Ge(t)}`);
  for (const [n, r] of Object.entries(t)) {
    const a = Dr(Bj);
    LT(a, r), e.fields[n] = a;
  }
}
function LT(e, t) {
  switch (typeof t) {
    case "number":
      e.kind = { case: "numberValue", value: t };
      break;
    case "string":
      e.kind = { case: "stringValue", value: t };
      break;
    case "boolean":
      e.kind = { case: "boolValue", value: t };
      break;
    case "object":
      if (t === null)
        e.kind = { case: "nullValue", value: XN.NULL_VALUE };
      else if (Array.isArray(t)) {
        const n = Dr(ype);
        Zj(n, t), e.kind = { case: "listValue", value: n };
      } else {
        const n = Dr(hpe);
        Jj(n, t), e.kind = { case: "structValue", value: n };
      }
      break;
    default:
      throw new Error(`cannot decode message ${e.$typeName} from JSON ${Ge(t)}`);
  }
  return e;
}
function Zj(e, t) {
  if (!Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Ge(t)}`);
  for (const n of t) {
    const r = Dr(Bj);
    LT(r, n), e.values.push(r);
  }
}
function WN(e) {
  const t = C[e];
  return typeof t != "string" ? e.toString() : t[0].toLowerCase() + t.substring(1).replace(/[A-Z]/g, (n) => "_" + n.toLowerCase());
}
let Pm;
function Zpe(e) {
  if (!Pm) {
    Pm = {};
    for (const t of Object.values(C))
      typeof t != "string" && (Pm[WN(t)] = t);
  }
  return Pm[e];
}
class Fe extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(t, n = C.Unknown, r, a, o) {
    super(Hpe(t, n)), this.name = "ConnectError", Object.setPrototypeOf(this, new.target.prototype), this.rawMessage = t, this.code = n, this.metadata = new Headers(r ?? {}), this.details = a ?? [], this.cause = o;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(t, n = C.Unknown) {
    return t instanceof Fe ? t : t instanceof Error ? t.name == "AbortError" || t.name == "TimeoutError" ? new Fe(t.message, C.Canceled) : new Fe(t.message, n, void 0, void 0, t) : new Fe(String(t), n, void 0, void 0, t);
  }
  static [Symbol.hasInstance](t) {
    return t instanceof Error ? Object.getPrototypeOf(t) === Fe.prototype ? !0 : t.name === "ConnectError" && "code" in t && typeof t.code == "number" && "metadata" in t && "details" in t && Array.isArray(t.details) && "rawMessage" in t && typeof t.rawMessage == "string" && "cause" in t : !1;
  }
  findDetails(t) {
    const n = t.kind === "message" ? {
      getMessage: (a) => a === t.typeName ? t : void 0
    } : t, r = [];
    for (const a of this.details) {
      if ("desc" in a) {
        n.getMessage(a.desc.typeName) && r.push(Dr(a.desc, a.value));
        continue;
      }
      const o = n.getMessage(a.type);
      if (o)
        try {
          r.push(ig(o, a.value));
        } catch {
        }
    }
    return r;
  }
}
function Hpe(e, t) {
  return e.length ? `[${WN(t)}] ${e}` : `[${WN(t)}]`;
}
function zpe(...e) {
  const t = new Headers();
  for (const n of e)
    n.forEach((r, a) => {
      t.append(a, r);
    });
  return t;
}
const ZA = 1;
function qpe(e, t, n = !1) {
  if (t > e) {
    let r = `message size is larger than configured readMaxBytes ${e}`;
    throw n && (r = `message size ${t} is larger than configured readMaxBytes ${e}`), new Fe(r, C.ResourceExhausted);
  }
}
function Qpe(e) {
  return new ebe(e);
}
class ebe {
  constructor(t) {
    this.readMaxBytes = t, this.header = new Uint8Array(5), this.headerView = new DataView(this.header.buffer), this.buf = [];
  }
  get byteLength() {
    return this.buf.reduce((t, n) => t + n.byteLength, 0);
  }
  decode(t) {
    this.buf.push(t);
    const n = [];
    for (; ; ) {
      let r = this.pop();
      if (!r)
        break;
      n.push(r);
    }
    return n;
  }
  // consume an enveloped message
  pop() {
    if (!(!this.env && (this.env = this.head(), !this.env)) && this.cons(this.env.data)) {
      const t = this.env;
      return this.env = void 0, t;
    }
  }
  // consume header
  head() {
    if (!this.cons(this.header))
      return;
    const t = this.headerView.getUint8(0), n = this.headerView.getUint32(1);
    return qpe(this.readMaxBytes, n, !0), {
      flags: t,
      data: new Uint8Array(n)
    };
  }
  // consume from buffer, fill target
  cons(t) {
    const n = t.byteLength;
    if (this.byteLength < n)
      return !1;
    let r = 0;
    for (; r < n; ) {
      const a = this.buf.shift();
      a.byteLength > n - r ? (t.set(a.subarray(0, n - r), r), this.buf.unshift(a.subarray(n - r)), r += n - r) : (t.set(a, r), r += a.byteLength);
    }
    return !0;
  }
}
function tbe(e) {
  let t;
  const n = Qpe(4294967295);
  return new ReadableStream({
    start() {
      t = e.getReader();
    },
    async pull(r) {
      let a = !1;
      for (; !a; ) {
        const o = await t.read();
        if (o.done)
          n.byteLength > 0 && r.error(new Fe("protocol error: incomplete envelope", C.InvalidArgument)), r.close();
        else
          for (const s of n.decode(o.value))
            r.enqueue(s), a = !0;
      }
    }
  });
}
function nbe(e, t) {
  const n = new Uint8Array(t.length + 5);
  n.set(t, 5);
  const r = new DataView(n.buffer, n.byteOffset, n.byteLength);
  return r.setUint8(0, e), r.setUint32(1, t.length), n;
}
function rbe(...e) {
  const t = new AbortController(), n = e.filter((a) => a !== void 0).concat(t.signal);
  for (const a of n) {
    if (a.aborted) {
      r.apply(a);
      break;
    }
    a.addEventListener("abort", r);
  }
  function r() {
    t.signal.aborted || t.abort(Hj(this));
    for (const a of n)
      a.removeEventListener("abort", r);
  }
  return t;
}
function abe(e) {
  const t = new AbortController(), n = () => {
    t.abort(new Fe("the operation timed out", C.DeadlineExceeded));
  };
  let r;
  return e !== void 0 && (e <= 0 ? n() : r = setTimeout(n, e)), {
    signal: t.signal,
    cleanup: () => clearTimeout(r)
  };
}
function Hj(e) {
  if (!e.aborted)
    return;
  if (e.reason !== void 0)
    return e.reason;
  const t = new Error("This operation was aborted");
  return t.name = "AbortError", t;
}
function HA() {
  return {
    get(e) {
      return e.id in this ? this[e.id] : e.defaultValue;
    },
    set(e, t) {
      return this[e.id] = t, this;
    },
    delete(e) {
      return delete this[e.id], this;
    }
  };
}
function zA(e, t) {
  return e.toString().replace(/\/?$/, `/${t.parent.typeName}/${t.name}`);
}
function zj(e, t) {
  return Dr(e, t);
}
function obe(e, t) {
  function n(r) {
    return r.done === !0 ? r : {
      done: r.done,
      value: zj(e, r.value)
    };
  }
  return {
    [Symbol.asyncIterator]() {
      const r = t[Symbol.asyncIterator](), a = {
        next: () => r.next().then(n)
      };
      return r.throw !== void 0 && (a.throw = (o) => r.throw(o).then(n)), r.return !== void 0 && (a.return = (o) => r.return(o).then(n)), a;
    }
  };
}
function qj(e, t) {
  if (!t)
    return e;
  for (const n of t.concat().reverse())
    e = n(e);
  return e;
}
function Qj(e) {
  var t;
  const n = Object.assign({}, e);
  return (t = n.ignoreUnknownFields) !== null && t !== void 0 || (n.ignoreUnknownFields = !0), n;
}
function qA(e, t, n, r) {
  const a = t ? QA(e.input, r) : e9(e.input, n);
  return { parse: (t ? QA(e.output, r) : e9(e.output, n)).parse, serialize: a.serialize };
}
function QA(e, t) {
  return {
    parse(n) {
      try {
        return ig(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Fe(`parse binary: ${a}`, C.Internal);
      }
    },
    serialize(n) {
      try {
        return Pj(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Fe(`serialize binary: ${a}`, C.Internal);
      }
    }
  };
}
function e9(e, t) {
  var n, r;
  const a = (n = t?.textEncoder) !== null && n !== void 0 ? n : new TextEncoder(), o = (r = t?.textDecoder) !== null && r !== void 0 ? r : new TextDecoder(), s = Qj(t);
  return {
    parse(i) {
      try {
        const u = o.decode(i);
        return Ppe(e, u, s);
      } catch (u) {
        throw Fe.from(u, C.InvalidArgument);
      }
    },
    serialize(i) {
      try {
        const u = Ope(e, i, s);
        return a.encode(u);
      } catch (u) {
        throw Fe.from(u, C.Internal);
      }
    }
  };
}
const sbe = /^application\/(connect\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i, ibe = "application/proto", ube = "application/json", lbe = "application/connect+proto", cbe = "application/connect+json";
function fbe(e) {
  const t = e?.match(sbe);
  if (!t)
    return;
  const n = !!t[1], r = !!t[3];
  return { stream: n, binary: r };
}
function eB(e, t, n) {
  var r;
  if (t && new Headers(t).forEach((i, u) => n.metadata.append(u, i)), typeof e != "object" || e == null || Array.isArray(e))
    throw n;
  let a = n.code;
  "code" in e && typeof e.code == "string" && (a = (r = Zpe(e.code)) !== null && r !== void 0 ? r : a);
  const o = e.message;
  if (o != null && typeof o != "string")
    throw n;
  const s = new Fe(o ?? "", a, t);
  if ("details" in e && Array.isArray(e.details))
    for (const i of e.details) {
      if (i === null || typeof i != "object" || Array.isArray(i) || typeof i.type != "string" || typeof i.value != "string")
        throw n;
      try {
        s.details.push({
          type: i.type,
          value: IT(i.value),
          debug: i.debug
        });
      } catch {
        throw n;
      }
    }
  return s;
}
const t9 = 2;
function mbe(e) {
  const t = new Fe("invalid end stream", C.Unknown);
  let n;
  try {
    n = JSON.parse(typeof e == "string" ? e : new TextDecoder().decode(e));
  } catch {
    throw t;
  }
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw t;
  const r = new Headers();
  if ("metadata" in n) {
    if (typeof n.metadata != "object" || n.metadata == null || Array.isArray(n.metadata))
      throw t;
    for (const [o, s] of Object.entries(n.metadata)) {
      if (!Array.isArray(s) || s.some((i) => typeof i != "string"))
        throw t;
      for (const i of s)
        r.append(o, i);
    }
  }
  const a = "error" in n && n.error != null ? eB(n.error, r, t) : void 0;
  return { metadata: r, error: a };
}
const Bp = "Content-Type", dbe = "Content-Length", n9 = "Content-Encoding", pbe = "Accept-Encoding", bbe = "Connect-Timeout-Ms", tB = "Connect-Protocol-Version", gbe = "User-Agent";
function hbe(e) {
  switch (e) {
    case 400:
      return C.Internal;
    case 401:
      return C.Unauthenticated;
    case 403:
      return C.PermissionDenied;
    case 404:
      return C.Unimplemented;
    case 429:
      return C.Unavailable;
    case 502:
      return C.Unavailable;
    case 503:
      return C.Unavailable;
    case 504:
      return C.Unavailable;
    default:
      return C.Unknown;
  }
}
function r9(e) {
  const t = new Headers(), n = new Headers();
  return e.forEach((r, a) => {
    a.toLowerCase().startsWith("trailer-") ? n.append(a.substring(8), r) : t.append(a, r);
  }), [t, n];
}
const nB = "1";
function a9(e, t, n, r, a) {
  const o = new Headers(r ?? {});
  return n !== void 0 && o.set(bbe, `${n}`), o.set(Bp, e == "unary" ? t ? ibe : ube : t ? lbe : cbe), o.set(tB, nB), o.has(gbe), o;
}
function o9(e, t, n, r) {
  const a = r.get(Bp), o = fbe(a);
  if (n !== 200) {
    const i = new Fe(`HTTP ${n}`, hbe(n), r);
    if (e == "unary" && o && !o.binary)
      return { isUnaryError: !0, unaryError: i };
    throw i;
  }
  const s = {
    binary: t,
    stream: e !== "unary"
  };
  if (o?.binary !== s.binary || o.stream !== s.stream)
    throw new Fe(`unsupported content type ${a}`, o === void 0 ? C.Unknown : C.Internal, r);
  return { isUnaryError: !1 };
}
const s9 = "application/";
function ybe(e, t) {
  return t ? _j(e, "url") : encodeURIComponent(new TextDecoder().decode(e));
}
function Nbe(e, t, n) {
  let r = `?connect=v${nB}`;
  const a = e.header.get(Bp);
  a?.indexOf(s9) === 0 && (r += "&encoding=" + encodeURIComponent(a.slice(s9.length)));
  const o = e.header.get(n9);
  o !== null && o !== "identity" && (r += "&compression=" + encodeURIComponent(o), n = !0), n && (r += "&base64=1"), r += "&message=" + ybe(t, n);
  const s = e.url + r, i = new Headers(e.header);
  for (const u of [
    tB,
    Bp,
    dbe,
    n9,
    pbe
  ])
    i.delete(u);
  return Object.assign(Object.assign({}, e), {
    requestMethod: "GET",
    url: s,
    header: i
  });
}
function Ebe(e) {
  const t = qj(e.next, e.interceptors), [n, r, a] = rB(e), o = Object.assign(Object.assign({}, e.req), { message: zj(e.req.method.input, e.req.message), signal: n });
  return t(o).then((s) => (a(), s), r);
}
function vbe(e) {
  const t = qj(e.next, e.interceptors), [n, r, a] = rB(e), o = Object.assign(Object.assign({}, e.req), { message: obe(e.req.method.input, e.req.message), signal: n });
  let s = !1;
  return n.addEventListener("abort", function() {
    var i, u;
    const l = e.req.message[Symbol.asyncIterator]();
    s || (i = l.throw) === null || i === void 0 || i.call(l, this.reason).catch(() => {
    }), (u = l.return) === null || u === void 0 || u.call(l).catch(() => {
    });
  }), t(o).then((i) => Object.assign(Object.assign({}, i), { message: {
    [Symbol.asyncIterator]() {
      const u = i.message[Symbol.asyncIterator]();
      return {
        next() {
          return u.next().then((l) => (l.done == !0 && (s = !0, a()), l), r);
        }
        // We deliberately omit throw/return.
      };
    }
  } }), r);
}
function rB(e) {
  const { signal: t, cleanup: n } = abe(e.timeoutMs), r = rbe(e.signal, t);
  return [
    r.signal,
    function(a) {
      const o = Fe.from(t.aborted ? Hj(t) : a);
      return r.abort(o), n(), Promise.reject(o);
    },
    function() {
      n(), r.abort();
    }
  ];
}
function Tbe() {
  try {
    new Headers();
  } catch {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}
var Nc = function(e) {
  return this instanceof Nc ? (this.v = e, this) : new Nc(e);
}, Ibe = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof Nc ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
const i9 = {
  redirect: "error"
};
function wbe(e) {
  var t;
  Tbe();
  const n = (t = e.useBinaryFormat) !== null && t !== void 0 ? t : !1;
  return {
    async unary(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = qA(r, n, e.jsonOptions, e.binaryOptions);
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await Ebe({
        interceptors: e.interceptors,
        signal: a,
        timeoutMs: o,
        req: {
          stream: !1,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: zA(e.baseUrl, r),
          header: a9(r.methodKind, n, o, s),
          contextValues: u ?? HA(),
          message: i
        },
        next: async (f) => {
          var d;
          const m = e.useHttpGet === !0 && r.idempotency === KN.NO_SIDE_EFFECTS;
          let p = null;
          m ? f = Nbe(f, l(f.message), n) : p = l(f.message);
          const b = await ((d = e.fetch) !== null && d !== void 0 ? d : globalThis.fetch)(f.url, Object.assign(Object.assign({}, i9), { method: f.requestMethod, headers: f.header, signal: f.signal, body: p })), { isUnaryError: g, unaryError: S } = o9(r.methodKind, n, b.status, b.headers);
          if (g)
            throw eB(await b.json(), zpe(...r9(b.headers)), S);
          const [D, k] = r9(b.headers);
          return {
            stream: !1,
            service: r.parent,
            method: r,
            header: D,
            message: n ? c(new Uint8Array(await b.arrayBuffer())) : Kj(r.output, await b.json(), Qj(e.jsonOptions)),
            trailer: k
          };
        }
      });
    },
    async stream(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = qA(r, n, e.jsonOptions, e.binaryOptions);
      function f(m, p, b, g) {
        return Ibe(this, arguments, function* () {
          const S = tbe(m).getReader();
          let D = !1;
          for (; ; ) {
            const k = yield Nc(S.read());
            if (k.done)
              break;
            const { flags: U, data: R } = k.value;
            if ((U & ZA) === ZA)
              throw new Fe("protocol error: received unsupported compressed output", C.Internal);
            if ((U & t9) === t9) {
              D = !0;
              const F = mbe(R);
              if (F.error) {
                const A = F.error;
                throw b.forEach((L, re) => {
                  A.metadata.append(re, L);
                }), A;
              }
              F.metadata.forEach((A, L) => p.set(L, A));
              continue;
            }
            yield yield Nc(c(R));
          }
          if ("throwIfAborted" in g && g.throwIfAborted(), !D)
            throw "missing EndStreamResponse";
        });
      }
      async function d(m) {
        if (r.methodKind != "server_streaming")
          throw "The fetch API does not support streaming request bodies";
        const p = await m[Symbol.asyncIterator]().next();
        if (p.done == !0)
          throw "missing request message";
        return nbe(0, l(p.value));
      }
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await vbe({
        interceptors: e.interceptors,
        timeoutMs: o,
        signal: a,
        req: {
          stream: !0,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: zA(e.baseUrl, r),
          header: a9(r.methodKind, n, o, s),
          contextValues: u ?? HA(),
          message: i
        },
        next: async (m) => {
          var p;
          const b = await ((p = e.fetch) !== null && p !== void 0 ? p : globalThis.fetch)(m.url, Object.assign(Object.assign({}, i9), { method: m.requestMethod, headers: m.header, signal: m.signal, body: await d(m.message) }));
          if (o9(r.methodKind, n, b.status, b.headers), b.body === null)
            throw "missing response body";
          const g = new Headers();
          return Object.assign(Object.assign({}, m), { header: b.headers, trailer: g, message: f(b.body, g, b.headers, m.signal) });
        }
      });
    }
  };
}
wbe({
  baseUrl: "/api",
  useBinaryFormat: !0,
  fetch: (e, t) => {
    const n = t?.headers ?? {};
    return fetch(e, {
      ...t,
      headers: {
        ...n,
        "qt-widget-id": window.qtWidgetId
      }
    });
  }
});
const Et = /* @__PURE__ */ Symbol(), _be = !1;
var Obe = Array.isArray, Sbe = Array.prototype.indexOf, Xh = Object.getOwnPropertyDescriptor, Dbe = Object.prototype, kbe = Array.prototype, Abe = Object.getPrototypeOf;
function Lbe(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function Fbe() {
  var e, t, n = new Promise((r, a) => {
    e = r, t = a;
  });
  return { promise: n, resolve: e, reject: t };
}
const dn = 2, Ube = 4, Rbe = 1 << 24, Du = 16, xf = 32, Yf = 64, FT = 128, ra = 512, kt = 1024, kr = 2048, aa = 4096, bd = 8192, Ss = 16384, $be = 32768, u9 = 1 << 17, aB = 1 << 18, Hs = 32768, JN = 1 << 21, oB = 1 << 22, Ec = 1 << 23, Wh = /* @__PURE__ */ Symbol("$state"), sB = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function Pbe() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Vbe() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function xbe() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Ybe() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function jbe(e) {
  return e === this.v;
}
let Bbe = !1;
function iB() {
  return !0;
}
let Si = [];
function Gbe() {
  var e = Si;
  Si = [], Lbe(e);
}
function Mbe(e) {
  if (Si.length === 0) {
    var t = Si;
    queueMicrotask(() => {
      t === Si && Gbe();
    });
  }
  Si.push(e);
}
function Cbe(e) {
  var t = en;
  if (t === null)
    return Ie.f |= Ec, e;
  if ((t.f & $be) === 0) {
    if ((t.f & FT) === 0)
      throw e;
    t.b.error(e);
  } else
    uB(e, t);
}
function uB(e, t) {
  for (; t !== null; ) {
    if ((t.f & FT) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e;
}
const Vm = /* @__PURE__ */ new Set();
let Qe = null, Cn = null, jr = [], UT = null, ZN = !1;
class vc {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #e = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #i = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    jr = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const r of t)
      this.#u(r, n);
    this.is_fork || this.#c(), this.is_deferred() ? (this.#n(n.effects), this.#n(n.render_effects)) : (Qe = null, l9(n.render_effects), l9(n.effects), this.#i?.resolve()), Cn = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #u(t, n) {
    t.f ^= kt;
    for (var r = t.first; r !== null; ) {
      var a = r.f, o = (a & (xf | Yf)) !== 0, s = o && (a & kt) !== 0, i = s || (a & bd) !== 0 || this.skipped_effects.has(r);
      if ((r.f & FT) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: []
      }), !i && r.fn !== null) {
        o ? r.f ^= kt : (a & Ube) !== 0 ? n.effects.push(r) : Bf(r) && ((r.f & Du) !== 0 && this.#o.add(r), Xp(r));
        var u = r.first;
        if (u !== null) {
          r = u;
          continue;
        }
      }
      var l = r.parent;
      for (r = r.next; r === null && l !== null; )
        l === n.effect && (this.#n(n.effects), this.#n(n.render_effects), n = /** @type {EffectTarget} */
        n.parent), r = l.next, l = l.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #n(t) {
    for (const n of t)
      (n.f & kr) !== 0 ? this.#o.add(n) : (n.f & aa) !== 0 && this.#s.add(n), this.#l(n.deps), tn(n, kt);
  }
  /**
   * @param {Value[] | null} deps
   */
  #l(t) {
    if (t !== null)
      for (const n of t)
        (n.f & dn) === 0 || (n.f & Hs) === 0 || (n.f ^= Hs, this.#l(
          /** @type {Derived} */
          n.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.previous.has(t) || this.previous.set(t, n), (t.f & Ec) === 0 && (this.current.set(t, t.v), Cn?.set(t, t.v));
  }
  activate() {
    Qe = this, this.apply();
  }
  deactivate() {
    Qe === this && (Qe = null, Cn = null);
  }
  flush() {
    if (this.activate(), jr.length > 0) {
      if (Kbe(), Qe !== null && Qe !== this)
        return;
    } else this.#e === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const t of this.#a) t(this);
    this.#a.clear();
  }
  #c() {
    if (this.#t === 0) {
      for (const t of this.#r) t();
      this.#r.clear();
    }
    this.#e === 0 && this.#f();
  }
  #f() {
    if (Vm.size > 1) {
      this.previous.clear();
      var t = Cn, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const o of Vm) {
        if (o === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [u, l] of this.current) {
          if (o.current.has(u))
            if (n && l !== o.current.get(u))
              o.current.set(u, l);
            else
              continue;
          s.push(u);
        }
        if (s.length === 0)
          continue;
        const i = [...o.current.keys()].filter((u) => !this.current.has(u));
        if (i.length > 0) {
          var a = jr;
          jr = [];
          const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            lB(c, i, u, l);
          if (jr.length > 0) {
            Qe = o, o.apply();
            for (const c of jr)
              o.#u(c, r);
            o.deactivate();
          }
          jr = a;
        }
      }
      Qe = null, Cn = t;
    }
    this.committed = !0, Vm.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(t) {
    this.#e += 1, t && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(t) {
    this.#e -= 1, t && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const t of this.#o)
      this.#s.delete(t), tn(t, kr), Tc(t);
    for (const t of this.#s)
      tn(t, aa), Tc(t);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(t) {
    this.#r.add(t);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(t) {
    this.#a.add(t);
  }
  settled() {
    return (this.#i ??= Fbe()).promise;
  }
  static ensure() {
    if (Qe === null) {
      const t = Qe = new vc();
      Vm.add(Qe), vc.enqueue(() => {
        Qe === t && t.flush();
      });
    }
    return Qe;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    Mbe(t);
  }
  apply() {
  }
}
function Kbe() {
  var e = Ds;
  ZN = !0;
  try {
    var t = 0;
    for (Mp(!0); jr.length > 0; ) {
      var n = vc.ensure();
      if (t++ > 1e3) {
        var r, a;
        Xbe();
      }
      n.process(jr), bo.clear();
    }
  } finally {
    ZN = !1, Mp(e), UT = null;
  }
}
function Xbe() {
  try {
    Pbe();
  } catch (e) {
    uB(e, UT);
  }
}
let wa = null;
function l9(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (Ss | bd)) === 0 && Bf(r) && (wa = /* @__PURE__ */ new Set(), Xp(r), r.deps === null && r.first === null && r.nodes === null && (r.teardown === null && r.ac === null ? yB(r) : r.fn = null), wa?.size > 0)) {
        bo.clear();
        for (const a of wa) {
          if ((a.f & (Ss | bd)) !== 0) continue;
          const o = [a];
          let s = a.parent;
          for (; s !== null; )
            wa.has(s) && (wa.delete(s), o.push(s)), s = s.parent;
          for (let i = o.length - 1; i >= 0; i--) {
            const u = o[i];
            (u.f & (Ss | bd)) === 0 && Xp(u);
          }
        }
        wa.clear();
      }
    }
    wa = null;
  }
}
function lB(e, t, n, r) {
  if (!n.has(e) && (n.add(e), e.reactions !== null))
    for (const a of e.reactions) {
      const o = a.f;
      (o & dn) !== 0 ? lB(
        /** @type {Derived} */
        a,
        t,
        n,
        r
      ) : (o & (oB | Du)) !== 0 && (o & kr) === 0 && cB(a, t, r) && (tn(a, kr), Tc(
        /** @type {Effect} */
        a
      ));
    }
}
function cB(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (e.deps !== null)
    for (const a of e.deps) {
      if (t.includes(a))
        return !0;
      if ((a.f & dn) !== 0 && cB(
        /** @type {Derived} */
        a,
        t,
        n
      ))
        return n.set(
          /** @type {Derived} */
          a,
          !0
        ), !0;
    }
  return n.set(e, !1), !1;
}
function Tc(e) {
  for (var t = UT = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (ZN && t === en && (n & Du) !== 0 && (n & aB) === 0)
      return;
    if ((n & (Yf | xf)) !== 0) {
      if ((n & kt) === 0) return;
      t.f ^= kt;
    }
  }
  jr.push(t);
}
function fB(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      $T(
        /** @type {Effect} */
        t[n]
      );
  }
}
function Wbe(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & dn) === 0)
      return (t.f & Ss) === 0 ? (
        /** @type {Effect} */
        t
      ) : null;
    t = t.parent;
  }
  return null;
}
function RT(e) {
  var t, n = en;
  Cp(Wbe(e));
  try {
    e.f &= ~Hs, fB(e), t = TB(e);
  } finally {
    Cp(n);
  }
  return t;
}
function mB(e) {
  var t = RT(e);
  if (e.equals(t) || (Qe?.is_fork || (e.v = t), e.wv = EB()), !jf)
    if (Cn !== null)
      (Gp() || Qe?.is_fork) && Cn.set(e, t);
    else {
      var n = (e.f & ra) === 0 ? aa : kt;
      tn(e, n);
    }
}
let HN = /* @__PURE__ */ new Set();
const bo = /* @__PURE__ */ new Map();
let dB = !1;
function Jbe(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: jbe,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function no(e, t) {
  const n = Jbe(e);
  return tge(n), n;
}
function Ko(e, t, n = !1) {
  Ie !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!ns || (Ie.f & u9) !== 0) && iB() && (Ie.f & (dn | Du | oB | u9)) !== 0 && !Ka?.includes(e) && Ybe();
  let r = n ? Di(t) : t;
  return Zbe(e, r);
}
function Zbe(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    jf ? bo.set(e, t) : bo.set(e, n), e.v = t;
    var r = vc.ensure();
    r.capture(e, n), (e.f & dn) !== 0 && ((e.f & kr) !== 0 && RT(
      /** @type {Derived} */
      e
    ), tn(e, (e.f & ra) !== 0 ? kt : aa)), e.wv = EB(), pB(e, kr), en !== null && (en.f & kt) !== 0 && (en.f & (xf | Yf)) === 0 && (Rn === null ? nge([e]) : Rn.push(e)), !r.is_fork && HN.size > 0 && !dB && Hbe();
  }
  return t;
}
function Hbe() {
  dB = !1;
  var e = Ds;
  Mp(!0);
  const t = Array.from(HN);
  try {
    for (const n of t)
      (n.f & kt) !== 0 && tn(n, aa), Bf(n) && Xp(n);
  } finally {
    Mp(e);
  }
  HN.clear();
}
function Jh(e) {
  Ko(e, e.v + 1);
}
function pB(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, a = 0; a < r; a++) {
      var o = n[a], s = o.f, i = (s & kr) === 0;
      if (i && tn(o, t), (s & dn) !== 0) {
        var u = (
          /** @type {Derived} */
          o
        );
        Cn?.delete(u), (s & Hs) === 0 && (s & ra && (o.f |= Hs), pB(u, aa));
      } else i && ((s & Du) !== 0 && wa !== null && wa.add(
        /** @type {Effect} */
        o
      ), Tc(
        /** @type {Effect} */
        o
      ));
    }
}
function Di(e) {
  if (typeof e != "object" || e === null || Wh in e)
    return e;
  const t = Abe(e);
  if (t !== Dbe && t !== kbe)
    return e;
  var n = /* @__PURE__ */ new Map(), r = Obe(e), a = /* @__PURE__ */ no(0), o = ks, s = (i) => {
    if (ks === o)
      return i();
    var u = Ie, l = ks;
    bu(null), f9(o);
    var c = i();
    return bu(u), f9(l), c;
  };
  return r && n.set("length", /* @__PURE__ */ no(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(i, u, l) {
        (!("value" in l) || l.configurable === !1 || l.enumerable === !1 || l.writable === !1) && Vbe();
        var c = n.get(u);
        return c === void 0 ? c = s(() => {
          var f = /* @__PURE__ */ no(l.value);
          return n.set(u, f), f;
        }) : Ko(c, l.value, !0), !0;
      },
      deleteProperty(i, u) {
        var l = n.get(u);
        if (l === void 0) {
          if (u in i) {
            const c = s(() => /* @__PURE__ */ no(Et));
            n.set(u, c), Jh(a);
          }
        } else
          Ko(l, Et), Jh(a);
        return !0;
      },
      get(i, u, l) {
        if (u === Wh)
          return e;
        var c = n.get(u), f = u in i;
        if (c === void 0 && (!f || Xh(i, u)?.writable) && (c = s(() => {
          var m = Di(f ? i[u] : Et), p = /* @__PURE__ */ no(m);
          return p;
        }), n.set(u, c)), c !== void 0) {
          var d = xm(c);
          return d === Et ? void 0 : d;
        }
        return Reflect.get(i, u, l);
      },
      getOwnPropertyDescriptor(i, u) {
        var l = Reflect.getOwnPropertyDescriptor(i, u);
        if (l && "value" in l) {
          var c = n.get(u);
          c && (l.value = xm(c));
        } else if (l === void 0) {
          var f = n.get(u), d = f?.v;
          if (f !== void 0 && d !== Et)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return l;
      },
      has(i, u) {
        if (u === Wh)
          return !0;
        var l = n.get(u), c = l !== void 0 && l.v !== Et || Reflect.has(i, u);
        if (l !== void 0 || en !== null && (!c || Xh(i, u)?.writable)) {
          l === void 0 && (l = s(() => {
            var d = c ? Di(i[u]) : Et, m = /* @__PURE__ */ no(d);
            return m;
          }), n.set(u, l));
          var f = xm(l);
          if (f === Et)
            return !1;
        }
        return c;
      },
      set(i, u, l, c) {
        var f = n.get(u), d = u in i;
        if (r && u === "length")
          for (var m = l; m < /** @type {Source<number>} */
          f.v; m += 1) {
            var p = n.get(m + "");
            p !== void 0 ? Ko(p, Et) : m in i && (p = s(() => /* @__PURE__ */ no(Et)), n.set(m + "", p));
          }
        if (f === void 0)
          (!d || Xh(i, u)?.writable) && (f = s(() => /* @__PURE__ */ no(void 0)), Ko(f, Di(l)), n.set(u, f));
        else {
          d = f.v !== Et;
          var b = s(() => Di(l));
          Ko(f, b);
        }
        var g = Reflect.getOwnPropertyDescriptor(i, u);
        if (g?.set && g.set.call(c, l), !d) {
          if (r && typeof u == "string") {
            var S = (
              /** @type {Source<number>} */
              n.get("length")
            ), D = Number(u);
            Number.isInteger(D) && D >= S.v && Ko(S, D + 1);
          }
          Jh(a);
        }
        return !0;
      },
      ownKeys(i) {
        xm(a);
        var u = Reflect.ownKeys(i).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== Et;
        });
        for (var [l, c] of n)
          c.v !== Et && !(l in i) && u.push(l);
        return u;
      },
      setPrototypeOf() {
        xbe();
      }
    }
  );
}
var zbe;
// @__NO_SIDE_EFFECTS__
function qbe(e) {
  return (
    /** @type {TemplateNode | null} */
    zbe.call(e)
  );
}
function bB(e) {
  var t = Ie, n = en;
  bu(null), Cp(null);
  try {
    return e();
  } finally {
    bu(t), Cp(n);
  }
}
function Gp() {
  return Ie !== null && !ns;
}
function gB(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = jf, r = Ie;
    c9(!0), bu(null);
    try {
      t.call(null);
    } finally {
      c9(n), bu(r);
    }
  }
}
function hB(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const a = n.ac;
    a !== null && bB(() => {
      a.abort(sB);
    });
    var r = n.next;
    (n.f & Yf) !== 0 ? n.parent = null : $T(n, t), n = r;
  }
}
function Qbe(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & xf) === 0 && $T(t), t = n;
  }
}
function $T(e, t = !0) {
  var n = !1;
  (t || (e.f & aB) !== 0) && e.nodes !== null && e.nodes.end !== null && (ege(
    e.nodes.start,
    /** @type {TemplateNode} */
    e.nodes.end
  ), n = !0), hB(e, t && !n), Kp(e, 0), tn(e, Ss);
  var r = e.nodes && e.nodes.t;
  if (r !== null)
    for (const o of r)
      o.stop();
  gB(e);
  var a = e.parent;
  a !== null && a.first !== null && yB(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes = e.ac = null;
}
function ege(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : /* @__PURE__ */ qbe(e);
    e.remove(), e = n;
  }
}
function yB(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
let Ds = !1;
function Mp(e) {
  Ds = e;
}
let jf = !1;
function c9(e) {
  jf = e;
}
let Ie = null, ns = !1;
function bu(e) {
  Ie = e;
}
let en = null;
function Cp(e) {
  en = e;
}
let Ka = null;
function tge(e) {
  Ie !== null && (Ka === null ? Ka = [e] : Ka.push(e));
}
let lt = null, In = 0, Rn = null;
function nge(e) {
  Rn = e;
}
let NB = 1, Ic = 0, ks = Ic;
function f9(e) {
  ks = e;
}
function EB() {
  return ++NB;
}
function Bf(e) {
  var t = e.f;
  if ((t & kr) !== 0)
    return !0;
  if (t & dn && (e.f &= ~Hs), (t & aa) !== 0) {
    var n = e.deps;
    if (n !== null)
      for (var r = n.length, a = 0; a < r; a++) {
        var o = n[a];
        if (Bf(
          /** @type {Derived} */
          o
        ) && mB(
          /** @type {Derived} */
          o
        ), o.wv > e.wv)
          return !0;
      }
    (t & ra) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Cn === null && tn(e, kt);
  }
  return !1;
}
function vB(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !Ka?.includes(e))
    for (var a = 0; a < r.length; a++) {
      var o = r[a];
      (o.f & dn) !== 0 ? vB(
        /** @type {Derived} */
        o,
        t,
        !1
      ) : t === o && (n ? tn(o, kr) : (o.f & kt) !== 0 && tn(o, aa), Tc(
        /** @type {Effect} */
        o
      ));
    }
}
function TB(e) {
  var t = lt, n = In, r = Rn, a = Ie, o = Ka, s = ns, i = ks, u = e.f;
  lt = /** @type {null | Value[]} */
  null, In = 0, Rn = null, Ie = (u & (xf | Yf)) === 0 ? e : null, Ka = null, e.ctx, ns = !1, ks = ++Ic, e.ac !== null && (bB(() => {
    e.ac.abort(sB);
  }), e.ac = null);
  try {
    e.f |= JN;
    var l = (
      /** @type {Function} */
      e.fn
    ), c = l(), f = e.deps;
    if (lt !== null) {
      var d;
      if (Kp(e, In), f !== null && In > 0)
        for (f.length = In + lt.length, d = 0; d < lt.length; d++)
          f[In + d] = lt[d];
      else
        e.deps = f = lt;
      if (Gp() && (e.f & ra) !== 0)
        for (d = In; d < f.length; d++)
          (f[d].reactions ??= []).push(e);
    } else f !== null && In < f.length && (Kp(e, In), f.length = In);
    if (iB() && Rn !== null && !ns && f !== null && (e.f & (dn | aa | kr)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      Rn.length; d++)
        vB(
          Rn[d],
          /** @type {Effect} */
          e
        );
    return a !== null && a !== e && (Ic++, Rn !== null && (r === null ? r = Rn : r.push(.../** @type {Source[]} */
    Rn))), (e.f & Ec) !== 0 && (e.f ^= Ec), c;
  } catch (m) {
    return Cbe(m);
  } finally {
    e.f ^= JN, lt = t, In = n, Rn = r, Ie = a, Ka = o, ns = s, ks = i;
  }
}
function rge(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = Sbe.call(n, e);
    if (r !== -1) {
      var a = n.length - 1;
      a === 0 ? n = t.reactions = null : (n[r] = n[a], n.pop());
    }
  }
  n === null && (t.f & dn) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (lt === null || !lt.includes(t)) && (tn(t, aa), (t.f & ra) !== 0 && (t.f ^= ra, t.f &= ~Hs), fB(
    /** @type {Derived} **/
    t
  ), Kp(
    /** @type {Derived} **/
    t,
    0
  ));
}
function Kp(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      rge(e, n[r]);
}
function Xp(e) {
  var t = e.f;
  if ((t & Ss) === 0) {
    tn(e, kt);
    var n = en, r = Ds;
    en = e, Ds = !0;
    try {
      (t & (Du | Rbe)) !== 0 ? Qbe(e) : hB(e), gB(e);
      var a = TB(e);
      e.teardown = typeof a == "function" ? a : null, e.wv = NB;
      var o;
      _be && Bbe && (e.f & kr) !== 0 && e.deps;
    } finally {
      Ds = r, en = n;
    }
  }
}
function xm(e) {
  var t = e.f, n = (t & dn) !== 0;
  if (Ie !== null && !ns) {
    var r = en !== null && (en.f & Ss) !== 0;
    if (!r && !Ka?.includes(e)) {
      var a = Ie.deps;
      if ((Ie.f & JN) !== 0)
        e.rv < Ic && (e.rv = Ic, lt === null && a !== null && a[In] === e ? In++ : lt === null ? lt = [e] : lt.includes(e) || lt.push(e));
      else {
        (Ie.deps ??= []).push(e);
        var o = e.reactions;
        o === null ? e.reactions = [Ie] : o.includes(Ie) || o.push(Ie);
      }
    }
  }
  if (jf) {
    if (bo.has(e))
      return bo.get(e);
    if (n) {
      var s = (
        /** @type {Derived} */
        e
      ), i = s.v;
      return ((s.f & kt) === 0 && s.reactions !== null || wB(s)) && (i = RT(s)), bo.set(s, i), i;
    }
  } else n && (!Cn?.has(e) || Qe?.is_fork && !Gp()) && (s = /** @type {Derived} */
  e, Bf(s) && mB(s), Ds && Gp() && (s.f & ra) === 0 && IB(s));
  if (Cn?.has(e))
    return Cn.get(e);
  if ((e.f & Ec) !== 0)
    throw e.v;
  return e.v;
}
function IB(e) {
  if (e.deps !== null) {
    e.f ^= ra;
    for (const t of e.deps)
      (t.reactions ??= []).push(e), (t.f & dn) !== 0 && (t.f & ra) === 0 && IB(
        /** @type {Derived} */
        t
      );
  }
}
function wB(e) {
  if (e.v === Et) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (bo.has(t) || (t.f & dn) !== 0 && wB(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
const age = -7169;
function tn(e, t) {
  e.f = e.f & age | t;
}
function _B() {
  return {
    isDark: document.documentElement.classList.contains("night-mode")
  };
}
const oge = Di(_B()), sge = new MutationObserver((e, t) => {
  oge.isDark = _B().isDark;
});
sge.observe(document.documentElement, { attributeFilter: ["class"] });
const ige = "5";
typeof window < "u" && ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(ige);
var K;
(function(e) {
  e[e.Canceled = 1] = "Canceled", e[e.Unknown = 2] = "Unknown", e[e.InvalidArgument = 3] = "InvalidArgument", e[e.DeadlineExceeded = 4] = "DeadlineExceeded", e[e.NotFound = 5] = "NotFound", e[e.AlreadyExists = 6] = "AlreadyExists", e[e.PermissionDenied = 7] = "PermissionDenied", e[e.ResourceExhausted = 8] = "ResourceExhausted", e[e.FailedPrecondition = 9] = "FailedPrecondition", e[e.Aborted = 10] = "Aborted", e[e.OutOfRange = 11] = "OutOfRange", e[e.Unimplemented = 12] = "Unimplemented", e[e.Internal = 13] = "Internal", e[e.Unavailable = 14] = "Unavailable", e[e.DataLoss = 15] = "DataLoss", e[e.Unauthenticated = 16] = "Unauthenticated";
})(K || (K = {}));
function PT(e, t) {
  return e !== null && typeof e == "object" && "$typeName" in e && typeof e.$typeName == "string" ? t === void 0 ? !0 : t.typeName === e.$typeName : !1;
}
var O;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(O || (O = {}));
function uge() {
  let e = 0, t = 0;
  for (let r = 0; r < 28; r += 7) {
    let a = this.buf[this.pos++];
    if (e |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  let n = this.buf[this.pos++];
  if (e |= (n & 15) << 28, t = (n & 112) >> 4, (n & 128) == 0)
    return this.assertBounds(), [e, t];
  for (let r = 3; r <= 31; r += 7) {
    let a = this.buf[this.pos++];
    if (t |= (a & 127) << r, (a & 128) == 0)
      return this.assertBounds(), [e, t];
  }
  throw new Error("invalid varint");
}
function Zh(e, t, n) {
  for (let o = 0; o < 28; o = o + 7) {
    const s = e >>> o, i = !(!(s >>> 7) && t == 0), u = (i ? s | 128 : s) & 255;
    if (n.push(u), !i)
      return;
  }
  const r = e >>> 28 & 15 | (t & 7) << 4, a = t >> 3 != 0;
  if (n.push((a ? r | 128 : r) & 255), !!a) {
    for (let o = 3; o < 31; o = o + 7) {
      const s = t >>> o, i = !!(s >>> 7), u = (i ? s | 128 : s) & 255;
      if (n.push(u), !i)
        return;
    }
    n.push(t >>> 31 & 1);
  }
}
const gd = 4294967296;
function m9(e) {
  const t = e[0] === "-";
  t && (e = e.slice(1));
  const n = 1e6;
  let r = 0, a = 0;
  function o(s, i) {
    const u = Number(e.slice(s, i));
    a *= n, r = r * n + u, r >= gd && (a = a + (r / gd | 0), r = r % gd);
  }
  return o(-24, -18), o(-18, -12), o(-12, -6), o(-6), t ? SB(r, a) : VT(r, a);
}
function lge(e, t) {
  let n = VT(e, t);
  const r = n.hi & 2147483648;
  r && (n = SB(n.lo, n.hi));
  const a = OB(n.lo, n.hi);
  return r ? "-" + a : a;
}
function OB(e, t) {
  if ({ lo: e, hi: t } = cge(e, t), t <= 2097151)
    return String(gd * t + e);
  const n = e & 16777215, r = (e >>> 24 | t << 8) & 16777215, a = t >> 16 & 65535;
  let o = n + r * 6777216 + a * 6710656, s = r + a * 8147497, i = a * 2;
  const u = 1e7;
  return o >= u && (s += Math.floor(o / u), o %= u), s >= u && (i += Math.floor(s / u), s %= u), i.toString() + d9(s) + d9(o);
}
function cge(e, t) {
  return { lo: e >>> 0, hi: t >>> 0 };
}
function VT(e, t) {
  return { lo: e | 0, hi: t | 0 };
}
function SB(e, t) {
  return t = ~t, e ? e = ~e + 1 : t += 1, VT(e, t);
}
const d9 = (e) => {
  const t = String(e);
  return "0000000".slice(t.length) + t;
};
function zN(e, t) {
  if (e >= 0) {
    for (; e > 127; )
      t.push(e & 127 | 128), e = e >>> 7;
    t.push(e);
  } else {
    for (let n = 0; n < 9; n++)
      t.push(e & 127 | 128), e = e >> 7;
    t.push(1);
  }
}
function fge() {
  let e = this.buf[this.pos++], t = e & 127;
  if ((e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 7, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 14, (e & 128) == 0)
    return this.assertBounds(), t;
  if (e = this.buf[this.pos++], t |= (e & 127) << 21, (e & 128) == 0)
    return this.assertBounds(), t;
  e = this.buf[this.pos++], t |= (e & 15) << 28;
  for (let n = 5; (e & 128) !== 0 && n < 10; n++)
    e = this.buf[this.pos++];
  if ((e & 128) != 0)
    throw new Error("invalid varint");
  return this.assertBounds(), t >>> 0;
}
const te = /* @__PURE__ */ mge();
function mge() {
  const e = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof e.getBigInt64 == "function" && typeof e.getBigUint64 == "function" && typeof e.setBigInt64 == "function" && typeof e.setBigUint64 == "function" && (globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const t = BigInt("-9223372036854775808"), n = BigInt("9223372036854775807"), r = BigInt("0"), a = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > n || s < t)
          throw new Error(`invalid int64: ${o}`);
        return s;
      },
      uParse(o) {
        const s = typeof o == "bigint" ? o : BigInt(o);
        if (s > a || s < r)
          throw new Error(`invalid uint64: ${o}`);
        return s;
      },
      enc(o) {
        return e.setBigInt64(0, this.parse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      uEnc(o) {
        return e.setBigInt64(0, this.uParse(o), !0), {
          lo: e.getInt32(0, !0),
          hi: e.getInt32(4, !0)
        };
      },
      dec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigInt64(0, !0);
      },
      uDec(o, s) {
        return e.setInt32(0, o, !0), e.setInt32(4, s, !0), e.getBigUint64(0, !0);
      }
    };
  }
  return {
    zero: "0",
    supported: !1,
    parse(t) {
      return typeof t != "string" && (t = t.toString()), p9(t), t;
    },
    uParse(t) {
      return typeof t != "string" && (t = t.toString()), b9(t), t;
    },
    enc(t) {
      return typeof t != "string" && (t = t.toString()), p9(t), m9(t);
    },
    uEnc(t) {
      return typeof t != "string" && (t = t.toString()), b9(t), m9(t);
    },
    dec(t, n) {
      return lge(t, n);
    },
    uDec(t, n) {
      return OB(t, n);
    }
  };
}
function p9(e) {
  if (!/^-?[0-9]+$/.test(e))
    throw new Error("invalid int64: " + e);
}
function b9(e) {
  if (!/^[0-9]+$/.test(e))
    throw new Error("invalid uint64: " + e);
}
function zs(e, t) {
  switch (e) {
    case O.STRING:
      return "";
    case O.BOOL:
      return !1;
    case O.DOUBLE:
    case O.FLOAT:
      return 0;
    case O.INT64:
    case O.UINT64:
    case O.SFIXED64:
    case O.FIXED64:
    case O.SINT64:
      return t ? "0" : te.zero;
    case O.BYTES:
      return new Uint8Array(0);
    default:
      return 0;
  }
}
function dge(e, t) {
  switch (e) {
    case O.BOOL:
      return t === !1;
    case O.STRING:
      return t === "";
    case O.BYTES:
      return t instanceof Uint8Array && !t.byteLength;
    default:
      return t == 0;
  }
}
const DB = 2, Pa = /* @__PURE__ */ Symbol.for("reflect unsafe local");
function kB(e, t) {
  const n = e[t.localName].case;
  return n === void 0 ? n : t.fields.find((r) => r.localName === n);
}
function pge(e, t) {
  const n = t.localName;
  if (t.oneof)
    return e[t.oneof.localName].case === n;
  if (t.presence != DB)
    return e[n] !== void 0 && Object.prototype.hasOwnProperty.call(e, n);
  switch (t.fieldKind) {
    case "list":
      return e[n].length > 0;
    case "map":
      return Object.keys(e[n]).length > 0;
    case "scalar":
      return !dge(t.scalar, e[n]);
    case "enum":
      return e[n] !== t.enum.values[0].number;
  }
  throw new Error("message field with implicit presence");
}
function wc(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t) && e[t] !== void 0;
}
function AB(e, t) {
  if (t.oneof) {
    const n = e[t.oneof.localName];
    return n.case === t.localName ? n.value : void 0;
  }
  return e[t.localName];
}
function LB(e, t, n) {
  t.oneof ? e[t.oneof.localName] = {
    case: t.localName,
    value: n
  } : e[t.localName] = n;
}
function bge(e, t) {
  const n = t.localName;
  if (t.oneof) {
    const r = t.oneof.localName;
    e[r].case === n && (e[r] = { case: void 0 });
  } else if (t.presence != DB)
    delete e[n];
  else
    switch (t.fieldKind) {
      case "map":
        e[n] = {};
        break;
      case "list":
        e[n] = [];
        break;
      case "enum":
        e[n] = t.enum.values[0].number;
        break;
      case "scalar":
        e[n] = zs(t.scalar, t.longAsString);
        break;
    }
}
function So(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function xT(e, t) {
  var n, r, a, o;
  if (So(e) && Pa in e && "add" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.listKind == i.listKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function YT(e, t) {
  var n, r, a, o;
  if (So(e) && Pa in e && "has" in e && "field" in e && typeof e.field == "function") {
    if (t !== void 0) {
      const s = t, i = e.field();
      return s.mapKey === i.mapKey && s.mapKind == i.mapKind && s.scalar === i.scalar && ((n = s.message) === null || n === void 0 ? void 0 : n.typeName) === ((r = i.message) === null || r === void 0 ? void 0 : r.typeName) && ((a = s.enum) === null || a === void 0 ? void 0 : a.typeName) === ((o = i.enum) === null || o === void 0 ? void 0 : o.typeName);
    }
    return !0;
  }
  return !1;
}
function jT(e, t) {
  return So(e) && Pa in e && "desc" in e && So(e.desc) && e.desc.kind === "message" && (t === void 0 || e.desc.typeName == t.typeName);
}
function gge(e) {
  return FB(e.$typeName);
}
function Gf(e) {
  const t = e.fields[0];
  return FB(e.typeName) && t !== void 0 && t.fieldKind == "scalar" && t.name == "value" && t.number == 1;
}
function FB(e) {
  return e.startsWith("google.protobuf.") && [
    "DoubleValue",
    "FloatValue",
    "Int64Value",
    "UInt64Value",
    "Int32Value",
    "UInt32Value",
    "BoolValue",
    "StringValue",
    "BytesValue"
  ].includes(e.substring(16));
}
const hge = 999, yge = 998, hd = 2;
function Ar(e, t) {
  if (PT(t, e))
    return t;
  const n = Ige(e);
  return t !== void 0 && Nge(e, n, t), n;
}
function Nge(e, t, n) {
  for (const r of e.members) {
    let a = n[r.localName];
    if (a == null)
      continue;
    let o;
    if (r.kind == "oneof") {
      const s = kB(n, r);
      if (!s)
        continue;
      o = s, a = AB(n, s);
    } else
      o = r;
    switch (o.fieldKind) {
      case "message":
        a = BT(o, a);
        break;
      case "scalar":
        a = UB(o, a);
        break;
      case "list":
        a = vge(o, a);
        break;
      case "map":
        a = Ege(o, a);
        break;
    }
    LB(t, o, a);
  }
  return t;
}
function UB(e, t) {
  return e.scalar == O.BYTES ? GT(t) : t;
}
function Ege(e, t) {
  if (So(t)) {
    if (e.scalar == O.BYTES)
      return g9(t, GT);
    if (e.mapKind == "message")
      return g9(t, (n) => BT(e, n));
  }
  return t;
}
function vge(e, t) {
  if (Array.isArray(t)) {
    if (e.scalar == O.BYTES)
      return t.map(GT);
    if (e.listKind == "message")
      return t.map((n) => BT(e, n));
  }
  return t;
}
function BT(e, t) {
  if (e.fieldKind == "message" && !e.oneof && Gf(e.message))
    return UB(e.message.fields[0], t);
  if (So(t)) {
    if (e.message.typeName == "google.protobuf.Struct" && e.parent.typeName !== "google.protobuf.Value")
      return t;
    if (!PT(t, e.message))
      return Ar(e.message, t);
  }
  return t;
}
function GT(e) {
  return Array.isArray(e) ? new Uint8Array(e) : e;
}
function g9(e, t) {
  const n = {};
  for (const r of Object.entries(e))
    n[r[0]] = t(r[1]);
  return n;
}
const Tge = /* @__PURE__ */ Symbol(), h9 = /* @__PURE__ */ new WeakMap();
function Ige(e) {
  let t;
  if (wge(e)) {
    const n = h9.get(e);
    let r, a;
    if (n)
      ({ prototype: r, members: a } = n);
    else {
      r = {}, a = /* @__PURE__ */ new Set();
      for (const o of e.members)
        o.kind != "oneof" && (o.fieldKind != "scalar" && o.fieldKind != "enum" || o.presence != hd && (a.add(o), r[o.localName] = Hh(o)));
      h9.set(e, { prototype: r, members: a });
    }
    t = Object.create(r), t.$typeName = e.typeName;
    for (const o of e.members)
      a.has(o) || o.kind == "field" && (o.fieldKind == "message" || (o.fieldKind == "scalar" || o.fieldKind == "enum") && o.presence != hd) || (t[o.localName] = Hh(o));
  } else {
    t = {
      $typeName: e.typeName
    };
    for (const n of e.members)
      (n.kind == "oneof" || n.presence == hd) && (t[n.localName] = Hh(n));
  }
  return t;
}
function wge(e) {
  switch (e.file.edition) {
    case hge:
      return !1;
    case yge:
      return !0;
    default:
      return e.fields.some((t) => t.presence != hd && t.fieldKind != "message" && !t.oneof);
  }
}
function Hh(e) {
  if (e.kind == "oneof")
    return { case: void 0 };
  if (e.fieldKind == "list")
    return [];
  if (e.fieldKind == "map")
    return {};
  if (e.fieldKind == "message")
    return Tge;
  const t = e.getDefaultValue();
  return t !== void 0 ? e.fieldKind == "scalar" && e.longAsString ? t.toString() : t : e.fieldKind == "scalar" ? zs(e.scalar, e.longAsString) : e.enum.values[0].number;
}
const _ge = [
  "FieldValueInvalidError",
  "FieldListRangeError",
  "ForeignFieldError"
];
class nn extends Error {
  constructor(t, n, r = "FieldValueInvalidError") {
    super(n), this.name = r, this.field = () => t;
  }
}
function Oge(e) {
  return e instanceof Error && _ge.includes(e.name) && "field" in e && typeof e.field == "function";
}
const zh = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
function MT() {
  if (globalThis[zh] == null) {
    const e = new globalThis.TextEncoder(), t = new globalThis.TextDecoder();
    globalThis[zh] = {
      encodeUtf8(n) {
        return e.encode(n);
      },
      decodeUtf8(n) {
        return t.decode(n);
      },
      checkUtf8(n) {
        try {
          return encodeURIComponent(n), !0;
        } catch {
          return !1;
        }
      }
    };
  }
  return globalThis[zh];
}
var de;
(function(e) {
  e[e.Varint = 0] = "Varint", e[e.Bit64 = 1] = "Bit64", e[e.LengthDelimited = 2] = "LengthDelimited", e[e.StartGroup = 3] = "StartGroup", e[e.EndGroup = 4] = "EndGroup", e[e.Bit32 = 5] = "Bit32";
})(de || (de = {}));
const RB = 34028234663852886e22, $B = -34028234663852886e22, PB = 4294967295, VB = 2147483647, xB = -2147483648;
class YB {
  constructor(t = MT().encodeUtf8) {
    this.encodeUtf8 = t, this.stack = [], this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []);
    let t = 0;
    for (let a = 0; a < this.chunks.length; a++)
      t += this.chunks[a].length;
    let n = new Uint8Array(t), r = 0;
    for (let a = 0; a < this.chunks.length; a++)
      n.set(this.chunks[a], r), r += this.chunks[a].length;
    return this.chunks = [], n;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let t = this.finish(), n = this.stack.pop();
    if (!n)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = n.chunks, this.buf = n.buf, this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(t, n) {
    return this.uint32((t << 3 | n) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(t) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(t), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(t) {
    for (y9(t); t > 127; )
      this.buf.push(t & 127 | 128), t = t >>> 7;
    return this.buf.push(t), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(t) {
    return qh(t), zN(t, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(t) {
    return this.buf.push(t ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(t) {
    return this.uint32(t.byteLength), this.raw(t);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(t) {
    let n = this.encodeUtf8(t);
    return this.uint32(n.byteLength), this.raw(n);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(t) {
    Sge(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setFloat32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(t) {
    let n = new Uint8Array(8);
    return new DataView(n.buffer).setFloat64(0, t, !0), this.raw(n);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(t) {
    y9(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setUint32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(t) {
    qh(t);
    let n = new Uint8Array(4);
    return new DataView(n.buffer).setInt32(0, t, !0), this.raw(n);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(t) {
    return qh(t), t = (t << 1 ^ t >> 31) >>> 0, zN(t, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = te.enc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(t) {
    let n = new Uint8Array(8), r = new DataView(n.buffer), a = te.uEnc(t);
    return r.setInt32(0, a.lo, !0), r.setInt32(4, a.hi, !0), this.raw(n);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(t) {
    let n = te.enc(t);
    return Zh(n.lo, n.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(t) {
    const n = te.enc(t), r = n.hi >> 31, a = n.lo << 1 ^ r, o = (n.hi << 1 | n.lo >>> 31) ^ r;
    return Zh(a, o, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(t) {
    const n = te.uEnc(t);
    return Zh(n.lo, n.hi, this.buf), this;
  }
}
class CT {
  constructor(t, n = MT().decodeUtf8) {
    this.decodeUtf8 = n, this.varint64 = uge, this.uint32 = fge, this.buf = t, this.len = t.length, this.pos = 0, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let t = this.uint32(), n = t >>> 3, r = t & 7;
    if (n <= 0 || r < 0 || r > 5)
      throw new Error("illegal tag: field no " + n + " wire type " + r);
    return [n, r];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(t, n) {
    let r = this.pos;
    switch (t) {
      case de.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case de.Bit64:
        this.pos += 4;
      case de.Bit32:
        this.pos += 4;
        break;
      case de.LengthDelimited:
        let a = this.uint32();
        this.pos += a;
        break;
      case de.StartGroup:
        for (; ; ) {
          const [o, s] = this.tag();
          if (s === de.EndGroup) {
            if (n !== void 0 && o !== n)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip(s, o);
        }
        break;
      default:
        throw new Error("cant skip wire type " + t);
    }
    return this.assertBounds(), this.buf.subarray(r, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let t = this.uint32();
    return t >>> 1 ^ -(t & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return te.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return te.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [t, n] = this.varint64(), r = -(t & 1);
    return t = (t >>> 1 | (n & 1) << 31) ^ r, n = n >>> 1 ^ r, te.dec(t, n);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [t, n] = this.varint64();
    return t !== 0 || n !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return te.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return te.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let t = this.uint32(), n = this.pos;
    return this.pos += t, this.assertBounds(), this.buf.subarray(n, n + t);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
}
function qh(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid int32: " + typeof e);
  if (!Number.isInteger(e) || e > VB || e < xB)
    throw new Error("invalid int32: " + e);
}
function y9(e) {
  if (typeof e == "string")
    e = Number(e);
  else if (typeof e != "number")
    throw new Error("invalid uint32: " + typeof e);
  if (!Number.isInteger(e) || e > PB || e < 0)
    throw new Error("invalid uint32: " + e);
}
function Sge(e) {
  if (typeof e == "string") {
    const t = e;
    if (e = Number(e), Number.isNaN(e) && t !== "NaN")
      throw new Error("invalid float32: " + t);
  } else if (typeof e != "number")
    throw new Error("invalid float32: " + typeof e);
  if (Number.isFinite(e) && (e > RB || e < $B))
    throw new Error("invalid float32: " + e);
}
function Xo(e, t) {
  const n = e.fieldKind == "list" ? xT(t, e) : e.fieldKind == "map" ? YT(t, e) : KT(e, t);
  if (n === !0)
    return;
  let r;
  switch (e.fieldKind) {
    case "list":
      r = `expected ${GB(e)}, got ${Me(t)}`;
      break;
    case "map":
      r = `expected ${MB(e)}, got ${Me(t)}`;
      break;
    default:
      r = Wp(e, t, n);
  }
  return new nn(e, r);
}
function N9(e, t, n) {
  const r = KT(e, n);
  if (r !== !0)
    return new nn(e, `list item #${t + 1}: ${Wp(e, n, r)}`);
}
function Dge(e, t, n) {
  const r = jB(t, e.mapKey);
  if (r !== !0)
    return new nn(e, `invalid map key: ${Wp({ scalar: e.mapKey }, t, r)}`);
  const a = KT(e, n);
  if (a !== !0)
    return new nn(e, `map entry ${Me(t)}: ${Wp(e, n, a)}`);
}
function KT(e, t) {
  return e.scalar !== void 0 ? jB(t, e.scalar) : e.enum !== void 0 ? e.enum.open ? Number.isInteger(t) : e.enum.values.some((n) => n.number === t) : jT(t, e.message);
}
function jB(e, t) {
  switch (t) {
    case O.DOUBLE:
      return typeof e == "number";
    case O.FLOAT:
      return typeof e != "number" ? !1 : Number.isNaN(e) || !Number.isFinite(e) ? !0 : e > RB || e < $B ? `${e.toFixed()} out of range` : !0;
    case O.INT32:
    case O.SFIXED32:
    case O.SINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > VB || e < xB ? `${e.toFixed()} out of range` : !0;
    case O.FIXED32:
    case O.UINT32:
      return typeof e != "number" || !Number.isInteger(e) ? !1 : e > PB || e < 0 ? `${e.toFixed()} out of range` : !0;
    case O.BOOL:
      return typeof e == "boolean";
    case O.STRING:
      return typeof e != "string" ? !1 : MT().checkUtf8(e) || "invalid UTF8";
    case O.BYTES:
      return e instanceof Uint8Array;
    case O.INT64:
    case O.SFIXED64:
    case O.SINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return te.parse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
    case O.FIXED64:
    case O.UINT64:
      if (typeof e == "bigint" || typeof e == "number" || typeof e == "string" && e.length > 0)
        try {
          return te.uParse(e), !0;
        } catch {
          return `${e} out of range`;
        }
      return !1;
  }
}
function Wp(e, t, n) {
  return n = typeof n == "string" ? `: ${n}` : `, got ${Me(t)}`, e.scalar !== void 0 ? `expected ${kge(e.scalar)}` + n : e.enum !== void 0 ? `expected ${e.enum.toString()}` + n : `expected ${BB(e.message)}` + n;
}
function Me(e) {
  switch (typeof e) {
    case "object":
      return e === null ? "null" : e instanceof Uint8Array ? `Uint8Array(${e.length})` : Array.isArray(e) ? `Array(${e.length})` : xT(e) ? GB(e.field()) : YT(e) ? MB(e.field()) : jT(e) ? BB(e.desc) : PT(e) ? `message ${e.$typeName}` : "object";
    case "string":
      return e.length > 30 ? "string" : `"${e.split('"').join('\\"')}"`;
    case "boolean":
      return String(e);
    case "number":
      return String(e);
    case "bigint":
      return String(e) + "n";
    default:
      return typeof e;
  }
}
function BB(e) {
  return `ReflectMessage (${e.typeName})`;
}
function GB(e) {
  switch (e.listKind) {
    case "message":
      return `ReflectList (${e.message.toString()})`;
    case "enum":
      return `ReflectList (${e.enum.toString()})`;
    case "scalar":
      return `ReflectList (${O[e.scalar]})`;
  }
}
function MB(e) {
  switch (e.mapKind) {
    case "message":
      return `ReflectMap (${O[e.mapKey]}, ${e.message.toString()})`;
    case "enum":
      return `ReflectMap (${O[e.mapKey]}, ${e.enum.toString()})`;
    case "scalar":
      return `ReflectMap (${O[e.mapKey]}, ${O[e.scalar]})`;
  }
}
function kge(e) {
  switch (e) {
    case O.STRING:
      return "string";
    case O.BOOL:
      return "boolean";
    case O.INT64:
    case O.SINT64:
    case O.SFIXED64:
      return "bigint (int64)";
    case O.UINT64:
    case O.FIXED64:
      return "bigint (uint64)";
    case O.BYTES:
      return "Uint8Array";
    case O.DOUBLE:
      return "number (float64)";
    case O.FLOAT:
      return "number (float32)";
    case O.FIXED32:
    case O.UINT32:
      return "number (uint32)";
    case O.INT32:
    case O.SFIXED32:
    case O.SINT32:
      return "number (int32)";
  }
}
function tr(e, t, n = !0) {
  return new CB(e, t, n);
}
const E9 = /* @__PURE__ */ new WeakMap();
class CB {
  get sortedFields() {
    const t = E9.get(this.desc);
    if (t)
      return t;
    const n = this.desc.fields.concat().sort((r, a) => r.number - a.number);
    return E9.set(this.desc, n), n;
  }
  constructor(t, n, r = !0) {
    this.lists = /* @__PURE__ */ new Map(), this.maps = /* @__PURE__ */ new Map(), this.check = r, this.desc = t, this.message = this[Pa] = n ?? Ar(t), this.fields = t.fields, this.oneofs = t.oneofs, this.members = t.members;
  }
  findNumber(t) {
    return this._fieldsByNumber || (this._fieldsByNumber = new Map(this.desc.fields.map((n) => [n.number, n]))), this._fieldsByNumber.get(t);
  }
  oneofCase(t) {
    return Yu(this.message, t), kB(this.message, t);
  }
  isSet(t) {
    return Yu(this.message, t), pge(this.message, t);
  }
  clear(t) {
    Yu(this.message, t), bge(this.message, t);
  }
  get(t) {
    Yu(this.message, t);
    const n = AB(this.message, t);
    switch (t.fieldKind) {
      case "list":
        let r = this.lists.get(t);
        return (!r || r[Pa] !== n) && this.lists.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          r = new Age(t, n, this.check)
        ), r;
      case "map":
        let a = this.maps.get(t);
        return (!a || a[Pa] !== n) && this.maps.set(
          t,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = new Lge(t, n, this.check)
        ), a;
      case "message":
        return WT(t, n, this.check);
      case "scalar":
        return n === void 0 ? zs(t.scalar, !1) : JT(t, n);
      case "enum":
        return n ?? t.enum.values[0].number;
    }
  }
  set(t, n) {
    if (Yu(this.message, t), this.check) {
      const a = Xo(t, n);
      if (a)
        throw a;
    }
    let r;
    t.fieldKind == "message" ? r = XT(t, n) : YT(n) || xT(n) ? r = n[Pa] : r = ZT(t, n), LB(this.message, t, r);
  }
  getUnknown() {
    return this.message.$unknown;
  }
  setUnknown(t) {
    this.message.$unknown = t;
  }
}
function Yu(e, t) {
  if (t.parent.typeName !== e.$typeName)
    throw new nn(t, `cannot use ${t.toString()} with message ${e.$typeName}`, "ForeignFieldError");
}
class Age {
  field() {
    return this._field;
  }
  get size() {
    return this._arr.length;
  }
  constructor(t, n, r) {
    this._field = t, this._arr = this[Pa] = n, this.check = r;
  }
  get(t) {
    const n = this._arr[t];
    return n === void 0 ? void 0 : Qh(this._field, n, this.check);
  }
  set(t, n) {
    if (t < 0 || t >= this._arr.length)
      throw new nn(this._field, `list item #${t + 1}: out of range`);
    if (this.check) {
      const r = N9(this._field, t, n);
      if (r)
        throw r;
    }
    this._arr[t] = v9(this._field, n);
  }
  add(t) {
    if (this.check) {
      const n = N9(this._field, this._arr.length, t);
      if (n)
        throw n;
    }
    this._arr.push(v9(this._field, t));
  }
  clear() {
    this._arr.splice(0, this._arr.length);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  keys() {
    return this._arr.keys();
  }
  *values() {
    for (const t of this._arr)
      yield Qh(this._field, t, this.check);
  }
  *entries() {
    for (let t = 0; t < this._arr.length; t++)
      yield [t, Qh(this._field, this._arr[t], this.check)];
  }
}
class Lge {
  constructor(t, n, r = !0) {
    this.obj = this[Pa] = n ?? {}, this.check = r, this._field = t;
  }
  field() {
    return this._field;
  }
  set(t, n) {
    if (this.check) {
      const r = Dge(this._field, t, n);
      if (r)
        throw r;
    }
    return this.obj[Ym(t)] = Fge(this._field, n), this;
  }
  delete(t) {
    const n = Ym(t), r = Object.prototype.hasOwnProperty.call(this.obj, n);
    return r && delete this.obj[n], r;
  }
  clear() {
    for (const t of Object.keys(this.obj))
      delete this.obj[t];
  }
  get(t) {
    let n = this.obj[Ym(t)];
    return n !== void 0 && (n = ey(this._field, n, this.check)), n;
  }
  has(t) {
    return Object.prototype.hasOwnProperty.call(this.obj, Ym(t));
  }
  *keys() {
    for (const t of Object.keys(this.obj))
      yield T9(t, this._field.mapKey);
  }
  *entries() {
    for (const t of Object.entries(this.obj))
      yield [
        T9(t[0], this._field.mapKey),
        ey(this._field, t[1], this.check)
      ];
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    return Object.keys(this.obj).length;
  }
  *values() {
    for (const t of Object.values(this.obj))
      yield ey(this._field, t, this.check);
  }
  forEach(t, n) {
    for (const r of this.entries())
      t.call(n, r[1], r[0], this);
  }
}
function XT(e, t) {
  return jT(t) ? gge(t.message) && !e.oneof && e.fieldKind == "message" ? t.message.value : t.desc.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" ? XB(t.message) : t.message : t;
}
function WT(e, t, n) {
  return t !== void 0 && (Gf(e.message) && !e.oneof && e.fieldKind == "message" ? t = {
    $typeName: e.message.typeName,
    value: JT(e.message.fields[0], t)
  } : e.message.typeName == "google.protobuf.Struct" && e.parent.typeName != "google.protobuf.Value" && So(t) && (t = KB(t))), new CB(e.message, t, n);
}
function v9(e, t) {
  return e.listKind == "message" ? XT(e, t) : ZT(e, t);
}
function Qh(e, t, n) {
  return e.listKind == "message" ? WT(e, t, n) : JT(e, t);
}
function Fge(e, t) {
  return e.mapKind == "message" ? XT(e, t) : ZT(e, t);
}
function ey(e, t, n) {
  return e.mapKind == "message" ? WT(e, t, n) : t;
}
function Ym(e) {
  return typeof e == "string" || typeof e == "number" ? e : String(e);
}
function T9(e, t) {
  switch (t) {
    case O.STRING:
      return e;
    case O.INT32:
    case O.FIXED32:
    case O.UINT32:
    case O.SFIXED32:
    case O.SINT32: {
      const n = Number.parseInt(e);
      if (Number.isFinite(n))
        return n;
      break;
    }
    case O.BOOL:
      switch (e) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      break;
    case O.UINT64:
    case O.FIXED64:
      try {
        return te.uParse(e);
      } catch {
      }
      break;
    default:
      try {
        return te.parse(e);
      } catch {
      }
      break;
  }
  return e;
}
function JT(e, t) {
  switch (e.scalar) {
    case O.INT64:
    case O.SFIXED64:
    case O.SINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = te.parse(t));
      break;
    case O.FIXED64:
    case O.UINT64:
      "longAsString" in e && e.longAsString && typeof t == "string" && (t = te.uParse(t));
      break;
  }
  return t;
}
function ZT(e, t) {
  switch (e.scalar) {
    case O.INT64:
    case O.SFIXED64:
    case O.SINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = te.parse(t));
      break;
    case O.FIXED64:
    case O.UINT64:
      "longAsString" in e && e.longAsString ? t = String(t) : (typeof t == "string" || typeof t == "number") && (t = te.uParse(t));
      break;
  }
  return t;
}
function KB(e) {
  const t = {
    $typeName: "google.protobuf.Struct",
    fields: {}
  };
  if (So(e))
    for (const [n, r] of Object.entries(e))
      t.fields[n] = JB(r);
  return t;
}
function XB(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = WB(r);
  return t;
}
function WB(e) {
  switch (e.kind.case) {
    case "structValue":
      return XB(e.kind.value);
    case "listValue":
      return e.kind.value.values.map(WB);
    case "nullValue":
    case void 0:
      return null;
    default:
      return e.kind.value;
  }
}
function JB(e) {
  const t = {
    $typeName: "google.protobuf.Value",
    kind: { case: void 0 }
  };
  switch (typeof e) {
    case "number":
      t.kind = { case: "numberValue", value: e };
      break;
    case "string":
      t.kind = { case: "stringValue", value: e };
      break;
    case "boolean":
      t.kind = { case: "boolValue", value: e };
      break;
    case "object":
      if (e === null)
        t.kind = { case: "nullValue", value: 0 };
      else if (Array.isArray(e)) {
        const n = {
          $typeName: "google.protobuf.ListValue",
          values: []
        };
        if (Array.isArray(e))
          for (const r of e)
            n.values.push(JB(r));
        t.kind = {
          case: "listValue",
          value: n
        };
      } else
        t.kind = {
          case: "structValue",
          value: KB(e)
        };
      break;
  }
  return t;
}
function HT(e) {
  const t = Uge();
  let n = e.length * 3 / 4;
  e[e.length - 2] == "=" ? n -= 2 : e[e.length - 1] == "=" && (n -= 1);
  let r = new Uint8Array(n), a = 0, o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++) {
    if (s = t[e.charCodeAt(u)], s === void 0)
      switch (e[u]) {
        // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
        case "=":
          o = 0;
        // reset state when padding found
        case `
`:
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error("invalid base64 string");
      }
    switch (o) {
      case 0:
        i = s, o = 1;
        break;
      case 1:
        r[a++] = i << 2 | (s & 48) >> 4, i = s, o = 2;
        break;
      case 2:
        r[a++] = (i & 15) << 4 | (s & 60) >> 2, i = s, o = 3;
        break;
      case 3:
        r[a++] = (i & 3) << 6 | s, o = 0;
        break;
    }
  }
  if (o == 1)
    throw Error("invalid base64 string");
  return r.subarray(0, a);
}
function ZB(e, t = "std") {
  const n = HB(t), r = t == "std";
  let a = "", o = 0, s, i = 0;
  for (let u = 0; u < e.length; u++)
    switch (s = e[u], o) {
      case 0:
        a += n[s >> 2], i = (s & 3) << 4, o = 1;
        break;
      case 1:
        a += n[i | s >> 4], i = (s & 15) << 2, o = 2;
        break;
      case 2:
        a += n[i | s >> 6], a += n[s & 63], o = 0;
        break;
    }
  return o && (a += n[i], r && (a += "=", o == 1 && (a += "="))), a;
}
let jm, I9, li;
function HB(e) {
  return jm || (jm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), I9 = jm.slice(0, -2).concat("-", "_")), e == "url" ? (
    // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
    I9
  ) : jm;
}
function Uge() {
  if (!li) {
    li = [];
    const e = HB("std");
    for (let t = 0; t < e.length; t++)
      li[e[t].charCodeAt(0)] = t;
    li[45] = e.indexOf("+"), li[95] = e.indexOf("/");
  }
  return li;
}
function _c(e) {
  let t = !1;
  const n = [];
  for (let r = 0; r < e.length; r++) {
    let a = e.charAt(r);
    switch (a) {
      case "_":
        t = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        n.push(a), t = !1;
        break;
      default:
        t && (t = !1, a = a.toUpperCase()), n.push(a);
        break;
    }
  }
  return n.join("");
}
const Rge = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
function Oc(e) {
  return Rge.has(e) ? e + "$" : e;
}
function zT(e) {
  for (const t of e.field)
    wc(t, "jsonName") || (t.jsonName = _c(t.name));
  e.nestedType.forEach(zT);
}
function $ge(e, t) {
  const n = e.values.find((r) => r.name === t);
  if (!n)
    throw new Error(`cannot parse ${e} default value: ${t}`);
  return n.number;
}
function Pge(e, t) {
  switch (e) {
    case O.STRING:
      return t;
    case O.BYTES: {
      const n = Vge(t);
      if (n === !1)
        throw new Error(`cannot parse ${O[e]} default value: ${t}`);
      return n;
    }
    case O.INT64:
    case O.SFIXED64:
    case O.SINT64:
      return te.parse(t);
    case O.UINT64:
    case O.FIXED64:
      return te.uParse(t);
    case O.DOUBLE:
    case O.FLOAT:
      switch (t) {
        case "inf":
          return Number.POSITIVE_INFINITY;
        case "-inf":
          return Number.NEGATIVE_INFINITY;
        case "nan":
          return Number.NaN;
        default:
          return parseFloat(t);
      }
    case O.BOOL:
      return t === "true";
    case O.INT32:
    case O.UINT32:
    case O.SINT32:
    case O.FIXED32:
    case O.SFIXED32:
      return parseInt(t, 10);
  }
}
function Vge(e) {
  const t = [], n = {
    tail: e,
    c: "",
    next() {
      return this.tail.length == 0 ? !1 : (this.c = this.tail[0], this.tail = this.tail.substring(1), !0);
    },
    take(r) {
      if (this.tail.length >= r) {
        const a = this.tail.substring(0, r);
        return this.tail = this.tail.substring(r), a;
      }
      return !1;
    }
  };
  for (; n.next(); )
    switch (n.c) {
      case "\\":
        if (n.next())
          switch (n.c) {
            case "\\":
              t.push(n.c.charCodeAt(0));
              break;
            case "b":
              t.push(8);
              break;
            case "f":
              t.push(12);
              break;
            case "n":
              t.push(10);
              break;
            case "r":
              t.push(13);
              break;
            case "t":
              t.push(9);
              break;
            case "v":
              t.push(11);
              break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 8);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "x": {
              const r = n.c, a = n.take(2);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              t.push(o);
              break;
            }
            case "u": {
              const r = n.c, a = n.take(4);
              if (a === !1)
                return !1;
              const o = parseInt(r + a, 16);
              if (Number.isNaN(o))
                return !1;
              const s = new Uint8Array(4);
              new DataView(s.buffer).setInt32(0, o, !0), t.push(s[0], s[1], s[2], s[3]);
              break;
            }
            case "U": {
              const r = n.c, a = n.take(8);
              if (a === !1)
                return !1;
              const o = te.uEnc(r + a), s = new Uint8Array(8), i = new DataView(s.buffer);
              i.setInt32(0, o.lo, !0), i.setInt32(4, o.hi, !0), t.push(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]);
              break;
            }
          }
        break;
      default:
        t.push(n.c.charCodeAt(0));
    }
  return new Uint8Array(t);
}
function* qN(e) {
  switch (e.kind) {
    case "file":
      for (const t of e.messages)
        yield t, yield* qN(t);
      yield* e.enums, yield* e.services, yield* e.extensions;
      break;
    case "message":
      for (const t of e.nestedMessages)
        yield t, yield* qN(t);
      yield* e.nestedEnums, yield* e.nestedExtensions;
      break;
  }
}
function zB(...e) {
  const t = xge();
  if (!e.length)
    return t;
  if ("$typeName" in e[0] && e[0].$typeName == "google.protobuf.FileDescriptorSet") {
    for (const n of e[0].file)
      D9(n, t);
    return t;
  }
  if ("$typeName" in e[0]) {
    let n = function(s) {
      const i = [];
      for (const u of s.dependency) {
        if (t.getFile(u) != null || o.has(u))
          continue;
        const l = a(u);
        if (!l)
          throw new Error(`Unable to resolve ${u}, imported by ${s.name}`);
        "kind" in l ? t.addFile(l, !1, !0) : (o.add(l.name), i.push(l));
      }
      return i.concat(...i.map(n));
    };
    const r = e[0], a = e[1], o = /* @__PURE__ */ new Set();
    for (const s of [r, ...n(r)].reverse())
      D9(s, t);
  } else
    for (const n of e)
      for (const r of n.files)
        t.addFile(r);
  return t;
}
function xge() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return {
    kind: "registry",
    types: e,
    extendees: t,
    [Symbol.iterator]() {
      return e.values();
    },
    get files() {
      return n.values();
    },
    addFile(r, a, o) {
      if (n.set(r.proto.name, r), !a)
        for (const s of qN(r))
          this.add(s);
      if (o)
        for (const s of r.dependencies)
          this.addFile(s, a, o);
    },
    add(r) {
      if (r.kind == "extension") {
        let a = t.get(r.extendee.typeName);
        a || t.set(
          r.extendee.typeName,
          // biome-ignore lint/suspicious/noAssignInExpressions: no
          a = /* @__PURE__ */ new Map()
        ), a.set(r.number, r);
      }
      e.set(r.typeName, r);
    },
    get(r) {
      return e.get(r);
    },
    getFile(r) {
      return n.get(r);
    },
    getMessage(r) {
      const a = e.get(r);
      return a?.kind == "message" ? a : void 0;
    },
    getEnum(r) {
      const a = e.get(r);
      return a?.kind == "enum" ? a : void 0;
    },
    getExtension(r) {
      const a = e.get(r);
      return a?.kind == "extension" ? a : void 0;
    },
    getExtensionFor(r, a) {
      var o;
      return (o = t.get(r.typeName)) === null || o === void 0 ? void 0 : o.get(a);
    },
    getService(r) {
      const a = e.get(r);
      return a?.kind == "service" ? a : void 0;
    }
  };
}
const Yge = 998, jge = 999, Bge = 9, Sc = 10, Hu = 11, Gge = 12, w9 = 14, qT = 3, Mge = 2, _9 = 1, Cge = 0, O9 = 1, S9 = 2, Kge = 3, Xge = 1, Wge = 2, Jge = 1, qB = {
  // EDITION_PROTO2
  998: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 2,
    // CLOSED,
    repeatedFieldEncoding: 2,
    // EXPANDED,
    utf8Validation: 3,
    // NONE,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 2,
    // LEGACY_BEST_EFFORT,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_PROTO3
  999: {
    fieldPresence: 2,
    // IMPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2023
  1e3: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 2,
    // STYLE_LEGACY,
    defaultSymbolVisibility: 1
    // EXPORT_ALL,
  },
  // EDITION_2024
  1001: {
    fieldPresence: 1,
    // EXPLICIT,
    enumType: 1,
    // OPEN,
    repeatedFieldEncoding: 1,
    // PACKED,
    utf8Validation: 2,
    // VERIFY,
    messageEncoding: 1,
    // LENGTH_PREFIXED,
    jsonFormat: 1,
    // ALLOW,
    enforceNamingStyle: 1,
    // STYLE2024,
    defaultSymbolVisibility: 2
    // EXPORT_TOP_LEVEL,
  }
};
function D9(e, t) {
  var n, r;
  const a = {
    kind: "file",
    proto: e,
    deprecated: (r = (n = e.options) === null || n === void 0 ? void 0 : n.deprecated) !== null && r !== void 0 ? r : !1,
    edition: qge(e),
    name: e.name.replace(/\.proto$/, ""),
    dependencies: Qge(e, t),
    enums: [],
    messages: [],
    extensions: [],
    services: [],
    toString() {
      return `file ${e.name}`;
    }
  }, o = /* @__PURE__ */ new Map(), s = {
    get(i) {
      return o.get(i);
    },
    add(i) {
      var u;
      fr(((u = i.proto.options) === null || u === void 0 ? void 0 : u.mapEntry) === !0), o.set(i.typeName, i);
    }
  };
  for (const i of e.enumType)
    QB(i, a, void 0, t);
  for (const i of e.messageType)
    eG(i, a, void 0, t, s);
  for (const i of e.service)
    Zge(i, a, t);
  QN(a, t);
  for (const i of o.values())
    eE(i, t, s);
  for (const i of a.messages)
    eE(i, t, s), QN(i, t);
  t.addFile(a, !0);
}
function QN(e, t) {
  switch (e.kind) {
    case "file":
      for (const n of e.proto.extension) {
        const r = tE(n, e, t);
        e.extensions.push(r), t.add(r);
      }
      break;
    case "message":
      for (const n of e.proto.extension) {
        const r = tE(n, e, t);
        e.nestedExtensions.push(r), t.add(r);
      }
      for (const n of e.nestedMessages)
        QN(n, t);
      break;
  }
}
function eE(e, t, n) {
  const r = e.proto.oneofDecl.map((o) => zge(o, e)), a = /* @__PURE__ */ new Set();
  for (const o of e.proto.field) {
    const s = nhe(o, r), i = tE(o, e, t, s, n);
    e.fields.push(i), e.field[i.localName] = i, s === void 0 ? e.members.push(i) : (s.fields.push(i), a.has(s) || (a.add(s), e.members.push(s)));
  }
  for (const o of r.filter((s) => a.has(s)))
    e.oneofs.push(o);
  for (const o of e.nestedMessages)
    eE(o, t, n);
}
function QB(e, t, n, r) {
  var a, o, s, i, u;
  const l = ehe(e.name, e.value), c = {
    kind: "enum",
    proto: e,
    deprecated: (o = (a = e.options) === null || a === void 0 ? void 0 : a.deprecated) !== null && o !== void 0 ? o : !1,
    file: t,
    parent: n,
    open: !0,
    name: e.name,
    typeName: dg(e, n, t),
    value: {},
    values: [],
    sharedPrefix: l,
    toString() {
      return `enum ${this.typeName}`;
    }
  };
  c.open = she(c), r.add(c);
  for (const f of e.value) {
    const d = f.name;
    c.values.push(
      // biome-ignore lint/suspicious/noAssignInExpressions: no
      c.value[f.number] = {
        kind: "enum_value",
        proto: f,
        deprecated: (i = (s = f.options) === null || s === void 0 ? void 0 : s.deprecated) !== null && i !== void 0 ? i : !1,
        parent: c,
        name: d,
        localName: Oc(l == null ? d : d.substring(l.length)),
        number: f.number,
        toString() {
          return `enum value ${c.typeName}.${d}`;
        }
      }
    );
  }
  ((u = n?.nestedEnums) !== null && u !== void 0 ? u : t.enums).push(c);
}
function eG(e, t, n, r, a) {
  var o, s, i, u;
  const l = {
    kind: "message",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    file: t,
    parent: n,
    name: e.name,
    typeName: dg(e, n, t),
    fields: [],
    field: {},
    oneofs: [],
    members: [],
    nestedEnums: [],
    nestedMessages: [],
    nestedExtensions: [],
    toString() {
      return `message ${this.typeName}`;
    }
  };
  ((i = e.options) === null || i === void 0 ? void 0 : i.mapEntry) === !0 ? a.add(l) : (((u = n?.nestedMessages) !== null && u !== void 0 ? u : t.messages).push(l), r.add(l));
  for (const c of e.enumType)
    QB(c, t, l, r);
  for (const c of e.nestedType)
    eG(c, t, l, r, a);
}
function Zge(e, t, n) {
  var r, a;
  const o = {
    kind: "service",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    file: t,
    name: e.name,
    typeName: dg(e, void 0, t),
    methods: [],
    method: {},
    toString() {
      return `service ${this.typeName}`;
    }
  };
  t.services.push(o), n.add(o);
  for (const s of e.method) {
    const i = Hge(s, o, n);
    o.methods.push(i), o.method[i.localName] = i;
  }
}
function Hge(e, t, n) {
  var r, a, o, s;
  let i;
  e.clientStreaming && e.serverStreaming ? i = "bidi_streaming" : e.clientStreaming ? i = "client_streaming" : e.serverStreaming ? i = "server_streaming" : i = "unary";
  const u = n.getMessage(_a(e.inputType)), l = n.getMessage(_a(e.outputType));
  fr(u, `invalid MethodDescriptorProto: input_type ${e.inputType} not found`), fr(l, `invalid MethodDescriptorProto: output_type ${e.inputType} not found`);
  const c = e.name;
  return {
    kind: "rpc",
    proto: e,
    deprecated: (a = (r = e.options) === null || r === void 0 ? void 0 : r.deprecated) !== null && a !== void 0 ? a : !1,
    parent: t,
    name: c,
    localName: Oc(c.length ? Oc(c[0].toLowerCase() + c.substring(1)) : c),
    methodKind: i,
    input: u,
    output: l,
    idempotency: (s = (o = e.options) === null || o === void 0 ? void 0 : o.idempotencyLevel) !== null && s !== void 0 ? s : Cge,
    toString() {
      return `rpc ${t.typeName}.${c}`;
    }
  };
}
function zge(e, t) {
  return {
    kind: "oneof",
    proto: e,
    deprecated: !1,
    parent: t,
    fields: [],
    name: e.name,
    localName: Oc(_c(e.name)),
    toString() {
      return `oneof ${t.typeName}.${this.name}`;
    }
  };
}
function tE(e, t, n, r, a) {
  var o, s, i;
  const u = a === void 0, l = {
    kind: "field",
    proto: e,
    deprecated: (s = (o = e.options) === null || o === void 0 ? void 0 : o.deprecated) !== null && s !== void 0 ? s : !1,
    name: e.name,
    number: e.number,
    scalar: void 0,
    message: void 0,
    enum: void 0,
    presence: rhe(e, r, u, t),
    listKind: void 0,
    mapKind: void 0,
    mapKey: void 0,
    delimitedEncoding: void 0,
    packed: void 0,
    longAsString: !1,
    getDefaultValue: void 0
  };
  if (u) {
    const m = t.kind == "file" ? t : t.file, p = t.kind == "file" ? void 0 : t, b = dg(e, p, m);
    l.kind = "extension", l.file = m, l.parent = p, l.oneof = void 0, l.typeName = b, l.jsonName = `[${b}]`, l.toString = () => `extension ${b}`;
    const g = n.getMessage(_a(e.extendee));
    fr(g, `invalid FieldDescriptorProto: extendee ${e.extendee} not found`), l.extendee = g;
  } else {
    const m = t;
    fr(m.kind == "message"), l.parent = m, l.oneof = r, l.localName = r ? _c(e.name) : Oc(_c(e.name)), l.jsonName = e.jsonName, l.toString = () => `field ${m.typeName}.${e.name}`;
  }
  const c = e.label, f = e.type, d = (i = e.options) === null || i === void 0 ? void 0 : i.jstype;
  if (c === qT) {
    const m = f == Hu ? a?.get(_a(e.typeName)) : void 0;
    if (m) {
      l.fieldKind = "map";
      const { key: p, value: b } = ohe(m);
      return l.mapKey = p.scalar, l.mapKind = b.fieldKind, l.message = b.message, l.delimitedEncoding = !1, l.enum = b.enum, l.scalar = b.scalar, l;
    }
    switch (l.fieldKind = "list", f) {
      case Hu:
      case Sc:
        l.listKind = "message", l.message = n.getMessage(_a(e.typeName)), fr(l.message), l.delimitedEncoding = k9(e, t);
        break;
      case w9:
        l.listKind = "enum", l.enum = n.getEnum(_a(e.typeName)), fr(l.enum);
        break;
      default:
        l.listKind = "scalar", l.scalar = f, l.longAsString = d == _9;
        break;
    }
    return l.packed = ahe(e, t), l;
  }
  switch (f) {
    case Hu:
    case Sc:
      l.fieldKind = "message", l.message = n.getMessage(_a(e.typeName)), fr(l.message, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.delimitedEncoding = k9(e, t), l.getDefaultValue = () => {
      };
      break;
    case w9: {
      const m = n.getEnum(_a(e.typeName));
      fr(m !== void 0, `invalid FieldDescriptorProto: type_name ${e.typeName} not found`), l.fieldKind = "enum", l.enum = n.getEnum(_a(e.typeName)), l.getDefaultValue = () => wc(e, "defaultValue") ? $ge(m, e.defaultValue) : void 0;
      break;
    }
    default: {
      l.fieldKind = "scalar", l.scalar = f, l.longAsString = d == _9, l.getDefaultValue = () => wc(e, "defaultValue") ? Pge(f, e.defaultValue) : void 0;
      break;
    }
  }
  return l;
}
function qge(e) {
  switch (e.syntax) {
    case "":
    case "proto2":
      return Yge;
    case "proto3":
      return jge;
    case "editions":
      if (e.edition in qB)
        return e.edition;
      throw new Error(`${e.name}: unsupported edition`);
    default:
      throw new Error(`${e.name}: unsupported syntax "${e.syntax}"`);
  }
}
function Qge(e, t) {
  return e.dependency.map((n) => {
    const r = t.getFile(n);
    if (!r)
      throw new Error(`Cannot find ${n}, imported by ${e.name}`);
    return r;
  });
}
function ehe(e, t) {
  const n = the(e) + "_";
  for (const r of t) {
    if (!r.name.toLowerCase().startsWith(n))
      return;
    const a = r.name.substring(n.length);
    if (a.length == 0 || /^\d/.test(a))
      return;
  }
  return n;
}
function the(e) {
  return (e.substring(0, 1) + e.substring(1).replace(/[A-Z]/g, (t) => "_" + t)).toLowerCase();
}
function dg(e, t, n) {
  let r;
  return t ? r = `${t.typeName}.${e.name}` : n.proto.package.length > 0 ? r = `${n.proto.package}.${e.name}` : r = `${e.name}`, r;
}
function _a(e) {
  return e.startsWith(".") ? e.substring(1) : e;
}
function nhe(e, t) {
  if (!wc(e, "oneofIndex") || e.proto3Optional)
    return;
  const n = t[e.oneofIndex];
  return fr(n, `invalid FieldDescriptorProto: oneof #${e.oneofIndex} for field #${e.number} not found`), n;
}
function rhe(e, t, n, r) {
  if (e.label == Mge)
    return Kge;
  if (e.label == qT)
    return S9;
  if (t || e.proto3Optional || n)
    return O9;
  const a = gu("fieldPresence", { proto: e, parent: r });
  return a == S9 && (e.type == Hu || e.type == Sc) ? O9 : a;
}
function ahe(e, t) {
  if (e.label != qT)
    return !1;
  switch (e.type) {
    case Bge:
    case Gge:
    case Sc:
    case Hu:
      return !1;
  }
  const n = e.options;
  return n && wc(n, "packed") ? n.packed : Xge == gu("repeatedFieldEncoding", {
    proto: e,
    parent: t
  });
}
function ohe(e) {
  const t = e.fields.find((r) => r.number === 1), n = e.fields.find((r) => r.number === 2);
  return fr(t && t.fieldKind == "scalar" && t.scalar != O.BYTES && t.scalar != O.FLOAT && t.scalar != O.DOUBLE && n && n.fieldKind != "list" && n.fieldKind != "map"), { key: t, value: n };
}
function she(e) {
  var t;
  return Jge == gu("enumType", {
    proto: e.proto,
    parent: (t = e.parent) !== null && t !== void 0 ? t : e.file
  });
}
function k9(e, t) {
  return e.type == Sc ? !0 : Wge == gu("messageEncoding", {
    proto: e,
    parent: t
  });
}
function gu(e, t) {
  var n, r;
  const a = (n = t.proto.options) === null || n === void 0 ? void 0 : n.features;
  if (a) {
    const o = a[e];
    if (o != 0)
      return o;
  }
  if ("kind" in t) {
    if (t.kind == "message")
      return gu(e, (r = t.parent) !== null && r !== void 0 ? r : t.file);
    const o = qB[t.edition];
    if (!o)
      throw new Error(`feature default for edition ${t.edition} not found`);
    return o[e];
  }
  return gu(e, t.parent);
}
function fr(e, t) {
  if (!e)
    throw new Error(t);
}
function ihe(e) {
  const t = uhe(e);
  return t.messageType.forEach(zT), zB(t, () => {
  }).getFile(t.name);
}
function uhe(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    syntax: "",
    edition: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FileDescriptorProto", dependency: [], publicDependency: [], weakDependency: [], optionDependency: [], service: [], extension: [] }, e), { messageType: e.messageType.map(tG), enumType: e.enumType.map(nG) }));
}
function tG(e) {
  var t, n, r, a, o, s, i, u;
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.DescriptorProto",
    name: e.name,
    field: (n = (t = e.field) === null || t === void 0 ? void 0 : t.map(lhe)) !== null && n !== void 0 ? n : [],
    extension: [],
    nestedType: (a = (r = e.nestedType) === null || r === void 0 ? void 0 : r.map(tG)) !== null && a !== void 0 ? a : [],
    enumType: (s = (o = e.enumType) === null || o === void 0 ? void 0 : o.map(nG)) !== null && s !== void 0 ? s : [],
    extensionRange: (u = (i = e.extensionRange) === null || i === void 0 ? void 0 : i.map((l) => Object.assign({ $typeName: "google.protobuf.DescriptorProto.ExtensionRange" }, l))) !== null && u !== void 0 ? u : [],
    oneofDecl: [],
    reservedRange: [],
    reservedName: []
  });
}
function lhe(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    label: 1,
    typeName: "",
    extendee: "",
    defaultValue: "",
    oneofIndex: 0,
    jsonName: "",
    proto3Optional: !1
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldDescriptorProto" }, e), { options: e.options ? che(e.options) : void 0 }));
}
function che(e) {
  var t, n, r;
  return Object.assign(/* @__PURE__ */ Object.create({
    ctype: 0,
    packed: !1,
    jstype: 0,
    lazy: !1,
    unverifiedLazy: !1,
    deprecated: !1,
    weak: !1,
    debugRedact: !1,
    retention: 0
  }), Object.assign(Object.assign({ $typeName: "google.protobuf.FieldOptions" }, e), { targets: (t = e.targets) !== null && t !== void 0 ? t : [], editionDefaults: (r = (n = e.editionDefaults) === null || n === void 0 ? void 0 : n.map((a) => Object.assign({ $typeName: "google.protobuf.FieldOptions.EditionDefault" }, a))) !== null && r !== void 0 ? r : [], uninterpretedOption: [] }));
}
function nG(e) {
  return Object.assign(/* @__PURE__ */ Object.create({
    visibility: 0
  }), {
    $typeName: "google.protobuf.EnumDescriptorProto",
    name: e.name,
    reservedName: [],
    reservedRange: [],
    value: e.value.map((t) => Object.assign({ $typeName: "google.protobuf.EnumValueDescriptorProto" }, t))
  });
}
function Mf(e, t, ...n) {
  return n.reduce((r, a) => r.nestedMessages[a], e.messages[t]);
}
const fhe = /* @__PURE__ */ ihe({ name: "google/protobuf/descriptor.proto", package: "google.protobuf", messageType: [{ name: "FileDescriptorSet", field: [{ name: "file", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FileDescriptorProto" }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "FileDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "package", number: 2, type: 9, label: 1 }, { name: "dependency", number: 3, type: 9, label: 3 }, { name: "public_dependency", number: 10, type: 5, label: 3 }, { name: "weak_dependency", number: 11, type: 5, label: 3 }, { name: "option_dependency", number: 15, type: 9, label: 3 }, { name: "message_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 5, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "service", number: 6, type: 11, label: 3, typeName: ".google.protobuf.ServiceDescriptorProto" }, { name: "extension", number: 7, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FileOptions" }, { name: "source_code_info", number: 9, type: 11, label: 1, typeName: ".google.protobuf.SourceCodeInfo" }, { name: "syntax", number: 12, type: 9, label: 1 }, { name: "edition", number: 14, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }, { name: "DescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "field", number: 2, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "extension", number: 6, type: 11, label: 3, typeName: ".google.protobuf.FieldDescriptorProto" }, { name: "nested_type", number: 3, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto" }, { name: "enum_type", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto" }, { name: "extension_range", number: 5, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ExtensionRange" }, { name: "oneof_decl", number: 8, type: 11, label: 3, typeName: ".google.protobuf.OneofDescriptorProto" }, { name: "options", number: 7, type: 11, label: 1, typeName: ".google.protobuf.MessageOptions" }, { name: "reserved_range", number: 9, type: 11, label: 3, typeName: ".google.protobuf.DescriptorProto.ReservedRange" }, { name: "reserved_name", number: 10, type: 9, label: 3 }, { name: "visibility", number: 11, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "ExtensionRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions" }] }, { name: "ReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "ExtensionRangeOptions", field: [{ name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }, { name: "declaration", number: 2, type: 11, label: 3, typeName: ".google.protobuf.ExtensionRangeOptions.Declaration", options: { retention: 2 } }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "verification", number: 3, type: 14, label: 1, typeName: ".google.protobuf.ExtensionRangeOptions.VerificationState", defaultValue: "UNVERIFIED", options: { retention: 2 } }], nestedType: [{ name: "Declaration", field: [{ name: "number", number: 1, type: 5, label: 1 }, { name: "full_name", number: 2, type: 9, label: 1 }, { name: "type", number: 3, type: 9, label: 1 }, { name: "reserved", number: 5, type: 8, label: 1 }, { name: "repeated", number: 6, type: 8, label: 1 }] }], enumType: [{ name: "VerificationState", value: [{ name: "DECLARATION", number: 0 }, { name: "UNVERIFIED", number: 1 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 3, type: 5, label: 1 }, { name: "label", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Label" }, { name: "type", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FieldDescriptorProto.Type" }, { name: "type_name", number: 6, type: 9, label: 1 }, { name: "extendee", number: 2, type: 9, label: 1 }, { name: "default_value", number: 7, type: 9, label: 1 }, { name: "oneof_index", number: 9, type: 5, label: 1 }, { name: "json_name", number: 10, type: 9, label: 1 }, { name: "options", number: 8, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions" }, { name: "proto3_optional", number: 17, type: 8, label: 1 }], enumType: [{ name: "Type", value: [{ name: "TYPE_DOUBLE", number: 1 }, { name: "TYPE_FLOAT", number: 2 }, { name: "TYPE_INT64", number: 3 }, { name: "TYPE_UINT64", number: 4 }, { name: "TYPE_INT32", number: 5 }, { name: "TYPE_FIXED64", number: 6 }, { name: "TYPE_FIXED32", number: 7 }, { name: "TYPE_BOOL", number: 8 }, { name: "TYPE_STRING", number: 9 }, { name: "TYPE_GROUP", number: 10 }, { name: "TYPE_MESSAGE", number: 11 }, { name: "TYPE_BYTES", number: 12 }, { name: "TYPE_UINT32", number: 13 }, { name: "TYPE_ENUM", number: 14 }, { name: "TYPE_SFIXED32", number: 15 }, { name: "TYPE_SFIXED64", number: 16 }, { name: "TYPE_SINT32", number: 17 }, { name: "TYPE_SINT64", number: 18 }] }, { name: "Label", value: [{ name: "LABEL_OPTIONAL", number: 1 }, { name: "LABEL_REPEATED", number: 3 }, { name: "LABEL_REQUIRED", number: 2 }] }] }, { name: "OneofDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "options", number: 2, type: 11, label: 1, typeName: ".google.protobuf.OneofOptions" }] }, { name: "EnumDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "value", number: 2, type: 11, label: 3, typeName: ".google.protobuf.EnumValueDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumOptions" }, { name: "reserved_range", number: 4, type: 11, label: 3, typeName: ".google.protobuf.EnumDescriptorProto.EnumReservedRange" }, { name: "reserved_name", number: 5, type: 9, label: 3 }, { name: "visibility", number: 6, type: 14, label: 1, typeName: ".google.protobuf.SymbolVisibility" }], nestedType: [{ name: "EnumReservedRange", field: [{ name: "start", number: 1, type: 5, label: 1 }, { name: "end", number: 2, type: 5, label: 1 }] }] }, { name: "EnumValueDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "number", number: 2, type: 5, label: 1 }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.EnumValueOptions" }] }, { name: "ServiceDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "method", number: 2, type: 11, label: 3, typeName: ".google.protobuf.MethodDescriptorProto" }, { name: "options", number: 3, type: 11, label: 1, typeName: ".google.protobuf.ServiceOptions" }] }, { name: "MethodDescriptorProto", field: [{ name: "name", number: 1, type: 9, label: 1 }, { name: "input_type", number: 2, type: 9, label: 1 }, { name: "output_type", number: 3, type: 9, label: 1 }, { name: "options", number: 4, type: 11, label: 1, typeName: ".google.protobuf.MethodOptions" }, { name: "client_streaming", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "server_streaming", number: 6, type: 8, label: 1, defaultValue: "false" }] }, { name: "FileOptions", field: [{ name: "java_package", number: 1, type: 9, label: 1 }, { name: "java_outer_classname", number: 8, type: 9, label: 1 }, { name: "java_multiple_files", number: 10, type: 8, label: 1, defaultValue: "false" }, { name: "java_generate_equals_and_hash", number: 20, type: 8, label: 1, options: { deprecated: !0 } }, { name: "java_string_check_utf8", number: 27, type: 8, label: 1, defaultValue: "false" }, { name: "optimize_for", number: 9, type: 14, label: 1, typeName: ".google.protobuf.FileOptions.OptimizeMode", defaultValue: "SPEED" }, { name: "go_package", number: 11, type: 9, label: 1 }, { name: "cc_generic_services", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "java_generic_services", number: 17, type: 8, label: 1, defaultValue: "false" }, { name: "py_generic_services", number: 18, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 23, type: 8, label: 1, defaultValue: "false" }, { name: "cc_enable_arenas", number: 31, type: 8, label: 1, defaultValue: "true" }, { name: "objc_class_prefix", number: 36, type: 9, label: 1 }, { name: "csharp_namespace", number: 37, type: 9, label: 1 }, { name: "swift_prefix", number: 39, type: 9, label: 1 }, { name: "php_class_prefix", number: 40, type: 9, label: 1 }, { name: "php_namespace", number: 41, type: 9, label: 1 }, { name: "php_metadata_namespace", number: 44, type: 9, label: 1 }, { name: "ruby_package", number: 45, type: 9, label: 1 }, { name: "features", number: 50, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "OptimizeMode", value: [{ name: "SPEED", number: 1 }, { name: "CODE_SIZE", number: 2 }, { name: "LITE_RUNTIME", number: 3 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MessageOptions", field: [{ name: "message_set_wire_format", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "no_standard_descriptor_accessor", number: 2, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "map_entry", number: 7, type: 8, label: 1 }, { name: "deprecated_legacy_json_field_conflicts", number: 11, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 12, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "FieldOptions", field: [{ name: "ctype", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.CType", defaultValue: "STRING" }, { name: "packed", number: 2, type: 8, label: 1 }, { name: "jstype", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.JSType", defaultValue: "JS_NORMAL" }, { name: "lazy", number: 5, type: 8, label: 1, defaultValue: "false" }, { name: "unverified_lazy", number: 15, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "weak", number: 10, type: 8, label: 1, defaultValue: "false", options: { deprecated: !0 } }, { name: "debug_redact", number: 16, type: 8, label: 1, defaultValue: "false" }, { name: "retention", number: 17, type: 14, label: 1, typeName: ".google.protobuf.FieldOptions.OptionRetention" }, { name: "targets", number: 19, type: 14, label: 3, typeName: ".google.protobuf.FieldOptions.OptionTargetType" }, { name: "edition_defaults", number: 20, type: 11, label: 3, typeName: ".google.protobuf.FieldOptions.EditionDefault" }, { name: "features", number: 21, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "feature_support", number: 22, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], nestedType: [{ name: "EditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "value", number: 2, type: 9, label: 1 }] }, { name: "FeatureSupport", field: [{ name: "edition_introduced", number: 1, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "edition_deprecated", number: 2, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "deprecation_warning", number: 3, type: 9, label: 1 }, { name: "edition_removed", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }] }], enumType: [{ name: "CType", value: [{ name: "STRING", number: 0 }, { name: "CORD", number: 1 }, { name: "STRING_PIECE", number: 2 }] }, { name: "JSType", value: [{ name: "JS_NORMAL", number: 0 }, { name: "JS_STRING", number: 1 }, { name: "JS_NUMBER", number: 2 }] }, { name: "OptionRetention", value: [{ name: "RETENTION_UNKNOWN", number: 0 }, { name: "RETENTION_RUNTIME", number: 1 }, { name: "RETENTION_SOURCE", number: 2 }] }, { name: "OptionTargetType", value: [{ name: "TARGET_TYPE_UNKNOWN", number: 0 }, { name: "TARGET_TYPE_FILE", number: 1 }, { name: "TARGET_TYPE_EXTENSION_RANGE", number: 2 }, { name: "TARGET_TYPE_MESSAGE", number: 3 }, { name: "TARGET_TYPE_FIELD", number: 4 }, { name: "TARGET_TYPE_ONEOF", number: 5 }, { name: "TARGET_TYPE_ENUM", number: 6 }, { name: "TARGET_TYPE_ENUM_ENTRY", number: 7 }, { name: "TARGET_TYPE_SERVICE", number: 8 }, { name: "TARGET_TYPE_METHOD", number: 9 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "OneofOptions", field: [{ name: "features", number: 1, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumOptions", field: [{ name: "allow_alias", number: 2, type: 8, label: 1 }, { name: "deprecated", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "deprecated_legacy_json_field_conflicts", number: 6, type: 8, label: 1, options: { deprecated: !0 } }, { name: "features", number: 7, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "EnumValueOptions", field: [{ name: "deprecated", number: 1, type: 8, label: 1, defaultValue: "false" }, { name: "features", number: 2, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "debug_redact", number: 3, type: 8, label: 1, defaultValue: "false" }, { name: "feature_support", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FieldOptions.FeatureSupport" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "ServiceOptions", field: [{ name: "features", number: 34, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "MethodOptions", field: [{ name: "deprecated", number: 33, type: 8, label: 1, defaultValue: "false" }, { name: "idempotency_level", number: 34, type: 14, label: 1, typeName: ".google.protobuf.MethodOptions.IdempotencyLevel", defaultValue: "IDEMPOTENCY_UNKNOWN" }, { name: "features", number: 35, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "uninterpreted_option", number: 999, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption" }], enumType: [{ name: "IdempotencyLevel", value: [{ name: "IDEMPOTENCY_UNKNOWN", number: 0 }, { name: "NO_SIDE_EFFECTS", number: 1 }, { name: "IDEMPOTENT", number: 2 }] }], extensionRange: [{ start: 1e3, end: 536870912 }] }, { name: "UninterpretedOption", field: [{ name: "name", number: 2, type: 11, label: 3, typeName: ".google.protobuf.UninterpretedOption.NamePart" }, { name: "identifier_value", number: 3, type: 9, label: 1 }, { name: "positive_int_value", number: 4, type: 4, label: 1 }, { name: "negative_int_value", number: 5, type: 3, label: 1 }, { name: "double_value", number: 6, type: 1, label: 1 }, { name: "string_value", number: 7, type: 12, label: 1 }, { name: "aggregate_value", number: 8, type: 9, label: 1 }], nestedType: [{ name: "NamePart", field: [{ name: "name_part", number: 1, type: 9, label: 2 }, { name: "is_extension", number: 2, type: 8, label: 2 }] }] }, { name: "FeatureSet", field: [{ name: "field_presence", number: 1, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.FieldPresence", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPLICIT", edition: 900 }, { value: "IMPLICIT", edition: 999 }, { value: "EXPLICIT", edition: 1e3 }] } }, { name: "enum_type", number: 2, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnumType", options: { retention: 1, targets: [6, 1], editionDefaults: [{ value: "CLOSED", edition: 900 }, { value: "OPEN", edition: 999 }] } }, { name: "repeated_field_encoding", number: 3, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.RepeatedFieldEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "EXPANDED", edition: 900 }, { value: "PACKED", edition: 999 }] } }, { name: "utf8_validation", number: 4, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.Utf8Validation", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "NONE", edition: 900 }, { value: "VERIFY", edition: 999 }] } }, { name: "message_encoding", number: 5, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.MessageEncoding", options: { retention: 1, targets: [4, 1], editionDefaults: [{ value: "LENGTH_PREFIXED", edition: 900 }] } }, { name: "json_format", number: 6, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.JsonFormat", options: { retention: 1, targets: [3, 6, 1], editionDefaults: [{ value: "LEGACY_BEST_EFFORT", edition: 900 }, { value: "ALLOW", edition: 999 }] } }, { name: "enforce_naming_style", number: 7, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.EnforceNamingStyle", options: { retention: 2, targets: [1, 2, 3, 4, 5, 6, 7, 8, 9], editionDefaults: [{ value: "STYLE_LEGACY", edition: 900 }, { value: "STYLE2024", edition: 1001 }] } }, { name: "default_symbol_visibility", number: 8, type: 14, label: 1, typeName: ".google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility", options: { retention: 2, targets: [1], editionDefaults: [{ value: "EXPORT_ALL", edition: 900 }, { value: "EXPORT_TOP_LEVEL", edition: 1001 }] } }], nestedType: [{ name: "VisibilityFeature", enumType: [{ name: "DefaultSymbolVisibility", value: [{ name: "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", number: 0 }, { name: "EXPORT_ALL", number: 1 }, { name: "EXPORT_TOP_LEVEL", number: 2 }, { name: "LOCAL_ALL", number: 3 }, { name: "STRICT", number: 4 }] }] }], enumType: [{ name: "FieldPresence", value: [{ name: "FIELD_PRESENCE_UNKNOWN", number: 0 }, { name: "EXPLICIT", number: 1 }, { name: "IMPLICIT", number: 2 }, { name: "LEGACY_REQUIRED", number: 3 }] }, { name: "EnumType", value: [{ name: "ENUM_TYPE_UNKNOWN", number: 0 }, { name: "OPEN", number: 1 }, { name: "CLOSED", number: 2 }] }, { name: "RepeatedFieldEncoding", value: [{ name: "REPEATED_FIELD_ENCODING_UNKNOWN", number: 0 }, { name: "PACKED", number: 1 }, { name: "EXPANDED", number: 2 }] }, { name: "Utf8Validation", value: [{ name: "UTF8_VALIDATION_UNKNOWN", number: 0 }, { name: "VERIFY", number: 2 }, { name: "NONE", number: 3 }] }, { name: "MessageEncoding", value: [{ name: "MESSAGE_ENCODING_UNKNOWN", number: 0 }, { name: "LENGTH_PREFIXED", number: 1 }, { name: "DELIMITED", number: 2 }] }, { name: "JsonFormat", value: [{ name: "JSON_FORMAT_UNKNOWN", number: 0 }, { name: "ALLOW", number: 1 }, { name: "LEGACY_BEST_EFFORT", number: 2 }] }, { name: "EnforceNamingStyle", value: [{ name: "ENFORCE_NAMING_STYLE_UNKNOWN", number: 0 }, { name: "STYLE2024", number: 1 }, { name: "STYLE_LEGACY", number: 2 }] }], extensionRange: [{ start: 1e3, end: 9995 }, { start: 9995, end: 1e4 }, { start: 1e4, end: 10001 }] }, { name: "FeatureSetDefaults", field: [{ name: "defaults", number: 1, type: 11, label: 3, typeName: ".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault" }, { name: "minimum_edition", number: 4, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "maximum_edition", number: 5, type: 14, label: 1, typeName: ".google.protobuf.Edition" }], nestedType: [{ name: "FeatureSetEditionDefault", field: [{ name: "edition", number: 3, type: 14, label: 1, typeName: ".google.protobuf.Edition" }, { name: "overridable_features", number: 4, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }, { name: "fixed_features", number: 5, type: 11, label: 1, typeName: ".google.protobuf.FeatureSet" }] }] }, { name: "SourceCodeInfo", field: [{ name: "location", number: 1, type: 11, label: 3, typeName: ".google.protobuf.SourceCodeInfo.Location" }], nestedType: [{ name: "Location", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "span", number: 2, type: 5, label: 3, options: { packed: !0 } }, { name: "leading_comments", number: 3, type: 9, label: 1 }, { name: "trailing_comments", number: 4, type: 9, label: 1 }, { name: "leading_detached_comments", number: 6, type: 9, label: 3 }] }], extensionRange: [{ start: 536e6, end: 536000001 }] }, { name: "GeneratedCodeInfo", field: [{ name: "annotation", number: 1, type: 11, label: 3, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation" }], nestedType: [{ name: "Annotation", field: [{ name: "path", number: 1, type: 5, label: 3, options: { packed: !0 } }, { name: "source_file", number: 2, type: 9, label: 1 }, { name: "begin", number: 3, type: 5, label: 1 }, { name: "end", number: 4, type: 5, label: 1 }, { name: "semantic", number: 5, type: 14, label: 1, typeName: ".google.protobuf.GeneratedCodeInfo.Annotation.Semantic" }], enumType: [{ name: "Semantic", value: [{ name: "NONE", number: 0 }, { name: "SET", number: 1 }, { name: "ALIAS", number: 2 }] }] }] }], enumType: [{ name: "Edition", value: [{ name: "EDITION_UNKNOWN", number: 0 }, { name: "EDITION_LEGACY", number: 900 }, { name: "EDITION_PROTO2", number: 998 }, { name: "EDITION_PROTO3", number: 999 }, { name: "EDITION_2023", number: 1e3 }, { name: "EDITION_2024", number: 1001 }, { name: "EDITION_UNSTABLE", number: 9999 }, { name: "EDITION_1_TEST_ONLY", number: 1 }, { name: "EDITION_2_TEST_ONLY", number: 2 }, { name: "EDITION_99997_TEST_ONLY", number: 99997 }, { name: "EDITION_99998_TEST_ONLY", number: 99998 }, { name: "EDITION_99999_TEST_ONLY", number: 99999 }, { name: "EDITION_MAX", number: 2147483647 }] }, { name: "SymbolVisibility", value: [{ name: "VISIBILITY_UNSET", number: 0 }, { name: "VISIBILITY_LOCAL", number: 1 }, { name: "VISIBILITY_EXPORT", number: 2 }] }] }), mhe = /* @__PURE__ */ Mf(fhe, 1);
var A9;
(function(e) {
  e[e.DECLARATION = 0] = "DECLARATION", e[e.UNVERIFIED = 1] = "UNVERIFIED";
})(A9 || (A9 = {}));
var L9;
(function(e) {
  e[e.DOUBLE = 1] = "DOUBLE", e[e.FLOAT = 2] = "FLOAT", e[e.INT64 = 3] = "INT64", e[e.UINT64 = 4] = "UINT64", e[e.INT32 = 5] = "INT32", e[e.FIXED64 = 6] = "FIXED64", e[e.FIXED32 = 7] = "FIXED32", e[e.BOOL = 8] = "BOOL", e[e.STRING = 9] = "STRING", e[e.GROUP = 10] = "GROUP", e[e.MESSAGE = 11] = "MESSAGE", e[e.BYTES = 12] = "BYTES", e[e.UINT32 = 13] = "UINT32", e[e.ENUM = 14] = "ENUM", e[e.SFIXED32 = 15] = "SFIXED32", e[e.SFIXED64 = 16] = "SFIXED64", e[e.SINT32 = 17] = "SINT32", e[e.SINT64 = 18] = "SINT64";
})(L9 || (L9 = {}));
var F9;
(function(e) {
  e[e.OPTIONAL = 1] = "OPTIONAL", e[e.REPEATED = 3] = "REPEATED", e[e.REQUIRED = 2] = "REQUIRED";
})(F9 || (F9 = {}));
var U9;
(function(e) {
  e[e.SPEED = 1] = "SPEED", e[e.CODE_SIZE = 2] = "CODE_SIZE", e[e.LITE_RUNTIME = 3] = "LITE_RUNTIME";
})(U9 || (U9 = {}));
var R9;
(function(e) {
  e[e.STRING = 0] = "STRING", e[e.CORD = 1] = "CORD", e[e.STRING_PIECE = 2] = "STRING_PIECE";
})(R9 || (R9 = {}));
var $9;
(function(e) {
  e[e.JS_NORMAL = 0] = "JS_NORMAL", e[e.JS_STRING = 1] = "JS_STRING", e[e.JS_NUMBER = 2] = "JS_NUMBER";
})($9 || ($9 = {}));
var P9;
(function(e) {
  e[e.RETENTION_UNKNOWN = 0] = "RETENTION_UNKNOWN", e[e.RETENTION_RUNTIME = 1] = "RETENTION_RUNTIME", e[e.RETENTION_SOURCE = 2] = "RETENTION_SOURCE";
})(P9 || (P9 = {}));
var V9;
(function(e) {
  e[e.TARGET_TYPE_UNKNOWN = 0] = "TARGET_TYPE_UNKNOWN", e[e.TARGET_TYPE_FILE = 1] = "TARGET_TYPE_FILE", e[e.TARGET_TYPE_EXTENSION_RANGE = 2] = "TARGET_TYPE_EXTENSION_RANGE", e[e.TARGET_TYPE_MESSAGE = 3] = "TARGET_TYPE_MESSAGE", e[e.TARGET_TYPE_FIELD = 4] = "TARGET_TYPE_FIELD", e[e.TARGET_TYPE_ONEOF = 5] = "TARGET_TYPE_ONEOF", e[e.TARGET_TYPE_ENUM = 6] = "TARGET_TYPE_ENUM", e[e.TARGET_TYPE_ENUM_ENTRY = 7] = "TARGET_TYPE_ENUM_ENTRY", e[e.TARGET_TYPE_SERVICE = 8] = "TARGET_TYPE_SERVICE", e[e.TARGET_TYPE_METHOD = 9] = "TARGET_TYPE_METHOD";
})(V9 || (V9 = {}));
var nE;
(function(e) {
  e[e.IDEMPOTENCY_UNKNOWN = 0] = "IDEMPOTENCY_UNKNOWN", e[e.NO_SIDE_EFFECTS = 1] = "NO_SIDE_EFFECTS", e[e.IDEMPOTENT = 2] = "IDEMPOTENT";
})(nE || (nE = {}));
var x9;
(function(e) {
  e[e.DEFAULT_SYMBOL_VISIBILITY_UNKNOWN = 0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN", e[e.EXPORT_ALL = 1] = "EXPORT_ALL", e[e.EXPORT_TOP_LEVEL = 2] = "EXPORT_TOP_LEVEL", e[e.LOCAL_ALL = 3] = "LOCAL_ALL", e[e.STRICT = 4] = "STRICT";
})(x9 || (x9 = {}));
var Y9;
(function(e) {
  e[e.FIELD_PRESENCE_UNKNOWN = 0] = "FIELD_PRESENCE_UNKNOWN", e[e.EXPLICIT = 1] = "EXPLICIT", e[e.IMPLICIT = 2] = "IMPLICIT", e[e.LEGACY_REQUIRED = 3] = "LEGACY_REQUIRED";
})(Y9 || (Y9 = {}));
var j9;
(function(e) {
  e[e.ENUM_TYPE_UNKNOWN = 0] = "ENUM_TYPE_UNKNOWN", e[e.OPEN = 1] = "OPEN", e[e.CLOSED = 2] = "CLOSED";
})(j9 || (j9 = {}));
var B9;
(function(e) {
  e[e.REPEATED_FIELD_ENCODING_UNKNOWN = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN", e[e.PACKED = 1] = "PACKED", e[e.EXPANDED = 2] = "EXPANDED";
})(B9 || (B9 = {}));
var G9;
(function(e) {
  e[e.UTF8_VALIDATION_UNKNOWN = 0] = "UTF8_VALIDATION_UNKNOWN", e[e.VERIFY = 2] = "VERIFY", e[e.NONE = 3] = "NONE";
})(G9 || (G9 = {}));
var M9;
(function(e) {
  e[e.MESSAGE_ENCODING_UNKNOWN = 0] = "MESSAGE_ENCODING_UNKNOWN", e[e.LENGTH_PREFIXED = 1] = "LENGTH_PREFIXED", e[e.DELIMITED = 2] = "DELIMITED";
})(M9 || (M9 = {}));
var C9;
(function(e) {
  e[e.JSON_FORMAT_UNKNOWN = 0] = "JSON_FORMAT_UNKNOWN", e[e.ALLOW = 1] = "ALLOW", e[e.LEGACY_BEST_EFFORT = 2] = "LEGACY_BEST_EFFORT";
})(C9 || (C9 = {}));
var K9;
(function(e) {
  e[e.ENFORCE_NAMING_STYLE_UNKNOWN = 0] = "ENFORCE_NAMING_STYLE_UNKNOWN", e[e.STYLE2024 = 1] = "STYLE2024", e[e.STYLE_LEGACY = 2] = "STYLE_LEGACY";
})(K9 || (K9 = {}));
var X9;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.SET = 1] = "SET", e[e.ALIAS = 2] = "ALIAS";
})(X9 || (X9 = {}));
var W9;
(function(e) {
  e[e.EDITION_UNKNOWN = 0] = "EDITION_UNKNOWN", e[e.EDITION_LEGACY = 900] = "EDITION_LEGACY", e[e.EDITION_PROTO2 = 998] = "EDITION_PROTO2", e[e.EDITION_PROTO3 = 999] = "EDITION_PROTO3", e[e.EDITION_2023 = 1e3] = "EDITION_2023", e[e.EDITION_2024 = 1001] = "EDITION_2024", e[e.EDITION_UNSTABLE = 9999] = "EDITION_UNSTABLE", e[e.EDITION_1_TEST_ONLY = 1] = "EDITION_1_TEST_ONLY", e[e.EDITION_2_TEST_ONLY = 2] = "EDITION_2_TEST_ONLY", e[e.EDITION_99997_TEST_ONLY = 99997] = "EDITION_99997_TEST_ONLY", e[e.EDITION_99998_TEST_ONLY = 99998] = "EDITION_99998_TEST_ONLY", e[e.EDITION_99999_TEST_ONLY = 99999] = "EDITION_99999_TEST_ONLY", e[e.EDITION_MAX = 2147483647] = "EDITION_MAX";
})(W9 || (W9 = {}));
var J9;
(function(e) {
  e[e.VISIBILITY_UNSET = 0] = "VISIBILITY_UNSET", e[e.VISIBILITY_LOCAL = 1] = "VISIBILITY_LOCAL", e[e.VISIBILITY_EXPORT = 2] = "VISIBILITY_EXPORT";
})(J9 || (J9 = {}));
const Z9 = {
  readUnknownFields: !0
};
function dhe(e) {
  return e ? Object.assign(Object.assign({}, Z9), e) : Z9;
}
function pg(e, t, n) {
  const r = tr(e, void 0, !1);
  return rG(r, new CT(t), dhe(n), !1, t.byteLength), r.message;
}
function rG(e, t, n, r, a) {
  var o;
  const s = r ? t.len : t.pos + a;
  let i, u;
  const l = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
  for (; t.pos < s && ([i, u] = t.tag(), !(r && u == de.EndGroup)); ) {
    const c = e.findNumber(i);
    if (!c) {
      const f = t.skip(u, i);
      n.readUnknownFields && l.push({ no: i, wireType: u, data: f });
      continue;
    }
    aG(e, t, c, u, n);
  }
  if (r && (u != de.EndGroup || i !== a))
    throw new Error("invalid end group tag");
  l.length > 0 && e.setUnknown(l);
}
function aG(e, t, n, r, a) {
  var o;
  switch (n.fieldKind) {
    case "scalar":
      e.set(n, hu(t, n.scalar));
      break;
    case "enum":
      const s = hu(t, O.INT32);
      if (n.enum.open)
        e.set(n, s);
      else if (n.enum.values.some((i) => i.number === s))
        e.set(n, s);
      else if (a.readUnknownFields) {
        const i = [];
        zN(s, i);
        const u = (o = e.getUnknown()) !== null && o !== void 0 ? o : [];
        u.push({
          no: n.number,
          wireType: r,
          data: new Uint8Array(i)
        }), e.setUnknown(u);
      }
      break;
    case "message":
      e.set(n, QT(t, a, n, e.get(n)));
      break;
    case "list":
      bhe(t, r, e.get(n), a);
      break;
    case "map":
      phe(t, e.get(n), a);
      break;
  }
}
function phe(e, t, n) {
  const r = t.field();
  let a, o;
  const s = e.uint32(), i = e.pos + s;
  for (; e.pos < i; ) {
    const [u] = e.tag();
    switch (u) {
      case 1:
        a = hu(e, r.mapKey);
        break;
      case 2:
        switch (r.mapKind) {
          case "scalar":
            o = hu(e, r.scalar);
            break;
          case "enum":
            o = e.int32();
            break;
          case "message":
            o = QT(e, n, r);
            break;
        }
        break;
    }
  }
  if (a === void 0 && (a = zs(r.mapKey, !1)), o === void 0)
    switch (r.mapKind) {
      case "scalar":
        o = zs(r.scalar, !1);
        break;
      case "enum":
        o = r.enum.values[0].number;
        break;
      case "message":
        o = tr(r.message, void 0, !1);
        break;
    }
  t.set(a, o);
}
function bhe(e, t, n, r) {
  var a;
  const o = n.field();
  if (o.listKind === "message") {
    n.add(QT(e, r, o));
    return;
  }
  const s = (a = o.scalar) !== null && a !== void 0 ? a : O.INT32;
  if (!(t == de.LengthDelimited && s != O.STRING && s != O.BYTES)) {
    n.add(hu(e, s));
    return;
  }
  const i = e.uint32() + e.pos;
  for (; e.pos < i; )
    n.add(hu(e, s));
}
function QT(e, t, n, r) {
  const a = n.delimitedEncoding, o = r ?? tr(n.message, void 0, !1);
  return rG(o, e, t, a, a ? n.number : e.uint32()), o;
}
function hu(e, t) {
  switch (t) {
    case O.STRING:
      return e.string();
    case O.BOOL:
      return e.bool();
    case O.DOUBLE:
      return e.double();
    case O.FLOAT:
      return e.float();
    case O.INT32:
      return e.int32();
    case O.INT64:
      return e.int64();
    case O.UINT64:
      return e.uint64();
    case O.FIXED64:
      return e.fixed64();
    case O.BYTES:
      return e.bytes();
    case O.FIXED32:
      return e.fixed32();
    case O.SFIXED32:
      return e.sfixed32();
    case O.SFIXED64:
      return e.sfixed64();
    case O.SINT64:
      return e.sint64();
    case O.UINT32:
      return e.uint32();
    case O.SINT32:
      return e.sint32();
  }
}
function oG(e, t) {
  var n;
  const r = pg(mhe, HT(e));
  return r.messageType.forEach(zT), r.dependency = (n = void 0) !== null && n !== void 0 ? n : [], zB(r, (a) => {
  }).getFile(r.name);
}
const ghe = /* @__PURE__ */ oG("Chlnb29nbGUvcHJvdG9idWYvYW55LnByb3RvEg9nb29nbGUucHJvdG9idWYiJgoDQW55EhAKCHR5cGVfdXJsGAEgASgJEg0KBXZhbHVlGAIgASgMQnYKE2NvbS5nb29nbGUucHJvdG9idWZCCEFueVByb3RvUAFaLGdvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL2FueXBiogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), hhe = /* @__PURE__ */ Mf(ghe, 0), yhe = 3, H9 = {
  writeUnknownFields: !0
};
function Nhe(e) {
  return e ? Object.assign(Object.assign({}, H9), e) : H9;
}
function sG(e, t, n) {
  return Jp(new YB(), Nhe(n), tr(e, t)).finish();
}
function Jp(e, t, n) {
  var r;
  for (const a of n.sortedFields) {
    if (!n.isSet(a)) {
      if (a.presence == yhe)
        throw new Error(`cannot encode ${a} to binary: required field not set`);
      continue;
    }
    iG(e, t, n, a);
  }
  if (t.writeUnknownFields)
    for (const { no: a, wireType: o, data: s } of (r = n.getUnknown()) !== null && r !== void 0 ? r : [])
      e.tag(a, o).raw(s);
  return e;
}
function iG(e, t, n, r) {
  var a;
  switch (r.fieldKind) {
    case "scalar":
    case "enum":
      Zp(e, n.desc.typeName, r.name, (a = r.scalar) !== null && a !== void 0 ? a : O.INT32, r.number, n.get(r));
      break;
    case "list":
      Ehe(e, t, r, n.get(r));
      break;
    case "message":
      uG(e, t, r, n.get(r));
      break;
    case "map":
      for (const [o, s] of n.get(r))
        vhe(e, t, r, o, s);
      break;
  }
}
function Zp(e, t, n, r, a, o) {
  lG(e.tag(a, The(r)), t, n, r, o);
}
function uG(e, t, n, r) {
  n.delimitedEncoding ? Jp(e.tag(n.number, de.StartGroup), t, r).tag(n.number, de.EndGroup) : Jp(e.tag(n.number, de.LengthDelimited).fork(), t, r).join();
}
function Ehe(e, t, n, r) {
  var a;
  if (n.listKind == "message") {
    for (const s of r)
      uG(e, t, n, s);
    return;
  }
  const o = (a = n.scalar) !== null && a !== void 0 ? a : O.INT32;
  if (n.packed) {
    if (!r.size)
      return;
    e.tag(n.number, de.LengthDelimited).fork();
    for (const s of r)
      lG(e, n.parent.typeName, n.name, o, s);
    e.join();
    return;
  }
  for (const s of r)
    Zp(e, n.parent.typeName, n.name, o, n.number, s);
}
function vhe(e, t, n, r, a) {
  var o;
  switch (e.tag(n.number, de.LengthDelimited).fork(), Zp(e, n.parent.typeName, n.name, n.mapKey, 1, r), n.mapKind) {
    case "scalar":
    case "enum":
      Zp(e, n.parent.typeName, n.name, (o = n.scalar) !== null && o !== void 0 ? o : O.INT32, 2, a);
      break;
    case "message":
      Jp(e.tag(2, de.LengthDelimited).fork(), t, a).join();
      break;
  }
  e.join();
}
function lG(e, t, n, r, a) {
  try {
    switch (r) {
      case O.STRING:
        e.string(a);
        break;
      case O.BOOL:
        e.bool(a);
        break;
      case O.DOUBLE:
        e.double(a);
        break;
      case O.FLOAT:
        e.float(a);
        break;
      case O.INT32:
        e.int32(a);
        break;
      case O.INT64:
        e.int64(a);
        break;
      case O.UINT64:
        e.uint64(a);
        break;
      case O.FIXED64:
        e.fixed64(a);
        break;
      case O.BYTES:
        e.bytes(a);
        break;
      case O.FIXED32:
        e.fixed32(a);
        break;
      case O.SFIXED32:
        e.sfixed32(a);
        break;
      case O.SFIXED64:
        e.sfixed64(a);
        break;
      case O.SINT64:
        e.sint64(a);
        break;
      case O.UINT32:
        e.uint32(a);
        break;
      case O.SINT32:
        e.sint32(a);
        break;
    }
  } catch (o) {
    throw o instanceof Error ? new Error(`cannot encode field ${t}.${n} to binary: ${o.message}`) : o;
  }
}
function The(e) {
  switch (e) {
    case O.BYTES:
    case O.STRING:
      return de.LengthDelimited;
    case O.DOUBLE:
    case O.FIXED64:
    case O.SFIXED64:
      return de.Bit64;
    case O.FIXED32:
    case O.SFIXED32:
    case O.FLOAT:
      return de.Bit32;
    default:
      return de.Varint;
  }
}
function Ihe(e, t, n) {
  let r = !1;
  return n || (n = Ar(hhe), r = !0), n.value = sG(e, t), n.typeUrl = Ohe(t.$typeName), r ? n : void 0;
}
function whe(e, t) {
  if (e.typeUrl === "")
    return !1;
  const n = typeof t == "string" ? t : t.typeName, r = cG(e.typeUrl);
  return n === r;
}
function _he(e, t) {
  if (e.typeUrl === "")
    return;
  const n = t.kind == "message" ? t : t.getMessage(cG(e.typeUrl));
  if (!(!n || !whe(e, n)))
    return pg(n, e.value);
}
function Ohe(e) {
  return `type.googleapis.com/${e}`;
}
function cG(e) {
  const t = e.lastIndexOf("/"), n = t >= 0 ? e.substring(t + 1) : e;
  if (!n.length)
    throw new Error(`invalid type url: ${e}`);
  return n;
}
const eI = /* @__PURE__ */ oG("Chxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvEg9nb29nbGUucHJvdG9idWYihAEKBlN0cnVjdBIzCgZmaWVsZHMYASADKAsyIy5nb29nbGUucHJvdG9idWYuU3RydWN0LkZpZWxkc0VudHJ5GkUKC0ZpZWxkc0VudHJ5EgsKA2tleRgBIAEoCRIlCgV2YWx1ZRgCIAEoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZToCOAEi6gEKBVZhbHVlEjAKCm51bGxfdmFsdWUYASABKA4yGi5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlSAASFgoMbnVtYmVyX3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASFAoKYm9vbF92YWx1ZRgEIAEoCEgAEi8KDHN0cnVjdF92YWx1ZRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3RIABIwCgpsaXN0X3ZhbHVlGAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZUgAQgYKBGtpbmQiMwoJTGlzdFZhbHVlEiYKBnZhbHVlcxgBIAMoCzIWLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSobCglOdWxsVmFsdWUSDgoKTlVMTF9WQUxVRRAAQn8KE2NvbS5nb29nbGUucHJvdG9idWZCC1N0cnVjdFByb3RvUAFaL2dvb2dsZS5nb2xhbmcub3JnL3Byb3RvYnVmL3R5cGVzL2tub3duL3N0cnVjdHBi+AEBogIDR1BCqgIeR29vZ2xlLlByb3RvYnVmLldlbGxLbm93blR5cGVzYgZwcm90bzM"), She = /* @__PURE__ */ Mf(eI, 0), fG = /* @__PURE__ */ Mf(eI, 1), Dhe = /* @__PURE__ */ Mf(eI, 2);
var rE;
(function(e) {
  e[e.NULL_VALUE = 0] = "NULL_VALUE";
})(rE || (rE = {}));
function khe(e, t) {
  mG(t, e);
  const n = Lhe(e.$unknown, t), [r, a, o] = bg(t);
  for (const s of n)
    aG(r, new CT(s.data), a, s.wireType, {
      readUnknownFields: !0
    });
  return o();
}
function Ahe(e, t, n) {
  var r;
  mG(t, e);
  const a = ((r = e.$unknown) !== null && r !== void 0 ? r : []).filter((l) => l.no !== t.number), [o, s] = bg(t, n), i = new YB();
  iG(i, { writeUnknownFields: !0 }, o, s);
  const u = new CT(i.finish());
  for (; u.pos < u.len; ) {
    const [l, c] = u.tag(), f = u.skip(c, l);
    a.push({ no: l, wireType: c, data: f });
  }
  e.$unknown = a;
}
function Lhe(e, t) {
  if (e === void 0)
    return [];
  if (t.fieldKind === "enum" || t.fieldKind === "scalar") {
    for (let n = e.length - 1; n >= 0; --n)
      if (e[n].no == t.number)
        return [e[n]];
    return [];
  }
  return e.filter((n) => n.no === t.number);
}
function bg(e, t) {
  const n = e.typeName, r = Object.assign(Object.assign({}, e), { kind: "field", parent: e.extendee, localName: n }), a = Object.assign(Object.assign({}, e.extendee), { fields: [r], members: [r], oneofs: [] }), o = Ar(a, t !== void 0 ? { [n]: t } : void 0);
  return [
    tr(a, o),
    r,
    () => {
      const s = o[n];
      if (s === void 0) {
        const i = e.message;
        return Gf(i) ? zs(i.fields[0].scalar, i.fields[0].longAsString) : Ar(i);
      }
      return s;
    }
  ];
}
function mG(e, t) {
  if (e.extendee.typeName != t.$typeName)
    throw new Error(`extension ${e.typeName} can only be applied to message ${e.extendee.typeName}`);
}
const Fhe = 3, Uhe = 2, z9 = {
  alwaysEmitImplicit: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1
};
function Rhe(e) {
  return e ? Object.assign(Object.assign({}, z9), e) : z9;
}
function $he(e, t, n) {
  return Cf(tr(e, t), Rhe(n));
}
function Phe(e, t, n) {
  var r;
  const a = $he(e, t, n);
  return JSON.stringify(a, null, (r = n?.prettySpaces) !== null && r !== void 0 ? r : 0);
}
function Cf(e, t) {
  var n;
  const r = jhe(e, t);
  if (r !== void 0)
    return r;
  const a = {};
  for (const o of e.sortedFields) {
    if (!e.isSet(o)) {
      if (o.presence == Fhe)
        throw new Error(`cannot encode ${o} to JSON: required field not set`);
      if (!t.alwaysEmitImplicit || o.presence !== Uhe)
        continue;
    }
    const s = q9(o, e.get(o), t);
    s !== void 0 && (a[Yhe(o, t)] = s);
  }
  if (t.registry) {
    const o = /* @__PURE__ */ new Set();
    for (const { no: s } of (n = e.getUnknown()) !== null && n !== void 0 ? n : [])
      if (!o.has(s)) {
        o.add(s);
        const i = t.registry.getExtensionFor(e.desc, s);
        if (!i)
          continue;
        const u = khe(e.message, i), [l, c] = bg(i, u), f = q9(c, l.get(c), t);
        f !== void 0 && (a[i.jsonName] = f);
      }
  }
  return a;
}
function q9(e, t, n) {
  switch (e.fieldKind) {
    case "scalar":
      return gg(e, t);
    case "message":
      return Cf(t, n);
    case "enum":
      return tI(e.enum, t, n.enumAsInteger);
    case "list":
      return xhe(t, n);
    case "map":
      return Vhe(t, n);
  }
}
function Vhe(e, t) {
  const n = e.field(), r = {};
  switch (n.mapKind) {
    case "scalar":
      for (const [a, o] of e)
        r[a] = gg(n, o);
      break;
    case "message":
      for (const [a, o] of e)
        r[a] = Cf(o, t);
      break;
    case "enum":
      for (const [a, o] of e)
        r[a] = tI(n.enum, o, t.enumAsInteger);
      break;
  }
  return t.alwaysEmitImplicit || e.size > 0 ? r : void 0;
}
function xhe(e, t) {
  const n = e.field(), r = [];
  switch (n.listKind) {
    case "scalar":
      for (const a of e)
        r.push(gg(n, a));
      break;
    case "enum":
      for (const a of e)
        r.push(tI(n.enum, a, t.enumAsInteger));
      break;
    case "message":
      for (const a of e)
        r.push(Cf(a, t));
      break;
  }
  return t.alwaysEmitImplicit || r.length > 0 ? r : void 0;
}
function tI(e, t, n) {
  var r;
  if (typeof t != "number")
    throw new Error(`cannot encode ${e} to JSON: expected number, got ${Me(t)}`);
  return e.typeName == "google.protobuf.NullValue" ? null : n ? t : (r = e.value[t]?.name) !== null && r !== void 0 ? r : t;
}
function gg(e, t) {
  var n, r, a, o, s, i;
  switch (e.scalar) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case O.INT32:
    case O.SFIXED32:
    case O.SINT32:
    case O.FIXED32:
    case O.UINT32:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(n = Xo(e, t)) === null || n === void 0 ? void 0 : n.message}`);
      return t;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case O.FLOAT:
    case O.DOUBLE:
      if (typeof t != "number")
        throw new Error(`cannot encode ${e} to JSON: ${(r = Xo(e, t)) === null || r === void 0 ? void 0 : r.message}`);
      return Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t;
    // string:
    case O.STRING:
      if (typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(a = Xo(e, t)) === null || a === void 0 ? void 0 : a.message}`);
      return t;
    // bool:
    case O.BOOL:
      if (typeof t != "boolean")
        throw new Error(`cannot encode ${e} to JSON: ${(o = Xo(e, t)) === null || o === void 0 ? void 0 : o.message}`);
      return t;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case O.UINT64:
    case O.FIXED64:
    case O.INT64:
    case O.SFIXED64:
    case O.SINT64:
      if (typeof t != "bigint" && typeof t != "string")
        throw new Error(`cannot encode ${e} to JSON: ${(s = Xo(e, t)) === null || s === void 0 ? void 0 : s.message}`);
      return t.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case O.BYTES:
      if (t instanceof Uint8Array)
        return ZB(t);
      throw new Error(`cannot encode ${e} to JSON: ${(i = Xo(e, t)) === null || i === void 0 ? void 0 : i.message}`);
  }
}
function Yhe(e, t) {
  return t.useProtoFieldName ? e.name : e.jsonName;
}
function jhe(e, t) {
  if (e.desc.typeName.startsWith("google.protobuf."))
    switch (e.desc.typeName) {
      case "google.protobuf.Any":
        return Bhe(e.message, t);
      case "google.protobuf.Timestamp":
        return Che(e.message);
      case "google.protobuf.Duration":
        return Ghe(e.message);
      case "google.protobuf.FieldMask":
        return Mhe(e.message);
      case "google.protobuf.Struct":
        return dG(e.message);
      case "google.protobuf.Value":
        return nI(e.message);
      case "google.protobuf.ListValue":
        return pG(e.message);
      default:
        if (Gf(e.desc)) {
          const n = e.desc.fields[0];
          return gg(n, e.get(n));
        }
        return;
    }
}
function Bhe(e, t) {
  if (e.typeUrl === "")
    return {};
  const { registry: n } = t;
  let r, a;
  if (n && (r = _he(e, n), r && (a = n.getMessage(r.$typeName))), !a || !r)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: "${e.typeUrl}" is not in the type registry`);
  let o = Cf(tr(a, r), t);
  return (a.typeName.startsWith("google.protobuf.") || o === null || Array.isArray(o) || typeof o != "object") && (o = { value: o }), o["@type"] = e.typeUrl, o;
}
function Ghe(e) {
  const t = Number(e.seconds), n = e.nanos;
  if (t > 315576e6 || t < -315576e6)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: value out of range`);
  if (t > 0 && n < 0 || t < 0 && n > 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos sign must match seconds sign`);
  let r = e.seconds.toString();
  if (n !== 0) {
    let a = Math.abs(n).toString();
    a = "0".repeat(9 - a.length) + a, a.substring(3) === "000000" ? a = a.substring(0, 3) : a.substring(6) === "000" && (a = a.substring(0, 6)), r += "." + a, n < 0 && t == 0 && (r = "-" + r);
  }
  return r + "s";
}
function Mhe(e) {
  return e.paths.map((t) => {
    if (t.match(/_[0-9]?_/g) || t.match(/[A-Z]/g))
      throw new Error(`cannot encode message ${e.$typeName} to JSON: lowerCamelCase of path name "` + t + '" is irreversible');
    return _c(t);
  }).join(",");
}
function dG(e) {
  const t = {};
  for (const [n, r] of Object.entries(e.fields))
    t[n] = nI(r);
  return t;
}
function nI(e) {
  switch (e.kind.case) {
    case "nullValue":
      return null;
    case "numberValue":
      if (!Number.isFinite(e.kind.value))
        throw new Error(`${e.$typeName} cannot be NaN or Infinity`);
      return e.kind.value;
    case "boolValue":
      return e.kind.value;
    case "stringValue":
      return e.kind.value;
    case "structValue":
      return dG(e.kind.value);
    case "listValue":
      return pG(e.kind.value);
    default:
      throw new Error(`${e.$typeName} must have a value`);
  }
}
function pG(e) {
  return e.values.map(nI);
}
function Che(e) {
  const t = Number(e.seconds) * 1e3;
  if (t < Date.parse("0001-01-01T00:00:00Z") || t > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot encode message ${e.$typeName} to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  if (e.nanos < 0)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be negative`);
  if (e.nanos > 999999999)
    throw new Error(`cannot encode message ${e.$typeName} to JSON: nanos must not be greater than 99999999`);
  let n = "Z";
  if (e.nanos > 0) {
    const r = (e.nanos + 1e9).toString().substring(1);
    r.substring(3) === "000000" ? n = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? n = "." + r.substring(0, 6) + "Z" : n = "." + r + "Z";
  }
  return new Date(t).toISOString().replace(".000Z", n);
}
const Q9 = {
  ignoreUnknownFields: !1
};
function Khe(e) {
  return e ? Object.assign(Object.assign({}, Q9), e) : Q9;
}
function Xhe(e, t, n) {
  return bG(e, Qhe(t, e.typeName), n);
}
function bG(e, t, n) {
  const r = tr(e);
  try {
    yu(r, t, Khe(n));
  } catch (a) {
    throw Oge(a) ? new Error(`cannot decode ${a.field()} from JSON: ${a.message}`, {
      cause: a
    }) : a;
  }
  return r.message;
}
function yu(e, t, n) {
  var r;
  if (eye(e, t, n))
    return;
  if (t == null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode ${e.desc} from JSON: ${Me(t)}`);
  const a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  for (const s of e.desc.fields)
    o.set(s.name, s).set(s.jsonName, s);
  for (const [s, i] of Object.entries(t)) {
    const u = o.get(s);
    if (u) {
      if (u.oneof) {
        if (i === null && u.fieldKind == "scalar")
          continue;
        const l = a.get(u.oneof);
        if (l !== void 0)
          throw new nn(u.oneof, `oneof set multiple times by ${l.name} and ${u.name}`);
        a.set(u.oneof, u);
      }
      eL(e, u, i, n);
    } else {
      let l;
      if (s.startsWith("[") && s.endsWith("]") && // biome-ignore lint/suspicious/noAssignInExpressions: no
      (l = (r = n.registry) === null || r === void 0 ? void 0 : r.getExtension(s.substring(1, s.length - 1))) && l.extendee.typeName === e.desc.typeName) {
        const [c, f, d] = bg(l);
        eL(c, f, i, n), Ahe(e.message, l, d());
      }
      if (!l && !n.ignoreUnknownFields)
        throw new Error(`cannot decode ${e.desc} from JSON: key "${s}" is unknown`);
    }
  }
}
function eL(e, t, n, r) {
  switch (t.fieldKind) {
    case "scalar":
      zhe(e, t, n);
      break;
    case "enum":
      Hhe(e, t, n, r);
      break;
    case "message":
      Zhe(e, t, n, r);
      break;
    case "list":
      Jhe(e.get(t), n, r);
      break;
    case "map":
      Whe(e.get(t), n, r);
      break;
  }
}
function Whe(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (typeof t != "object" || Array.isArray(t))
    throw new nn(r, "expected object, got " + Me(t));
  for (const [a, o] of Object.entries(t)) {
    if (o === null && !gG(r))
      throw new nn(r, "map value must not be null");
    let s;
    switch (r.mapKind) {
      case "message":
        const u = tr(r.message);
        yu(u, o, n), s = u;
        break;
      case "enum":
        if (s = rI(r.enum, o, n.ignoreUnknownFields, !0), s === hg)
          return;
        break;
      case "scalar":
        s = Ng(r, o, !0);
        break;
    }
    const i = qhe(r.mapKey, a);
    e.set(i, s);
  }
}
function Jhe(e, t, n) {
  if (t === null)
    return;
  const r = e.field();
  if (!Array.isArray(t))
    throw new nn(r, "expected Array, got " + Me(t));
  for (const a of t) {
    if (a === null && !gG(r))
      throw new nn(r, "list item must not be null");
    switch (r.listKind) {
      case "message":
        const o = tr(r.message);
        yu(o, a, n), e.add(o);
        break;
      case "enum":
        const s = rI(r.enum, a, n.ignoreUnknownFields, !0);
        s !== hg && e.add(s);
        break;
      case "scalar":
        e.add(Ng(r, a, !0));
        break;
    }
  }
}
function gG(e) {
  var t, n;
  return ((t = e.message) === null || t === void 0 ? void 0 : t.typeName) == "google.protobuf.Value" || ((n = e.enum) === null || n === void 0 ? void 0 : n.typeName) == "google.protobuf.NullValue";
}
function Zhe(e, t, n, r) {
  if (n === null && t.message.typeName != "google.protobuf.Value") {
    e.clear(t);
    return;
  }
  const a = e.isSet(t) ? e.get(t) : tr(t.message);
  yu(a, n, r), e.set(t, a);
}
function Hhe(e, t, n, r) {
  const a = rI(t.enum, n, r.ignoreUnknownFields, !1);
  a === yg ? e.clear(t) : a !== hg && e.set(t, a);
}
function zhe(e, t, n) {
  const r = Ng(t, n, !1);
  r === yg ? e.clear(t) : e.set(t, r);
}
const hg = /* @__PURE__ */ Symbol();
function rI(e, t, n, r) {
  if (t === null)
    return e.typeName == "google.protobuf.NullValue" ? 0 : r ? e.values[0].number : yg;
  switch (typeof t) {
    case "number":
      if (Number.isInteger(t))
        return t;
      break;
    case "string":
      const a = e.values.find((o) => o.name === t);
      if (a !== void 0)
        return a.number;
      if (n)
        return hg;
      break;
  }
  throw new Error(`cannot decode ${e} from JSON: ${Me(t)}`);
}
const yg = /* @__PURE__ */ Symbol();
function Ng(e, t, n) {
  if (t === null)
    return n ? zs(e.scalar, !1) : yg;
  switch (e.scalar) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case O.DOUBLE:
    case O.FLOAT:
      if (t === "NaN")
        return NaN;
      if (t === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (t === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (typeof t == "number") {
        if (Number.isNaN(t))
          throw new nn(e, "unexpected NaN number");
        if (!Number.isFinite(t))
          throw new nn(e, "unexpected infinite number");
        break;
      }
      if (typeof t == "string") {
        if (t === "" || t.trim().length !== t.length)
          break;
        const r = Number(t);
        if (!Number.isFinite(r))
          break;
        return r;
      }
      break;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case O.INT32:
    case O.FIXED32:
    case O.SFIXED32:
    case O.SINT32:
    case O.UINT32:
      return hG(t);
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case O.BYTES:
      if (typeof t == "string") {
        if (t === "")
          return new Uint8Array(0);
        try {
          return HT(t);
        } catch (r) {
          const a = r instanceof Error ? r.message : String(r);
          throw new nn(e, a);
        }
      }
      break;
  }
  return t;
}
function qhe(e, t) {
  switch (e) {
    case O.BOOL:
      switch (t) {
        case "true":
          return !0;
        case "false":
          return !1;
      }
      return t;
    case O.INT32:
    case O.FIXED32:
    case O.UINT32:
    case O.SFIXED32:
    case O.SINT32:
      return hG(t);
    default:
      return t;
  }
}
function hG(e) {
  if (typeof e == "string") {
    if (e === "" || e.trim().length !== e.length)
      return e;
    const t = Number(e);
    return Number.isNaN(t) ? e : t;
  }
  return e;
}
function Qhe(e, t) {
  try {
    return JSON.parse(e);
  } catch (n) {
    const r = n instanceof Error ? n.message : String(n);
    throw new Error(
      `cannot decode message ${t} from JSON: ${r}`,
      // @ts-expect-error we use the ES2022 error CTOR option "cause" for better stack traces
      { cause: n }
    );
  }
}
function eye(e, t, n) {
  if (!e.desc.typeName.startsWith("google.protobuf."))
    return !1;
  switch (e.desc.typeName) {
    case "google.protobuf.Any":
      return tye(e.message, t, n), !0;
    case "google.protobuf.Timestamp":
      return nye(e.message, t), !0;
    case "google.protobuf.Duration":
      return rye(e.message, t), !0;
    case "google.protobuf.FieldMask":
      return aye(e.message, t), !0;
    case "google.protobuf.Struct":
      return yG(e.message, t), !0;
    case "google.protobuf.Value":
      return aI(e.message, t), !0;
    case "google.protobuf.ListValue":
      return NG(e.message, t), !0;
    default:
      if (Gf(e.desc)) {
        const r = e.desc.fields[0];
        return t === null ? e.clear(r) : e.set(r, Ng(r, t, !0)), !0;
      }
      return !1;
  }
}
function tye(e, t, n) {
  var r;
  if (t === null || Array.isArray(t) || typeof t != "object")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: expected object but got ${Me(t)}`);
  if (Object.keys(t).length == 0)
    return;
  const a = t["@type"];
  if (typeof a != "string" || a == "")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is empty`);
  const o = a.includes("/") ? a.substring(a.lastIndexOf("/") + 1) : a;
  if (!o.length)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: "@type" is invalid`);
  const s = (r = n.registry) === null || r === void 0 ? void 0 : r.getMessage(o);
  if (!s)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${a} is not in the type registry`);
  const i = tr(s);
  if (o.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(t, "value")) {
    const u = t.value;
    yu(i, u, n);
  } else {
    const u = Object.assign({}, t);
    delete u["@type"], yu(i, u, n);
  }
  Ihe(i.desc, i.message, e);
}
function nye(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Me(t)}`);
  const n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:\.([0-9]{1,9}))?(?:Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
  if (!n)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  const r = Date.parse(
    // biome-ignore format: want this to read well
    n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z")
  );
  if (Number.isNaN(r))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: invalid RFC 3339 string`);
  if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
    throw new Error(`cannot decode message ${e.$typeName} from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
  e.seconds = te.parse(r / 1e3), e.nanos = 0, n[7] && (e.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9);
}
function rye(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Me(t)}`);
  const n = t.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
  if (n === null)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Me(t)}`);
  const r = Number(n[1]);
  if (r > 315576e6 || r < -315576e6)
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Me(t)}`);
  if (e.seconds = te.parse(r), typeof n[2] != "string")
    return;
  const a = n[2] + "0".repeat(9 - n[2].length);
  e.nanos = parseInt(a), (r < 0 || Object.is(r, -0)) && (e.nanos = -e.nanos);
}
function aye(e, t) {
  if (typeof t != "string")
    throw new Error(`cannot decode message ${e.$typeName} from JSON: ${Me(t)}`);
  if (t === "")
    return;
  function n(r) {
    if (r.includes("_"))
      throw new Error(`cannot decode message ${e.$typeName} from JSON: path names must be lowerCamelCase`);
    const a = r.replace(/[A-Z]/g, (o) => "_" + o.toLowerCase());
    return a[0] === "_" ? a.substring(1) : a;
  }
  e.paths = t.split(",").map(n);
}
function yG(e, t) {
  if (typeof t != "object" || t == null || Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Me(t)}`);
  for (const [n, r] of Object.entries(t)) {
    const a = Ar(fG);
    aI(a, r), e.fields[n] = a;
  }
}
function aI(e, t) {
  switch (typeof t) {
    case "number":
      e.kind = { case: "numberValue", value: t };
      break;
    case "string":
      e.kind = { case: "stringValue", value: t };
      break;
    case "boolean":
      e.kind = { case: "boolValue", value: t };
      break;
    case "object":
      if (t === null)
        e.kind = { case: "nullValue", value: rE.NULL_VALUE };
      else if (Array.isArray(t)) {
        const n = Ar(Dhe);
        NG(n, t), e.kind = { case: "listValue", value: n };
      } else {
        const n = Ar(She);
        yG(n, t), e.kind = { case: "structValue", value: n };
      }
      break;
    default:
      throw new Error(`cannot decode message ${e.$typeName} from JSON ${Me(t)}`);
  }
  return e;
}
function NG(e, t) {
  if (!Array.isArray(t))
    throw new Error(`cannot decode message ${e.$typeName} from JSON ${Me(t)}`);
  for (const n of t) {
    const r = Ar(fG);
    aI(r, n), e.values.push(r);
  }
}
function aE(e) {
  const t = K[e];
  return typeof t != "string" ? e.toString() : t[0].toLowerCase() + t.substring(1).replace(/[A-Z]/g, (n) => "_" + n.toLowerCase());
}
let Bm;
function oye(e) {
  if (!Bm) {
    Bm = {};
    for (const t of Object.values(K))
      typeof t != "string" && (Bm[aE(t)] = t);
  }
  return Bm[e];
}
class Ue extends Error {
  /**
   * Create a new ConnectError.
   * If no code is provided, code "unknown" is used.
   * Outgoing details are only relevant for the server side - a service may
   * raise an error with details, and it is up to the protocol implementation
   * to encode and send the details along with the error.
   */
  constructor(t, n = K.Unknown, r, a, o) {
    super(sye(t, n)), this.name = "ConnectError", Object.setPrototypeOf(this, new.target.prototype), this.rawMessage = t, this.code = n, this.metadata = new Headers(r ?? {}), this.details = a ?? [], this.cause = o;
  }
  /**
   * Convert any value - typically a caught error into a ConnectError,
   * following these rules:
   * - If the value is already a ConnectError, return it as is.
   * - If the value is an AbortError or TimeoutError from the fetch API, return
   *   the message of the error with code Canceled.
   * - For other Errors, return the error message with code Unknown by default.
   * - For other values, return the values String representation as a message,
   *   with the code Unknown by default.
   * The original value will be used for the "cause" property for the new
   * ConnectError.
   */
  static from(t, n = K.Unknown) {
    return t instanceof Ue ? t : t instanceof Error ? t.name == "AbortError" || t.name == "TimeoutError" ? new Ue(t.message, K.Canceled) : new Ue(t.message, n, void 0, void 0, t) : new Ue(String(t), n, void 0, void 0, t);
  }
  static [Symbol.hasInstance](t) {
    return t instanceof Error ? Object.getPrototypeOf(t) === Ue.prototype ? !0 : t.name === "ConnectError" && "code" in t && typeof t.code == "number" && "metadata" in t && "details" in t && Array.isArray(t.details) && "rawMessage" in t && typeof t.rawMessage == "string" && "cause" in t : !1;
  }
  findDetails(t) {
    const n = t.kind === "message" ? {
      getMessage: (a) => a === t.typeName ? t : void 0
    } : t, r = [];
    for (const a of this.details) {
      if ("desc" in a) {
        n.getMessage(a.desc.typeName) && r.push(Ar(a.desc, a.value));
        continue;
      }
      const o = n.getMessage(a.type);
      if (o)
        try {
          r.push(pg(o, a.value));
        } catch {
        }
    }
    return r;
  }
}
function sye(e, t) {
  return e.length ? `[${aE(t)}] ${e}` : `[${aE(t)}]`;
}
function iye(...e) {
  const t = new Headers();
  for (const n of e)
    n.forEach((r, a) => {
      t.append(a, r);
    });
  return t;
}
const tL = 1;
function uye(e, t, n = !1) {
  if (t > e) {
    let r = `message size is larger than configured readMaxBytes ${e}`;
    throw n && (r = `message size ${t} is larger than configured readMaxBytes ${e}`), new Ue(r, K.ResourceExhausted);
  }
}
function lye(e) {
  return new cye(e);
}
class cye {
  constructor(t) {
    this.readMaxBytes = t, this.header = new Uint8Array(5), this.headerView = new DataView(this.header.buffer), this.buf = [];
  }
  get byteLength() {
    return this.buf.reduce((t, n) => t + n.byteLength, 0);
  }
  decode(t) {
    this.buf.push(t);
    const n = [];
    for (; ; ) {
      let r = this.pop();
      if (!r)
        break;
      n.push(r);
    }
    return n;
  }
  // consume an enveloped message
  pop() {
    if (!(!this.env && (this.env = this.head(), !this.env)) && this.cons(this.env.data)) {
      const t = this.env;
      return this.env = void 0, t;
    }
  }
  // consume header
  head() {
    if (!this.cons(this.header))
      return;
    const t = this.headerView.getUint8(0), n = this.headerView.getUint32(1);
    return uye(this.readMaxBytes, n, !0), {
      flags: t,
      data: new Uint8Array(n)
    };
  }
  // consume from buffer, fill target
  cons(t) {
    const n = t.byteLength;
    if (this.byteLength < n)
      return !1;
    let r = 0;
    for (; r < n; ) {
      const a = this.buf.shift();
      a.byteLength > n - r ? (t.set(a.subarray(0, n - r), r), this.buf.unshift(a.subarray(n - r)), r += n - r) : (t.set(a, r), r += a.byteLength);
    }
    return !0;
  }
}
function fye(e) {
  let t;
  const n = lye(4294967295);
  return new ReadableStream({
    start() {
      t = e.getReader();
    },
    async pull(r) {
      let a = !1;
      for (; !a; ) {
        const o = await t.read();
        if (o.done)
          n.byteLength > 0 && r.error(new Ue("protocol error: incomplete envelope", K.InvalidArgument)), r.close();
        else
          for (const s of n.decode(o.value))
            r.enqueue(s), a = !0;
      }
    }
  });
}
function mye(e, t) {
  const n = new Uint8Array(t.length + 5);
  n.set(t, 5);
  const r = new DataView(n.buffer, n.byteOffset, n.byteLength);
  return r.setUint8(0, e), r.setUint32(1, t.length), n;
}
function dye(...e) {
  const t = new AbortController(), n = e.filter((a) => a !== void 0).concat(t.signal);
  for (const a of n) {
    if (a.aborted) {
      r.apply(a);
      break;
    }
    a.addEventListener("abort", r);
  }
  function r() {
    t.signal.aborted || t.abort(EG(this));
    for (const a of n)
      a.removeEventListener("abort", r);
  }
  return t;
}
function pye(e) {
  const t = new AbortController(), n = () => {
    t.abort(new Ue("the operation timed out", K.DeadlineExceeded));
  };
  let r;
  return e !== void 0 && (e <= 0 ? n() : r = setTimeout(n, e)), {
    signal: t.signal,
    cleanup: () => clearTimeout(r)
  };
}
function EG(e) {
  if (!e.aborted)
    return;
  if (e.reason !== void 0)
    return e.reason;
  const t = new Error("This operation was aborted");
  return t.name = "AbortError", t;
}
function nL() {
  return {
    get(e) {
      return e.id in this ? this[e.id] : e.defaultValue;
    },
    set(e, t) {
      return this[e.id] = t, this;
    },
    delete(e) {
      return delete this[e.id], this;
    }
  };
}
function rL(e, t) {
  return e.toString().replace(/\/?$/, `/${t.parent.typeName}/${t.name}`);
}
function vG(e, t) {
  return Ar(e, t);
}
function bye(e, t) {
  function n(r) {
    return r.done === !0 ? r : {
      done: r.done,
      value: vG(e, r.value)
    };
  }
  return {
    [Symbol.asyncIterator]() {
      const r = t[Symbol.asyncIterator](), a = {
        next: () => r.next().then(n)
      };
      return r.throw !== void 0 && (a.throw = (o) => r.throw(o).then(n)), r.return !== void 0 && (a.return = (o) => r.return(o).then(n)), a;
    }
  };
}
function TG(e, t) {
  if (!t)
    return e;
  for (const n of t.concat().reverse())
    e = n(e);
  return e;
}
function IG(e) {
  var t;
  const n = Object.assign({}, e);
  return (t = n.ignoreUnknownFields) !== null && t !== void 0 || (n.ignoreUnknownFields = !0), n;
}
function aL(e, t, n, r) {
  const a = t ? oL(e.input, r) : sL(e.input, n);
  return { parse: (t ? oL(e.output, r) : sL(e.output, n)).parse, serialize: a.serialize };
}
function oL(e, t) {
  return {
    parse(n) {
      try {
        return pg(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Ue(`parse binary: ${a}`, K.Internal);
      }
    },
    serialize(n) {
      try {
        return sG(e, n, t);
      } catch (r) {
        const a = r instanceof Error ? r.message : String(r);
        throw new Ue(`serialize binary: ${a}`, K.Internal);
      }
    }
  };
}
function sL(e, t) {
  var n, r;
  const a = (n = t?.textEncoder) !== null && n !== void 0 ? n : new TextEncoder(), o = (r = t?.textDecoder) !== null && r !== void 0 ? r : new TextDecoder(), s = IG(t);
  return {
    parse(i) {
      try {
        const u = o.decode(i);
        return Xhe(e, u, s);
      } catch (u) {
        throw Ue.from(u, K.InvalidArgument);
      }
    },
    serialize(i) {
      try {
        const u = Phe(e, i, s);
        return a.encode(u);
      } catch (u) {
        throw Ue.from(u, K.Internal);
      }
    }
  };
}
const gye = /^application\/(connect\+)?(?:(json)(?:; ?charset=utf-?8)?|(proto))$/i, hye = "application/proto", yye = "application/json", Nye = "application/connect+proto", Eye = "application/connect+json";
function vye(e) {
  const t = e?.match(gye);
  if (!t)
    return;
  const n = !!t[1], r = !!t[3];
  return { stream: n, binary: r };
}
function wG(e, t, n) {
  var r;
  if (t && new Headers(t).forEach((i, u) => n.metadata.append(u, i)), typeof e != "object" || e == null || Array.isArray(e))
    throw n;
  let a = n.code;
  "code" in e && typeof e.code == "string" && (a = (r = oye(e.code)) !== null && r !== void 0 ? r : a);
  const o = e.message;
  if (o != null && typeof o != "string")
    throw n;
  const s = new Ue(o ?? "", a, t);
  if ("details" in e && Array.isArray(e.details))
    for (const i of e.details) {
      if (i === null || typeof i != "object" || Array.isArray(i) || typeof i.type != "string" || typeof i.value != "string")
        throw n;
      try {
        s.details.push({
          type: i.type,
          value: HT(i.value),
          debug: i.debug
        });
      } catch {
        throw n;
      }
    }
  return s;
}
const iL = 2;
function Tye(e) {
  const t = new Ue("invalid end stream", K.Unknown);
  let n;
  try {
    n = JSON.parse(typeof e == "string" ? e : new TextDecoder().decode(e));
  } catch {
    throw t;
  }
  if (typeof n != "object" || n == null || Array.isArray(n))
    throw t;
  const r = new Headers();
  if ("metadata" in n) {
    if (typeof n.metadata != "object" || n.metadata == null || Array.isArray(n.metadata))
      throw t;
    for (const [o, s] of Object.entries(n.metadata)) {
      if (!Array.isArray(s) || s.some((i) => typeof i != "string"))
        throw t;
      for (const i of s)
        r.append(o, i);
    }
  }
  const a = "error" in n && n.error != null ? wG(n.error, r, t) : void 0;
  return { metadata: r, error: a };
}
const Hp = "Content-Type", Iye = "Content-Length", uL = "Content-Encoding", wye = "Accept-Encoding", _ye = "Connect-Timeout-Ms", _G = "Connect-Protocol-Version", Oye = "User-Agent";
function Sye(e) {
  switch (e) {
    case 400:
      return K.Internal;
    case 401:
      return K.Unauthenticated;
    case 403:
      return K.PermissionDenied;
    case 404:
      return K.Unimplemented;
    case 429:
      return K.Unavailable;
    case 502:
      return K.Unavailable;
    case 503:
      return K.Unavailable;
    case 504:
      return K.Unavailable;
    default:
      return K.Unknown;
  }
}
function lL(e) {
  const t = new Headers(), n = new Headers();
  return e.forEach((r, a) => {
    a.toLowerCase().startsWith("trailer-") ? n.append(a.substring(8), r) : t.append(a, r);
  }), [t, n];
}
const OG = "1";
function cL(e, t, n, r, a) {
  const o = new Headers(r ?? {});
  return n !== void 0 && o.set(_ye, `${n}`), o.set(Hp, e == "unary" ? t ? hye : yye : t ? Nye : Eye), o.set(_G, OG), o.has(Oye), o;
}
function fL(e, t, n, r) {
  const a = r.get(Hp), o = vye(a);
  if (n !== 200) {
    const i = new Ue(`HTTP ${n}`, Sye(n), r);
    if (e == "unary" && o && !o.binary)
      return { isUnaryError: !0, unaryError: i };
    throw i;
  }
  const s = {
    binary: t,
    stream: e !== "unary"
  };
  if (o?.binary !== s.binary || o.stream !== s.stream)
    throw new Ue(`unsupported content type ${a}`, o === void 0 ? K.Unknown : K.Internal, r);
  return { isUnaryError: !1 };
}
const mL = "application/";
function Dye(e, t) {
  return t ? ZB(e, "url") : encodeURIComponent(new TextDecoder().decode(e));
}
function kye(e, t, n) {
  let r = `?connect=v${OG}`;
  const a = e.header.get(Hp);
  a?.indexOf(mL) === 0 && (r += "&encoding=" + encodeURIComponent(a.slice(mL.length)));
  const o = e.header.get(uL);
  o !== null && o !== "identity" && (r += "&compression=" + encodeURIComponent(o), n = !0), n && (r += "&base64=1"), r += "&message=" + Dye(t, n);
  const s = e.url + r, i = new Headers(e.header);
  for (const u of [
    _G,
    Hp,
    Iye,
    uL,
    wye
  ])
    i.delete(u);
  return Object.assign(Object.assign({}, e), {
    requestMethod: "GET",
    url: s,
    header: i
  });
}
function Aye(e) {
  const t = TG(e.next, e.interceptors), [n, r, a] = SG(e), o = Object.assign(Object.assign({}, e.req), { message: vG(e.req.method.input, e.req.message), signal: n });
  return t(o).then((s) => (a(), s), r);
}
function Lye(e) {
  const t = TG(e.next, e.interceptors), [n, r, a] = SG(e), o = Object.assign(Object.assign({}, e.req), { message: bye(e.req.method.input, e.req.message), signal: n });
  let s = !1;
  return n.addEventListener("abort", function() {
    var i, u;
    const l = e.req.message[Symbol.asyncIterator]();
    s || (i = l.throw) === null || i === void 0 || i.call(l, this.reason).catch(() => {
    }), (u = l.return) === null || u === void 0 || u.call(l).catch(() => {
    });
  }), t(o).then((i) => Object.assign(Object.assign({}, i), { message: {
    [Symbol.asyncIterator]() {
      const u = i.message[Symbol.asyncIterator]();
      return {
        next() {
          return u.next().then((l) => (l.done == !0 && (s = !0, a()), l), r);
        }
        // We deliberately omit throw/return.
      };
    }
  } }), r);
}
function SG(e) {
  const { signal: t, cleanup: n } = pye(e.timeoutMs), r = dye(e.signal, t);
  return [
    r.signal,
    function(a) {
      const o = Ue.from(t.aborted ? EG(t) : a);
      return r.abort(o), n(), Promise.reject(o);
    },
    function() {
      n(), r.abort();
    }
  ];
}
function Fye() {
  try {
    new Headers();
  } catch {
    throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
  }
}
var Dc = function(e) {
  return this instanceof Dc ? (this.v = e, this) : new Dc(e);
}, Uye = function(e, t, n) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, o = [];
  return a = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), i("next"), i("throw"), i("return", s), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function s(m) {
    return function(p) {
      return Promise.resolve(p).then(m, f);
    };
  }
  function i(m, p) {
    r[m] && (a[m] = function(b) {
      return new Promise(function(g, S) {
        o.push([m, b, g, S]) > 1 || u(m, b);
      });
    }, p && (a[m] = p(a[m])));
  }
  function u(m, p) {
    try {
      l(r[m](p));
    } catch (b) {
      d(o[0][3], b);
    }
  }
  function l(m) {
    m.value instanceof Dc ? Promise.resolve(m.value.v).then(c, f) : d(o[0][2], m);
  }
  function c(m) {
    u("next", m);
  }
  function f(m) {
    u("throw", m);
  }
  function d(m, p) {
    m(p), o.shift(), o.length && u(o[0][0], o[0][1]);
  }
};
const dL = {
  redirect: "error"
};
function Rye(e) {
  var t;
  Fye();
  const n = (t = e.useBinaryFormat) !== null && t !== void 0 ? t : !1;
  return {
    async unary(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = aL(r, n, e.jsonOptions, e.binaryOptions);
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await Aye({
        interceptors: e.interceptors,
        signal: a,
        timeoutMs: o,
        req: {
          stream: !1,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: rL(e.baseUrl, r),
          header: cL(r.methodKind, n, o, s),
          contextValues: u ?? nL(),
          message: i
        },
        next: async (f) => {
          var d;
          const m = e.useHttpGet === !0 && r.idempotency === nE.NO_SIDE_EFFECTS;
          let p = null;
          m ? f = kye(f, l(f.message), n) : p = l(f.message);
          const b = await ((d = e.fetch) !== null && d !== void 0 ? d : globalThis.fetch)(f.url, Object.assign(Object.assign({}, dL), { method: f.requestMethod, headers: f.header, signal: f.signal, body: p })), { isUnaryError: g, unaryError: S } = fL(r.methodKind, n, b.status, b.headers);
          if (g)
            throw wG(await b.json(), iye(...lL(b.headers)), S);
          const [D, k] = lL(b.headers);
          return {
            stream: !1,
            service: r.parent,
            method: r,
            header: D,
            message: n ? c(new Uint8Array(await b.arrayBuffer())) : bG(r.output, await b.json(), IG(e.jsonOptions)),
            trailer: k
          };
        }
      });
    },
    async stream(r, a, o, s, i, u) {
      const { serialize: l, parse: c } = aL(r, n, e.jsonOptions, e.binaryOptions);
      function f(m, p, b, g) {
        return Uye(this, arguments, function* () {
          const S = fye(m).getReader();
          let D = !1;
          for (; ; ) {
            const k = yield Dc(S.read());
            if (k.done)
              break;
            const { flags: U, data: R } = k.value;
            if ((U & tL) === tL)
              throw new Ue("protocol error: received unsupported compressed output", K.Internal);
            if ((U & iL) === iL) {
              D = !0;
              const F = Tye(R);
              if (F.error) {
                const A = F.error;
                throw b.forEach((L, re) => {
                  A.metadata.append(re, L);
                }), A;
              }
              F.metadata.forEach((A, L) => p.set(L, A));
              continue;
            }
            yield yield Dc(c(R));
          }
          if ("throwIfAborted" in g && g.throwIfAborted(), !D)
            throw "missing EndStreamResponse";
        });
      }
      async function d(m) {
        if (r.methodKind != "server_streaming")
          throw "The fetch API does not support streaming request bodies";
        const p = await m[Symbol.asyncIterator]().next();
        if (p.done == !0)
          throw "missing request message";
        return mye(0, l(p.value));
      }
      return o = o === void 0 ? e.defaultTimeoutMs : o <= 0 ? void 0 : o, await Lye({
        interceptors: e.interceptors,
        timeoutMs: o,
        signal: a,
        req: {
          stream: !0,
          service: r.parent,
          method: r,
          requestMethod: "POST",
          url: rL(e.baseUrl, r),
          header: cL(r.methodKind, n, o, s),
          contextValues: u ?? nL(),
          message: i
        },
        next: async (m) => {
          var p;
          const b = await ((p = e.fetch) !== null && p !== void 0 ? p : globalThis.fetch)(m.url, Object.assign(Object.assign({}, dL), { method: m.requestMethod, headers: m.header, signal: m.signal, body: await d(m.message) }));
          if (fL(r.methodKind, n, b.status, b.headers), b.body === null)
            throw "missing response body";
          const g = new Headers();
          return Object.assign(Object.assign({}, m), { header: b.headers, trailer: g, message: f(b.body, g, b.headers, m.signal) });
        }
      });
    }
  };
}
Rye({
  baseUrl: "/api",
  useBinaryFormat: !0,
  fetch: (e, t) => {
    const n = t?.headers ?? {};
    return fetch(e, {
      ...t,
      headers: {
        ...n,
        "qt-widget-id": window.qtWidgetId
      }
    });
  }
});
const vt = /* @__PURE__ */ Symbol(), $ye = !1;
var Pye = Array.isArray, Vye = Array.prototype.indexOf, ty = Object.getOwnPropertyDescriptor, xye = Object.prototype, Yye = Array.prototype, jye = Object.getPrototypeOf;
function Bye(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function Gye() {
  var e, t, n = new Promise((r, a) => {
    e = r, t = a;
  });
  return { promise: n, resolve: e, reject: t };
}
const pn = 2, Mye = 4, Cye = 1 << 24, ku = 16, Kf = 32, Xf = 64, oI = 128, oa = 512, At = 1024, Lr = 2048, sa = 4096, yd = 8192, As = 16384, Kye = 32768, pL = 1 << 17, DG = 1 << 18, qs = 32768, oE = 1 << 21, kG = 1 << 22, kc = 1 << 23, ny = /* @__PURE__ */ Symbol("$state"), AG = new class extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
function Xye() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function Wye() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function Jye() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function Zye() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
function Hye(e) {
  return e === this.v;
}
let zye = !1;
function LG() {
  return !0;
}
let ki = [];
function qye() {
  var e = ki;
  ki = [], Bye(e);
}
function Qye(e) {
  if (ki.length === 0) {
    var t = ki;
    queueMicrotask(() => {
      t === ki && qye();
    });
  }
  ki.push(e);
}
function eNe(e) {
  var t = rn;
  if (t === null)
    return we.f |= kc, e;
  if ((t.f & Kye) === 0) {
    if ((t.f & oI) === 0)
      throw e;
    t.b.error(e);
  } else
    FG(e, t);
}
function FG(e, t) {
  for (; t !== null; ) {
    if ((t.f & oI) !== 0)
      try {
        t.b.error(e);
        return;
      } catch (n) {
        e = n;
      }
    t = t.parent;
  }
  throw e;
}
const Gm = /* @__PURE__ */ new Set();
let et = null, Kn = null, Br = [], sI = null, sE = !1;
class Ac {
  committed = !1;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #r = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #a = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #e = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #t = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #i = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #o = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #s = /* @__PURE__ */ new Set();
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = !1;
  is_deferred() {
    return this.is_fork || this.#t > 0;
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    Br = [], this.apply();
    var n = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: []
    };
    for (const r of t)
      this.#u(r, n);
    this.is_fork || this.#c(), this.is_deferred() ? (this.#n(n.effects), this.#n(n.render_effects)) : (et = null, bL(n.render_effects), bL(n.effects), this.#i?.resolve()), Kn = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #u(t, n) {
    t.f ^= At;
    for (var r = t.first; r !== null; ) {
      var a = r.f, o = (a & (Kf | Xf)) !== 0, s = o && (a & At) !== 0, i = s || (a & yd) !== 0 || this.skipped_effects.has(r);
      if ((r.f & oI) !== 0 && r.b?.is_pending() && (n = {
        parent: n,
        effect: r,
        effects: [],
        render_effects: []
      }), !i && r.fn !== null) {
        o ? r.f ^= At : (a & Mye) !== 0 ? n.effects.push(r) : Jf(r) && ((r.f & ku) !== 0 && this.#o.add(r), tb(r));
        var u = r.first;
        if (u !== null) {
          r = u;
          continue;
        }
      }
      var l = r.parent;
      for (r = r.next; r === null && l !== null; )
        l === n.effect && (this.#n(n.effects), this.#n(n.render_effects), n = /** @type {EffectTarget} */
        n.parent), r = l.next, l = l.parent;
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #n(t) {
    for (const n of t)
      (n.f & Lr) !== 0 ? this.#o.add(n) : (n.f & sa) !== 0 && this.#s.add(n), this.#l(n.deps), an(n, At);
  }
  /**
   * @param {Value[] | null} deps
   */
  #l(t) {
    if (t !== null)
      for (const n of t)
        (n.f & pn) === 0 || (n.f & qs) === 0 || (n.f ^= qs, this.#l(
          /** @type {Derived} */
          n.deps
        ));
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, n) {
    this.previous.has(t) || this.previous.set(t, n), (t.f & kc) === 0 && (this.current.set(t, t.v), Kn?.set(t, t.v));
  }
  activate() {
    et = this, this.apply();
  }
  deactivate() {
    et === this && (et = null, Kn = null);
  }
  flush() {
    if (this.activate(), Br.length > 0) {
      if (tNe(), et !== null && et !== this)
        return;
    } else this.#e === 0 && this.process([]);
    this.deactivate();
  }
  discard() {
    for (const t of this.#a) t(this);
    this.#a.clear();
  }
  #c() {
    if (this.#t === 0) {
      for (const t of this.#r) t();
      this.#r.clear();
    }
    this.#e === 0 && this.#f();
  }
  #f() {
    if (Gm.size > 1) {
      this.previous.clear();
      var t = Kn, n = !0, r = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: []
      };
      for (const o of Gm) {
        if (o === this) {
          n = !1;
          continue;
        }
        const s = [];
        for (const [u, l] of this.current) {
          if (o.current.has(u))
            if (n && l !== o.current.get(u))
              o.current.set(u, l);
            else
              continue;
          s.push(u);
        }
        if (s.length === 0)
          continue;
        const i = [...o.current.keys()].filter((u) => !this.current.has(u));
        if (i.length > 0) {
          var a = Br;
          Br = [];
          const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
          for (const c of s)
            UG(c, i, u, l);
          if (Br.length > 0) {
            et = o, o.apply();
            for (const c of Br)
              o.#u(c, r);
            o.deactivate();
          }
          Br = a;
        }
      }
      et = null, Kn = t;
    }
    this.committed = !0, Gm.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(t) {
    this.#e += 1, t && (this.#t += 1);
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(t) {
    this.#e -= 1, t && (this.#t -= 1), this.revive();
  }
  revive() {
    for (const t of this.#o)
      this.#s.delete(t), an(t, Lr), Lc(t);
    for (const t of this.#s)
      an(t, sa), Lc(t);
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(t) {
    this.#r.add(t);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(t) {
    this.#a.add(t);
  }
  settled() {
    return (this.#i ??= Gye()).promise;
  }
  static ensure() {
    if (et === null) {
      const t = et = new Ac();
      Gm.add(et), Ac.enqueue(() => {
        et === t && t.flush();
      });
    }
    return et;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    Qye(t);
  }
  apply() {
  }
}
function tNe() {
  var e = Ls;
  sE = !0;
  try {
    var t = 0;
    for (qp(!0); Br.length > 0; ) {
      var n = Ac.ensure();
      if (t++ > 1e3) {
        var r, a;
        nNe();
      }
      n.process(Br), go.clear();
    }
  } finally {
    sE = !1, qp(e), sI = null;
  }
}
function nNe() {
  try {
    Xye();
  } catch (e) {
    FG(e, sI);
  }
}
let Oa = null;
function bL(e) {
  var t = e.length;
  if (t !== 0) {
    for (var n = 0; n < t; ) {
      var r = e[n++];
      if ((r.f & (As | yd)) === 0 && Jf(r) && (Oa = /* @__PURE__ */ new Set(), tb(r), r.deps === null && r.first === null && r.nodes === null && (r.teardown === null && r.ac === null ? GG(r) : r.fn = null), Oa?.size > 0)) {
        go.clear();
        for (const a of Oa) {
          if ((a.f & (As | yd)) !== 0) continue;
          const o = [a];
          let s = a.parent;
          for (; s !== null; )
            Oa.has(s) && (Oa.delete(s), o.push(s)), s = s.parent;
          for (let i = o.length - 1; i >= 0; i--) {
            const u = o[i];
            (u.f & (As | yd)) === 0 && tb(u);
          }
        }
        Oa.clear();
      }
    }
    Oa = null;
  }
}
function UG(e, t, n, r) {
  if (!n.has(e) && (n.add(e), e.reactions !== null))
    for (const a of e.reactions) {
      const o = a.f;
      (o & pn) !== 0 ? UG(
        /** @type {Derived} */
        a,
        t,
        n,
        r
      ) : (o & (kG | ku)) !== 0 && (o & Lr) === 0 && RG(a, t, r) && (an(a, Lr), Lc(
        /** @type {Effect} */
        a
      ));
    }
}
function RG(e, t, n) {
  const r = n.get(e);
  if (r !== void 0) return r;
  if (e.deps !== null)
    for (const a of e.deps) {
      if (t.includes(a))
        return !0;
      if ((a.f & pn) !== 0 && RG(
        /** @type {Derived} */
        a,
        t,
        n
      ))
        return n.set(
          /** @type {Derived} */
          a,
          !0
        ), !0;
    }
  return n.set(e, !1), !1;
}
function Lc(e) {
  for (var t = sI = e; t.parent !== null; ) {
    t = t.parent;
    var n = t.f;
    if (sE && t === rn && (n & ku) !== 0 && (n & DG) === 0)
      return;
    if ((n & (Xf | Kf)) !== 0) {
      if ((n & At) === 0) return;
      t.f ^= At;
    }
  }
  Br.push(t);
}
function $G(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var n = 0; n < t.length; n += 1)
      uI(
        /** @type {Effect} */
        t[n]
      );
  }
}
function rNe(e) {
  for (var t = e.parent; t !== null; ) {
    if ((t.f & pn) === 0)
      return (t.f & As) === 0 ? (
        /** @type {Effect} */
        t
      ) : null;
    t = t.parent;
  }
  return null;
}
function iI(e) {
  var t, n = rn;
  Qp(rNe(e));
  try {
    e.f &= ~qs, $G(e), t = XG(e);
  } finally {
    Qp(n);
  }
  return t;
}
function PG(e) {
  var t = iI(e);
  if (e.equals(t) || (et?.is_fork || (e.v = t), e.wv = CG()), !Wf)
    if (Kn !== null)
      (zp() || et?.is_fork) && Kn.set(e, t);
    else {
      var n = (e.f & oa) === 0 ? sa : At;
      an(e, n);
    }
}
let iE = /* @__PURE__ */ new Set();
const go = /* @__PURE__ */ new Map();
let VG = !1;
function aNe(e, t) {
  var n = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: Hye,
    rv: 0,
    wv: 0
  };
  return n;
}
// @__NO_SIDE_EFFECTS__
function ro(e, t) {
  const n = aNe(e);
  return fNe(n), n;
}
function Wo(e, t, n = !1) {
  we !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!rs || (we.f & pL) !== 0) && LG() && (we.f & (pn | ku | kG | pL)) !== 0 && !Xa?.includes(e) && Zye();
  let r = n ? Ai(t) : t;
  return oNe(e, r);
}
function oNe(e, t) {
  if (!e.equals(t)) {
    var n = e.v;
    Wf ? go.set(e, t) : go.set(e, n), e.v = t;
    var r = Ac.ensure();
    r.capture(e, n), (e.f & pn) !== 0 && ((e.f & Lr) !== 0 && iI(
      /** @type {Derived} */
      e
    ), an(e, (e.f & oa) !== 0 ? At : sa)), e.wv = CG(), xG(e, Lr), rn !== null && (rn.f & At) !== 0 && (rn.f & (Kf | Xf)) === 0 && ($n === null ? mNe([e]) : $n.push(e)), !r.is_fork && iE.size > 0 && !VG && sNe();
  }
  return t;
}
function sNe() {
  VG = !1;
  var e = Ls;
  qp(!0);
  const t = Array.from(iE);
  try {
    for (const n of t)
      (n.f & At) !== 0 && an(n, sa), Jf(n) && tb(n);
  } finally {
    qp(e);
  }
  iE.clear();
}
function ry(e) {
  Wo(e, e.v + 1);
}
function xG(e, t) {
  var n = e.reactions;
  if (n !== null)
    for (var r = n.length, a = 0; a < r; a++) {
      var o = n[a], s = o.f, i = (s & Lr) === 0;
      if (i && an(o, t), (s & pn) !== 0) {
        var u = (
          /** @type {Derived} */
          o
        );
        Kn?.delete(u), (s & qs) === 0 && (s & oa && (o.f |= qs), xG(u, sa));
      } else i && ((s & ku) !== 0 && Oa !== null && Oa.add(
        /** @type {Effect} */
        o
      ), Lc(
        /** @type {Effect} */
        o
      ));
    }
}
function Ai(e) {
  if (typeof e != "object" || e === null || ny in e)
    return e;
  const t = jye(e);
  if (t !== xye && t !== Yye)
    return e;
  var n = /* @__PURE__ */ new Map(), r = Pye(e), a = /* @__PURE__ */ ro(0), o = Fs, s = (i) => {
    if (Fs === o)
      return i();
    var u = we, l = Fs;
    Nu(null), hL(o);
    var c = i();
    return Nu(u), hL(l), c;
  };
  return r && n.set("length", /* @__PURE__ */ ro(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(i, u, l) {
        (!("value" in l) || l.configurable === !1 || l.enumerable === !1 || l.writable === !1) && Wye();
        var c = n.get(u);
        return c === void 0 ? c = s(() => {
          var f = /* @__PURE__ */ ro(l.value);
          return n.set(u, f), f;
        }) : Wo(c, l.value, !0), !0;
      },
      deleteProperty(i, u) {
        var l = n.get(u);
        if (l === void 0) {
          if (u in i) {
            const c = s(() => /* @__PURE__ */ ro(vt));
            n.set(u, c), ry(a);
          }
        } else
          Wo(l, vt), ry(a);
        return !0;
      },
      get(i, u, l) {
        if (u === ny)
          return e;
        var c = n.get(u), f = u in i;
        if (c === void 0 && (!f || ty(i, u)?.writable) && (c = s(() => {
          var m = Ai(f ? i[u] : vt), p = /* @__PURE__ */ ro(m);
          return p;
        }), n.set(u, c)), c !== void 0) {
          var d = Mm(c);
          return d === vt ? void 0 : d;
        }
        return Reflect.get(i, u, l);
      },
      getOwnPropertyDescriptor(i, u) {
        var l = Reflect.getOwnPropertyDescriptor(i, u);
        if (l && "value" in l) {
          var c = n.get(u);
          c && (l.value = Mm(c));
        } else if (l === void 0) {
          var f = n.get(u), d = f?.v;
          if (f !== void 0 && d !== vt)
            return {
              enumerable: !0,
              configurable: !0,
              value: d,
              writable: !0
            };
        }
        return l;
      },
      has(i, u) {
        if (u === ny)
          return !0;
        var l = n.get(u), c = l !== void 0 && l.v !== vt || Reflect.has(i, u);
        if (l !== void 0 || rn !== null && (!c || ty(i, u)?.writable)) {
          l === void 0 && (l = s(() => {
            var d = c ? Ai(i[u]) : vt, m = /* @__PURE__ */ ro(d);
            return m;
          }), n.set(u, l));
          var f = Mm(l);
          if (f === vt)
            return !1;
        }
        return c;
      },
      set(i, u, l, c) {
        var f = n.get(u), d = u in i;
        if (r && u === "length")
          for (var m = l; m < /** @type {Source<number>} */
          f.v; m += 1) {
            var p = n.get(m + "");
            p !== void 0 ? Wo(p, vt) : m in i && (p = s(() => /* @__PURE__ */ ro(vt)), n.set(m + "", p));
          }
        if (f === void 0)
          (!d || ty(i, u)?.writable) && (f = s(() => /* @__PURE__ */ ro(void 0)), Wo(f, Ai(l)), n.set(u, f));
        else {
          d = f.v !== vt;
          var b = s(() => Ai(l));
          Wo(f, b);
        }
        var g = Reflect.getOwnPropertyDescriptor(i, u);
        if (g?.set && g.set.call(c, l), !d) {
          if (r && typeof u == "string") {
            var S = (
              /** @type {Source<number>} */
              n.get("length")
            ), D = Number(u);
            Number.isInteger(D) && D >= S.v && Wo(S, D + 1);
          }
          ry(a);
        }
        return !0;
      },
      ownKeys(i) {
        Mm(a);
        var u = Reflect.ownKeys(i).filter((f) => {
          var d = n.get(f);
          return d === void 0 || d.v !== vt;
        });
        for (var [l, c] of n)
          c.v !== vt && !(l in i) && u.push(l);
        return u;
      },
      setPrototypeOf() {
        Jye();
      }
    }
  );
}
var iNe;
// @__NO_SIDE_EFFECTS__
function uNe(e) {
  return (
    /** @type {TemplateNode | null} */
    iNe.call(e)
  );
}
function YG(e) {
  var t = we, n = rn;
  Nu(null), Qp(null);
  try {
    return e();
  } finally {
    Nu(t), Qp(n);
  }
}
function zp() {
  return we !== null && !rs;
}
function jG(e) {
  var t = e.teardown;
  if (t !== null) {
    const n = Wf, r = we;
    gL(!0), Nu(null);
    try {
      t.call(null);
    } finally {
      gL(n), Nu(r);
    }
  }
}
function BG(e, t = !1) {
  var n = e.first;
  for (e.first = e.last = null; n !== null; ) {
    const a = n.ac;
    a !== null && YG(() => {
      a.abort(AG);
    });
    var r = n.next;
    (n.f & Xf) !== 0 ? n.parent = null : uI(n, t), n = r;
  }
}
function lNe(e) {
  for (var t = e.first; t !== null; ) {
    var n = t.next;
    (t.f & Kf) === 0 && uI(t), t = n;
  }
}
function uI(e, t = !0) {
  var n = !1;
  (t || (e.f & DG) !== 0) && e.nodes !== null && e.nodes.end !== null && (cNe(
    e.nodes.start,
    /** @type {TemplateNode} */
    e.nodes.end
  ), n = !0), BG(e, t && !n), eb(e, 0), an(e, As);
  var r = e.nodes && e.nodes.t;
  if (r !== null)
    for (const o of r)
      o.stop();
  jG(e);
  var a = e.parent;
  a !== null && a.first !== null && GG(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes = e.ac = null;
}
function cNe(e, t) {
  for (; e !== null; ) {
    var n = e === t ? null : /* @__PURE__ */ uNe(e);
    e.remove(), e = n;
  }
}
function GG(e) {
  var t = e.parent, n = e.prev, r = e.next;
  n !== null && (n.next = r), r !== null && (r.prev = n), t !== null && (t.first === e && (t.first = r), t.last === e && (t.last = n));
}
let Ls = !1;
function qp(e) {
  Ls = e;
}
let Wf = !1;
function gL(e) {
  Wf = e;
}
let we = null, rs = !1;
function Nu(e) {
  we = e;
}
let rn = null;
function Qp(e) {
  rn = e;
}
let Xa = null;
function fNe(e) {
  we !== null && (Xa === null ? Xa = [e] : Xa.push(e));
}
let ct = null, wn = 0, $n = null;
function mNe(e) {
  $n = e;
}
let MG = 1, Fc = 0, Fs = Fc;
function hL(e) {
  Fs = e;
}
function CG() {
  return ++MG;
}
function Jf(e) {
  var t = e.f;
  if ((t & Lr) !== 0)
    return !0;
  if (t & pn && (e.f &= ~qs), (t & sa) !== 0) {
    var n = e.deps;
    if (n !== null)
      for (var r = n.length, a = 0; a < r; a++) {
        var o = n[a];
        if (Jf(
          /** @type {Derived} */
          o
        ) && PG(
          /** @type {Derived} */
          o
        ), o.wv > e.wv)
          return !0;
      }
    (t & oa) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    Kn === null && an(e, At);
  }
  return !1;
}
function KG(e, t, n = !0) {
  var r = e.reactions;
  if (r !== null && !Xa?.includes(e))
    for (var a = 0; a < r.length; a++) {
      var o = r[a];
      (o.f & pn) !== 0 ? KG(
        /** @type {Derived} */
        o,
        t,
        !1
      ) : t === o && (n ? an(o, Lr) : (o.f & At) !== 0 && an(o, sa), Lc(
        /** @type {Effect} */
        o
      ));
    }
}
function XG(e) {
  var t = ct, n = wn, r = $n, a = we, o = Xa, s = rs, i = Fs, u = e.f;
  ct = /** @type {null | Value[]} */
  null, wn = 0, $n = null, we = (u & (Kf | Xf)) === 0 ? e : null, Xa = null, e.ctx, rs = !1, Fs = ++Fc, e.ac !== null && (YG(() => {
    e.ac.abort(AG);
  }), e.ac = null);
  try {
    e.f |= oE;
    var l = (
      /** @type {Function} */
      e.fn
    ), c = l(), f = e.deps;
    if (ct !== null) {
      var d;
      if (eb(e, wn), f !== null && wn > 0)
        for (f.length = wn + ct.length, d = 0; d < ct.length; d++)
          f[wn + d] = ct[d];
      else
        e.deps = f = ct;
      if (zp() && (e.f & oa) !== 0)
        for (d = wn; d < f.length; d++)
          (f[d].reactions ??= []).push(e);
    } else f !== null && wn < f.length && (eb(e, wn), f.length = wn);
    if (LG() && $n !== null && !rs && f !== null && (e.f & (pn | sa | Lr)) === 0)
      for (d = 0; d < /** @type {Source[]} */
      $n.length; d++)
        KG(
          $n[d],
          /** @type {Effect} */
          e
        );
    return a !== null && a !== e && (Fc++, $n !== null && (r === null ? r = $n : r.push(.../** @type {Source[]} */
    $n))), (e.f & kc) !== 0 && (e.f ^= kc), c;
  } catch (m) {
    return eNe(m);
  } finally {
    e.f ^= oE, ct = t, wn = n, $n = r, we = a, Xa = o, rs = s, Fs = i;
  }
}
function dNe(e, t) {
  let n = t.reactions;
  if (n !== null) {
    var r = Vye.call(n, e);
    if (r !== -1) {
      var a = n.length - 1;
      a === 0 ? n = t.reactions = null : (n[r] = n[a], n.pop());
    }
  }
  n === null && (t.f & pn) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (ct === null || !ct.includes(t)) && (an(t, sa), (t.f & oa) !== 0 && (t.f ^= oa, t.f &= ~qs), $G(
    /** @type {Derived} **/
    t
  ), eb(
    /** @type {Derived} **/
    t,
    0
  ));
}
function eb(e, t) {
  var n = e.deps;
  if (n !== null)
    for (var r = t; r < n.length; r++)
      dNe(e, n[r]);
}
function tb(e) {
  var t = e.f;
  if ((t & As) === 0) {
    an(e, At);
    var n = rn, r = Ls;
    rn = e, Ls = !0;
    try {
      (t & (ku | Cye)) !== 0 ? lNe(e) : BG(e), jG(e);
      var a = XG(e);
      e.teardown = typeof a == "function" ? a : null, e.wv = MG;
      var o;
      $ye && zye && (e.f & Lr) !== 0 && e.deps;
    } finally {
      Ls = r, rn = n;
    }
  }
}
function Mm(e) {
  var t = e.f, n = (t & pn) !== 0;
  if (we !== null && !rs) {
    var r = rn !== null && (rn.f & As) !== 0;
    if (!r && !Xa?.includes(e)) {
      var a = we.deps;
      if ((we.f & oE) !== 0)
        e.rv < Fc && (e.rv = Fc, ct === null && a !== null && a[wn] === e ? wn++ : ct === null ? ct = [e] : ct.includes(e) || ct.push(e));
      else {
        (we.deps ??= []).push(e);
        var o = e.reactions;
        o === null ? e.reactions = [we] : o.includes(we) || o.push(we);
      }
    }
  }
  if (Wf) {
    if (go.has(e))
      return go.get(e);
    if (n) {
      var s = (
        /** @type {Derived} */
        e
      ), i = s.v;
      return ((s.f & At) === 0 && s.reactions !== null || JG(s)) && (i = iI(s)), go.set(s, i), i;
    }
  } else n && (!Kn?.has(e) || et?.is_fork && !zp()) && (s = /** @type {Derived} */
  e, Jf(s) && PG(s), Ls && zp() && (s.f & oa) === 0 && WG(s));
  if (Kn?.has(e))
    return Kn.get(e);
  if ((e.f & kc) !== 0)
    throw e.v;
  return e.v;
}
function WG(e) {
  if (e.deps !== null) {
    e.f ^= oa;
    for (const t of e.deps)
      (t.reactions ??= []).push(e), (t.f & pn) !== 0 && (t.f & oa) === 0 && WG(
        /** @type {Derived} */
        t
      );
  }
}
function JG(e) {
  if (e.v === vt) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (go.has(t) || (t.f & pn) !== 0 && JG(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
const pNe = -7169;
function an(e, t) {
  e.f = e.f & pNe | t;
}
function ZG() {
  return {
    isDark: document.documentElement.classList.contains("night-mode")
  };
}
const bNe = Ai(ZG()), gNe = new MutationObserver((e, t) => {
  bNe.isDark = ZG().isDark;
});
gNe.observe(document.documentElement, { attributeFilter: ["class"] });
var hNe = /* @__PURE__ */ D5('<div><div><div class="svelte-15g82xt"></div> <div class="svelte-15g82xt"></div> <div class="svelte-15g82xt"></div> <div class="svelte-15g82xt"></div></div> <div class="progress-label svelte-15g82xt"> </div></div>');
function INe(e, t) {
  qK(t, !0);
  let n = Ag(t, "label", 3, "Loading..."), r = Ag(t, "size", 3, 80), a = Ag(t, "center", 3, !0);
  var o = hNe();
  let s;
  var i = dw(o);
  let u;
  var l = p5(i, 2), c = dw(l);
  N5(() => {
    s = hw(o, 1, "progress-container svelte-15g82xt", null, s, { centered: a() }), U5(o, `--size: ${r() ?? ""}px`), u = hw(i, 1, "spinner svelte-15g82xt", null, u, { nightMode: N4.isDark }), A5(c, n());
  }), k5(e, o), QK();
}
export {
  INe as Spinner,
  yNe as bridgeCommand,
  TNe as checkNightMode,
  ENe as createProtoClient,
  R5 as pageTheme,
  NNe as promiseWithResolver
};
